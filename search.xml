<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDE答案]]></title>
    <url>%2F2020%2F02%2F29%2FSDE%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[K Smallest In Unsorted Array 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// min heap: offline算法// Time: O((n+k)logn)// Space: O(n)public class Solution &#123; public int[] kSmallest(int[] array, int k) &#123; // Write your solution here if (array.length == 0 || k == 0) &#123; return new int[0]; &#125; PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; array.length; i++) &#123; minHeap.offer(array[i]); &#125; int[] result = new int[k]; for (int j = 0; j &lt; k; j++) &#123; result[j] = minHeap.poll(); &#125; return result; &#125;&#125;// priorityqueue heapify O(n)建堆public class Solution &#123; public int[] kSmallest(int[] array, int k) &#123; // Write your solution here if (array.length == 0 || k == 0) &#123; return new int[0]; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; array.length; i++) &#123; list.add(array[i]); &#125; PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(list); int[] result = new int[k]; for (int j = 0; j &lt; k; j++) &#123; result[j] = minHeap.poll(); &#125; return result; &#125;&#125;// max heap: online算法// Time: O((n+k)logk)// Space: O(k)public class Solution &#123; public int[] kSmallest(int[] array, int k) &#123; // Write your solution here if (array.length == 0 || k == 0) &#123; return new int[0]; &#125; PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(k, Collections.reverseOrder()); for (int i = 0; i &lt; array.length; i++) &#123; if (i &lt; k) &#123; maxHeap.offer(array[i]); &#125; else if (array[i] &lt; maxHeap.peek()) &#123; maxHeap.poll(); maxHeap.offer(array[i]); &#125; &#125; int[] result = new int[k]; for (int j = k - 1; j &gt;= 0; j--) &#123; result[j] = maxHeap.poll(); &#125; return result; &#125;&#125; Rainbow Sort 1234567891011121314151617181920212223242526public class Solution &#123; public int[] rainbowSort(int[] array) &#123; // Write your solution here int i = 0; int j = 0; int k = array.length - 1; while (j &lt;= k) &#123; if (array[j] == -1) &#123; swap(array, i, j); i++; j++; &#125; else if (array[j] == 0) &#123; j++; &#125; else if (array[j] == 1) &#123; swap(array, j, k); k--; &#125; &#125; return array; &#125; private void swap(int[] array, int i, int j) &#123; int tmp = array[i]; array[i] = array[j]; array[j] = tmp; &#125;&#125; Overview Array and Sorting Algorithms 4. Selection Sort 1234567891011121314151617181920212223242526272829// 4. Selection Sort// selection sort an array a[] with size n.public class Solution &#123; public int[] solve(int[] array) &#123; // Write your solution here if (array == null || array.length &lt;= 1) &#123; return array; &#125; // outer loop: how many iterations for (int i = 0; i &lt; array.length - 1; i++) &#123; int minIndex = i; // inner loop: find the global min from the rest elements. for (int j = i; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; // record the index of the smallest element. minIndex = j; &#125; &#125; swap(array, i, minIndex); &#125; return array; &#125; private void swap(int[] array, int i, int minIndex) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125;&#125; 279. Sort With 3 Stacks 123456789101112131415161718192021222324252627282930// 279. Sort With 3 Stackspublic class Solution &#123; public void sort(LinkedList&lt;Integer&gt; s1) &#123; LinkedList&lt;Integer&gt; s2 = new LinkedList&lt;Integer&gt;(); LinkedList&lt;Integer&gt; s3 = new LinkedList&lt;Integer&gt;(); // Write your solution here. while (!s1.isEmpty() || !s2.isEmpty()) &#123; int globalMin = Integer.MAX_VALUE; while (!s1.isEmpty()) &#123; int temp = s1.pop(); globalMin = temp &lt; globalMin ? temp : globalMin; s2.push(temp); &#125; while (!s2.isEmpty()) &#123; int temp = s2.pop(); if (temp != globalMin) &#123; s1.push(temp); &#125; else &#123; s3.push(globalMin); &#125; &#125; &#125; while (!s3.isEmpty()) &#123; s1.push(s3.pop()); &#125; &#125;&#125;// time: O(n^2), space: O(n) 280. Sort With 2 Stacks 123456789101112131415161718192021222324252627282930313233343536// 280. Sort With 2 Stackspublic class Solution &#123; public void sort(LinkedList&lt;Integer&gt; s1) &#123; LinkedList&lt;Integer&gt; s2 = new LinkedList&lt;Integer&gt;(); // Write your solution here. int cnt = 0; while (!s1.isEmpty()) &#123; int globalMin = Integer.MAX_VALUE; while (!s1.isEmpty()) &#123; int temp = s1.pop(); if (temp &lt; globalMin) &#123; globalMin = temp; &#125; s2.push(temp); &#125; while (!s2.isEmpty() &amp;&amp; s2.peek() &gt;= globalMin) &#123; int temp = s2.pop(); if (temp == globalMin) &#123; cnt++; &#125; else &#123; s1.push(temp); &#125; &#125; while (cnt &gt; 0) &#123; s2.push(globalMin); cnt--; &#125; &#125; while (!s2.isEmpty()) &#123; s1.push(s2.pop()); &#125; &#125;&#125;// time: O(n^2), space: O(n) 9. Merge Sort 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 9. Merge Sortpublic class Solution &#123; public int[] mergeSort(int[] array) &#123; // Write your solution here if (array == null || array.length &lt;= 1) &#123; return array; &#125; int[] temp = new int[array.length]; helper(array, temp, 0, array.length - 1); return array; &#125; private void helper(int[] array, int[] temp, int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; helper(array, temp, left, mid); helper(array, temp, mid + 1, right); merge(array, temp, left, mid, right); &#125; private void merge(int[] array, int[] temp, int left, int mid, int right) &#123; int leftIndex = left; int rightIndex = mid + 1; int index = left; while (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= right) &#123; if (array[leftIndex] &lt; array[rightIndex]) &#123; temp[index++] = array[leftIndex++]; &#125; else &#123; temp[index++] = array[rightIndex++]; &#125; &#125; while (leftIndex &lt;= mid) &#123; temp[index++] = array[leftIndex++]; &#125; while (rightIndex &lt;= right) &#123; temp[index++] = array[rightIndex++]; &#125; // copy temp back to array // right is included for (index = left; index &lt;= right; index++) &#123; array[index] = temp[index]; &#125; &#125;&#125; 29. Merge Sort Linked List 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 29. Merge Sort Linked List/** * class ListNode &#123; * public int value; * public ListNode next; * public ListNode(int value) &#123; * this.value = value; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode mergeSort(ListNode head) &#123; // Write your solution here if (head == null || head.next == null) &#123; return head; &#125; ListNode left = head; ListNode mid = finMid(head); left = mergeSort(left); mid = mergeSort(mid); head = merge（left, mid); return head; &#125; private ListNode findMid(ListNode head) &#123; ListNode slow = head, fast = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; ListNode mid = slow.next; slow.next = null; &#125; private ListNode merge(ListNode left, ListNode mid) &#123; ListNode dummy = new ListNode(0); ListNode cur = dummy; while (left != null &amp;&amp; mid != null) &#123; if (left.value &lt; mid.value) &#123; cur.next = left; left = left.next; &#125; else &#123; cur.next = right; right = right.next; &#125; cur = cur.next; &#125; cur.next = (left == null) ? right : left; return dummy.next; &#125;&#125; 10. Quick Sort 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 10. Quick Sortpublic class Solution &#123; public int[] quickSort(int[] array) &#123; if (array == null) &#123; // 1 return array; &#125; quickSort(array, 0, array.length - 1); return array; &#125; private void quickSort(int[] array, int left, int right) &#123; if (left &gt;= right) &#123; // 1 return; &#125; int pivotPos = partition(array, left, right); quickSort(array, left, pivotPos - 1); quickSort(array, pivotPos + 1, right); &#125; private int partition(int[] array, int left, int right) &#123; int pivotIndex = pivotIndex(left, right); int pivot = array[pivotIndex]; swap(array, pivotIndex, right); int leftBound = left; int rightBound = right - 1; while (leftBound &lt;= rightBound) &#123; if (array[leftBound] &lt; pivot) &#123; leftBound++; &#125; else if (array[rightBound] &gt;= pivot) &#123; rightBound--; &#125; else &#123; swap(array, leftBound++, rightBound--); // 2 &#125; &#125; swap(array, leftBound, right); // 3 return leftBound; &#125; private int pivotIndex(int left, int right) &#123; return left + (int) (Math.random() * (right - left + 1)); &#125; private void swap(int[] array, int left, int right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; &#125;&#125; 10. Quick Sort (jiuzhang solution) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 10. Quick Sort// jiuzhang solutionpublic class Solution &#123; public Random rand; public int[] quickSort(int[] array) &#123; // Write your solution here rand = new Random(); helper(array, 0, array.length - 1); return array; &#125; private void helper(int[] array, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; // rand.nextInt(end - start + 1) // generate a random number in range [0,end - start + 1) // index in range [start, end] int index = rand.nextInt(end - start + 1) + start; // 1. pivot不选择array[start]或array[end]，选择中点也可，避免升序降序最坏情况 // get value not index int pivot = array[index]; int left = start; int right = end; // 2. left &lt;= right not left &lt; right // array = &#123;1, 2&#125; pivot = 1 会死循环，解决办法是在left == right时仍进入操作，排除掉一个元素 while (left &lt;= right) &#123; // 3. array[left] &lt; pivot not &lt;= 避免数组中大部分重复元素导致的效率下降 // array = &#123;1, 1, 1, 1, 1, 1&#125; while (left &lt;= right &amp;&amp; array[left] &lt; pivot) &#123; left++; &#125; while (left &lt;= right &amp;&amp; array[right] &gt; pivot) &#123; right--; &#125; if (left &lt;= right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; left++; right--; &#125; &#125; helper(array, start, right); helper(array, left, end); &#125;&#125; 258. Move 0s To The End I 12345678910111213141516171819202122232425262728293031// 258. Move 0s To The End I// The relative order of the elements in the original array does not need to be maintained.// 两根指针，相向而行public class Solution &#123; public int[] moveZero(int[] array) &#123; // Write your solution here if (array == null || array.length &lt;= 1) &#123; return array; &#125; int left = 0, right = array.length - 1; while (left &lt;= right) &#123; if (array[left] != 0) &#123; left++; &#125; else if (array[right] == 0) &#123; right--; &#125; else &#123; swap(array, left, right); &#125; &#125; return array; &#125; private void swap(int[] array, int left, int right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; &#125;&#125;// Time complexity is O(n).// Space complexity is O(1). 259. Move 0s To The End II 1234567891011121314151617181920212223242526// 259. Move 0s To The End II// The relative order of the elements in the original array need to be maintained.// 两根指针，同向而行public class Solution &#123; public int[] moveZero(int[] array) &#123; // left指针左侧是非零元素 // right指针遍历整个数组 int left = 0, right = 0; while (right &lt; array.length) &#123; if (array[right] != 0) &#123; swap(array, left, right); left++; &#125; right++; &#125; return array; &#125; private void swap(int[] array, int left, int right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; &#125;&#125;// Time complexity is O(n).// Space complexity is O(1). 519. Move zeros 1234567891011121314151617181920212223242526272829// 519. Move zeros// 1. maintain order.// 2. Minimize the total number of operations.public class Solution &#123; public int[] moveZeroes(int[] nums) &#123; // Write your solution here if (nums == null || nums.length &lt;= 1) &#123; return nums; &#125; int left = 0, right = 0; while (right &lt; nums.length) &#123; if (nums[right] != 0) &#123; if (left != right) &#123; nums[left] = nums[right]; &#125; left++; &#125; right++; &#125; for (int i = left; i &lt; nums.length; i++) &#123; if (nums[i] != 0) &#123; nums[i] = 0; &#125; &#125; return nums; &#125;&#125; 395. Remove Certain Characters 1234567891011121314151617181920212223// 395. Remove Certain Characters// Remove given characters in input string, the relative order of other characters should be remained. // Return the new string after deletion.public class Solution &#123; public String remove(String input, String t) &#123; // Write your solution here Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) &#123; set.add(t.charAt(i)); &#125; char[] array = input.toCharArray(); int slow = 0; for (int fast = 0; fast &lt; array.length; fast++) &#123; if (!set.contains(array[fast])) &#123; array[slow++] = array[fast]; &#125; &#125; return new String(Arrays.copyOf(array, slow)); &#125;&#125;// Time complexity is O(m + n).// Space complexitty is O(m + n). 281. Remove Spaces 123456789101112131415161718192021// 281. Remove Spaces// Given a string, remove all leading/trailing/duplicated empty spaces.public class Solution &#123; public String removeSpaces(String input) &#123; // Write your solution here char[] array = input.toCharArray(); int slow = 0; for (int fast = 0; fast &lt; array.length; fast++) &#123; if (array[fast] != ' ' || fast &gt; 0 &amp;&amp; array[fast - 1] != ' ') &#123; array[slow++] = array[fast]; &#125; &#125; if (slow - 1 &gt;= 0 &amp;&amp; array[slow - 1] == ' ') &#123; slow--; &#125; return new String(Arrays.copyOf(array, slow)); &#125;&#125;// Time complexity is O(n).// Space complexity is O(n). 549. Partition 12345678910111213141516171819202122232425// 549. Partitionclass Solution &#123; public void partition(int[] array, int pivotIndex) &#123; int pivot = array[pivotIndex]; int left = 0; int right = array.length - 1; swap(array, pivotIndex, right); while (left &lt;= right) &#123; if (array[left] &lt; pivot) &#123; left++; &#125; else if (array[right] &gt;= pivot) &#123; right--; &#125; else &#123; swap(array, left++, right--); &#125; &#125; swap(array, left, array.length - 1); &#125; private void swap(int[] array, int left, int right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; &#125;&#125; Recursion I 12. Fibonacci Number 12345678910111213141516171819202122232425262728293031323334353637383940// 12. Fibonacci Number// Calculating Fibonacci value// Recursion solutionpublic class Solution &#123; public long fibonacci(int K) &#123; // Base case. (进入function之后首先check是否要停下来) if (K &lt;= 0) &#123; return 0; &#125; if (K == 1) &#123; return 1; &#125; // Recursive rule return fibonacci(K-1) + fibonacci(K-2); &#125;&#125;// Time complexity is O(2^k).// Space complexity is O(k).// DP solutionpublic class Solution &#123; public long fibonacci(int K) &#123; // Write your solution here if (K &lt;= 0) &#123; return 0; &#125; if (K == 1) &#123; return 1; &#125; long prev = 0, cur = 1, next = 1; for (int i = 2; i &lt;= K; i++) &#123; next = prev + cur; prev = cur; cur = next; &#125; return next; &#125;&#125;// Time complexity is O(k).// Space complexity is O(1). 538. Calculate a to the power of b (naive) 123456789101112131415// 538. Calculate a to the power of b (naive)public class Solution &#123; public int power(int a, int b) &#123; if (b == 0) &#123; return 1; &#125; int half_result = power(a, b/2); if (b % 2 == 0) &#123; return half_result * half_result; &#125; else &#123; return half_result * half_result * a; &#125; &#125;&#125; Binary Search 267. Search In Sorted Matrix I 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 267. Search In Sorted Matrix Ipublic class Solution &#123; public int[] search(int[][] matrix, int target) &#123; // Write your solution here int[] result = new int[]&#123;-1, -1&#125;; if (matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] &gt; target) &#123; return result; &#125; int row = findRow(matrix, target); int col = findCol(matrix[row], target); if (col == -1) &#123; return result; &#125; else &#123; result[0] = row; result[1] = col; return result; &#125; &#125; // up = down + 1 // make sure matrix[down][0] &lt;= target private int findRow(int[][] matrix, int target) &#123; int up = 0, down = matrix.length - 1; while (up &lt;= down) &#123; int mid = up + (down - up) / 2; if (matrix[mid][0] &gt; target) &#123; down = mid - 1; &#125; else &#123; up = mid + 1; &#125; &#125; return down; &#125; private int findCol(int[] array, int target) &#123; int left = 0, right = array.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (array[mid] == target) &#123; return mid; &#125; else if (array[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 267. Search In Sorted Matrix I (M2) 1234567891011121314151617181920212223242526// 267. Search In Sorted Matrix Ipublic class Solution &#123; public int[] search(int[][] matrix, int target) &#123; // &#123;&#125;, &#123;&#123;&#125;&#125; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return new int[] &#123; -1, -1 &#125;; &#125; int rows = matrix.length, cols = matrix[0].length; int left = 0, right = rows * cols - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; int row = mid / cols, col = mid % cols; if (matrix[row][col] == target) &#123; return new int[] &#123; row, col &#125;; &#125; else if (matrix[row][col] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return new int[] &#123; -1, -1 &#125;; &#125;&#125;// Time complexity is O(log(n*m)).// Space complexity is O(1). Queue &amp; Stack 31. Queue By Two Stacks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 31. Queue By Two Stackspublic class Solution &#123; private LinkedList&lt;Integer&gt; input; private LinkedList&lt;Integer&gt; output; public Solution() &#123; // Write your solution here. input = new LinkedList&lt;&gt;(); output = new LinkedList&lt;&gt;(); &#125; public Integer poll() &#123; if (isEmpty()) &#123; return null; &#125; if (output.isEmpty()) &#123; while (!input.isEmpty()) &#123; output.offerFirst(input.pollFirst()); &#125; &#125; return output.pollFirst(); &#125; public void offer(int element) &#123; input.offerFirst(element); &#125; public Integer peek() &#123; if (isEmpty()) &#123; return null; &#125; if (output.isEmpty()) &#123; while (!input.isEmpty()) &#123; output.offerFirst(input.pollFirst()); &#125; &#125; return output.peekFirst(); &#125; public int size() &#123; return input.size() + output.size(); &#125; public boolean isEmpty() &#123; return input.size() == 0 &amp;&amp; output.size() == 0; &#125;&#125; 32. Stack With min() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 32. Stack With min()public class Solution &#123; private Deque&lt;Integer&gt; stack; private Deque&lt;Integer&gt; minStack; public Solution() &#123; stack = new LinkedList&lt;Integer&gt;(); minStack = new LinkedList&lt;Integer&gt;(); &#125; public int min() &#123; if(minStack.isEmpty()) &#123; return -1; &#125; return minStack.peekFirst(); &#125; public void push(int value) &#123; stack.offerFirst(value); // when value &lt;= current min value in stack, // need to push the value to minStack. if (minStack.isEmpty() || value &lt;= minStack.peekFirst()) &#123; minStack.offerFirst(value); &#125; &#125; public int pop() &#123; if(stack.isEmpty()) &#123; return -1; &#125; Integer result = stack.pollFirst(); // when the popped value is the same as top value of minStack, the value // need to be popped from minStack as well. if (minStack.peekFirst().equals(result)) &#123; minStack.pollFirst(); &#125; return result; &#125; public int top() &#123; if (stack.isEmpty()) &#123; return -1; &#125; return stack.peekFirst(); &#125;&#125; 32. Stack With min() (M2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 32. Stack With min()class Wrapper &#123; int min; int pos; public Wrapper(int min, int pos) &#123; this.min = min; this.pos = pos; &#125;&#125;public class Solution &#123; private Deque&lt;Integer&gt; stack; private Deque&lt;Wrapper&gt; minStack; public Solution() &#123; stack = new LinkedList&lt;Integer&gt;(); minStack = new LinkedList&lt;Wrapper&gt;(); &#125; public int min() &#123; if(minStack.isEmpty()) &#123; return -1; &#125; return minStack.peekFirst().min; &#125; public void push(int value) &#123; stack.offerFirst(value); // when value &lt;= current min value in stack, // need to push the value to minStack. if (minStack.isEmpty() || value &lt; minStack.peekFirst().min)&#123; minStack.offerFirst(new Wrapper(value, stack.size() - 1)); &#125; &#125; public int pop() &#123; if(stack.isEmpty()) &#123; return -1; &#125; Integer result = stack.pollFirst(); // when the popped value is the same as top value of minStack and the popped value's index is the same as top position of minStack, the wrapper object need to be popped from minStack as well. if (new Integer(minStack.peekFirst().min).equals(result) &amp;&amp; stack.size() == minStack.peekFirst().pos) &#123; minStack.pollFirst(); &#125; return result; &#125; public int top() &#123; if (stack.isEmpty()) &#123; return -1; &#125; return stack.peekFirst(); &#125;&#125; LinkedList Binary Tree &amp; Binary Search Tree Heap Breadth-First Search (BFS-1): Best First Search (BFS-2) Depth First Search 62. All Subsets I 12345678910111213141516171819202122232425262728// 62. All Subsets I// Given a set of characters represented by a String, return a list containing all subsets of the characters.public class Solution &#123; public List&lt;String&gt; subSets(String set) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (set == null) &#123; return result; &#125; if (set.length() == 0) &#123; result.add(""); return result; &#125; StringBuilder sb = new StringBuilder(); DFS(set, sb, result, 0); return result; &#125; private void DFS(String set, StringBuilder sb, List&lt;String&gt; result, int level) &#123; if (level == set.length()) &#123; result.add(sb.toString()); return; &#125; sb.append(set.charAt(level)); DFS(set, sb, result, level + 1); sb.deleteCharAt(sb.length() - 1); DFS(set, sb, result, level + 1); &#125;&#125; 63. All Subsets II 12345678910111213141516171819202122232425262728293031323334// 63. All Subsets II// String with duplicate characterpublic class Solution &#123; public List&lt;String&gt; subSets(String set) &#123; // Write your solution here. List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (set == null) &#123; return result; &#125; if (set.length() == 0) &#123; result.add(""); return result; &#125; char[] array = set.toCharArray(); Arrays.sort(array); StringBuilder sb = new StringBuilder(); dfs(array, sb, result, 0); return result; &#125; private void dfs(char[] array, StringBuilder sb, List&lt;String&gt; result, int level) &#123; if (level == array.length) &#123; result.add(sb.toString()); return; &#125; sb.append(array[level]); dfs(array, sb, result, level + 1); sb.deleteCharAt(sb.length() - 1); while (level &lt; array.length - 1 &amp;&amp; array[level] == array[level + 1]) &#123; level++; &#125; dfs(array, sb, result, level + 1); &#125;&#125; nowcoder subsets 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// input: [1, 2, 3]// output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]import java.util.Arrays;import java.util.List;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] S) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; subset = new ArrayList&lt;&gt;(); Arrays.sort(S); if (S == null || S.length == 0) &#123; return result; &#125; dfs(S, subset, result, 0); Collections.sort(result, new Comparator&lt;ArrayList&lt;Integer&gt;&gt;() &#123; @Override public int compare(ArrayList&lt;Integer&gt; o1, ArrayList&lt;Integer&gt; o2) &#123; int size1 = o1.size(), size2 = o2.size(); if (size1 != size2) return size1 &lt; size2 ? -1 : 1; else &#123; for (int i = 0; i &lt; o1.size(); i++) &#123; if (o1.get(i) == o2.get(i)) continue; else return o1.get(i) &lt; o2.get(i) ? -1 : 1; &#125; &#125; return 0; &#125; &#125;); return result; &#125; private void dfs(int[] S, ArrayList&lt;Integer&gt; subset, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result, int level) &#123; if (level == S.length) &#123; result.add(new ArrayList(subset)); return; &#125; subset.add(S[level]); dfs(S, subset, result, level + 1); subset.remove(subset.size() - 1); dfs(S, subset, result, level + 1); &#125;&#125; 64. All Permutations I 1234567891011121314151617181920212223242526272829303132333435// 64. All Permutations Ipublic class Solution &#123; public List&lt;String&gt; permutations(String input) &#123; // Write your solution here List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (input == null) &#123; return result; &#125; if (input.length() == 0) &#123; result.add(""); return result; &#125; char[] array = input.toCharArray(); dfs(array, result, 0); return result; &#125; private void dfs(char[] array, List&lt;String&gt; result, int level) &#123; if (level == array.length) &#123; result.add(new String(array)); return; &#125; for (int i = level; i &lt; array.length; i++) &#123; swap(array, i, level); dfs(array, result, level + 1); swap(array, i, level); &#125; &#125; private void swap(char[] array, int i, int j) &#123; char temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 65. All Permutations II 1234567891011121314151617181920212223242526272829303132333435363738// 65. All Permutations IIpublic class Solution &#123; public List&lt;String&gt; permutations(String input) &#123; // Write your solution here List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (input == null) &#123; return result; &#125; if (input.length() == 0) &#123; result.add(""); return result; &#125; char[] array = input.toCharArray(); dfs(array, result, 0); return result; &#125; private void dfs(char[] array, List&lt;String&gt; result, int level) &#123; if (level == array.length) &#123; result.add(new String(array)); return; &#125; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = level; i &lt; array.length; i++) &#123; if (set.add(array[i])) &#123; swap(array, i, level); dfs(array, result, level + 1); swap(array, i, level); &#125; &#125; &#125; private void swap(char[] array, int i, int j) &#123; char temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; String I String II Recursion II Dynamic Programming I Dynamic Programming II Probability, Sampling, Randomization, etc. Recursion III]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDE理论]]></title>
    <url>%2F2020%2F02%2F28%2FSDE%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[credit: rick sun Overview Data structure is a particular way of organizing data in a computer so that it can be used efficiently. Common data structure Array Stack Queue Linked List Tree Heap Graph Hash table Platform https://www.laioffer.com/ https://www.laicode.io/ Array and Sorting Algorithms E.g. int a[10]; Assume a problem's size is n (n elements). For example: print all the elements of this array. Big O notation: algorithm complexity (time complexity, space complexity) e.g., time complexity O(n). e.g., space complexity: how much memory does it need to run this algorithm. O(n) e.g., auxiliary space complexity: is the extra space or temporary space used by an algorithm. Selection Sort Example: int[i]=(-1, -3, 4, 7) =&gt; (-3, -1, 4, 7) ascending order iteration 1: find global min -3 (-3, -1, 4, 7) insert 3 to the right place iteration 2; find global min in the rest -3 (-1, 4, 7) =&gt; -3 -1 (4, 7) iteration 3; find global min in the rest -3 -1 (4, 7) =&gt; -3 -1 4 (7) iteration 4; find global min and done . 讲解code要点: 做题要求: A complete answer will include the following: Document your assumptions Explain your approach and how you intend to solve the problem Provide code comments where applicable Explain the big-O run time complexity of your solution. Justify your answer. Identify any additional data structures you used and justify why you used them. Only provide your best answer to each part of the question. 时间复杂度分析: O(n^2) Discussion: 1) 什么是面试中一个类型的题? (1.1) Given an array in Stack1, how to sort the numbers by using additional two stacks? Stack1 || 1 3 2 4 . global_ min = Stack2 || Stack3 || 通过Stack1和2选择出最小值放在Stack3中，再将Stack1恢复，循环。 M1: 普通作法，来回倒，s2作为buffer，s3作为output，最后再把s3中排完序的数字倒入s1 (1.2) Follow up, what if only 1 additional stack can be used? solution: 基于selection sort，一个stack即当buffer又当output，每次倒的时候记录global min及出现次数（以防重复元素） Merge sort a[n] = 1,3,5,7,9,8,6,4,2,0 Space = O(n) // look at the pink path Time = O(nlogn) Discussion: 1) Could we use Merge Sort to sort a linked list?What is the time complexity if so? 可以，在使用快慢指针找到linked list的中点的时间复杂度为O(N)，所以在横线上的每一层都是O(N)的复杂度，但还是logn层，所以总的复杂度不变，仍为O(n logn)。 什么是面试中一个类型的题? (2.1) e.g A1B2C3D4 -&gt; ABCD1234 性质:只是combine function的实现稍微不一样而已。 设置成字母比数字小 (2.2) (Advanced topic 1) ABCD1234 -&gt; A1B2C3D4 Way of thinking? How to relate 2.1 and 2.2? Do not only focus on solving 1 problem and 1 problem only. (2.3) (Advanced topic 2) K-way merge and its application in Mapreduce e.g. how to merge TB/PB level data? Algorithm + System Design (2.4) (Advanced topic 3) count- array problem Given an array A[N] with all positive integers from [1...N]. How to get an array B[N] such that B[i] represents how many elements A[j] (j &gt; i) in array A[] that are smaller than A[i]. For example, given A[N]={4, 1, 3, 2}, we should get B[N]={3, 0, 1, 0}. Requirement: Time = O(nlogn). 性质: 在log(n)层中，combine function能够让每个element都会和其他所有的元素compare至少一次。总的时间复杂度依然是O(nlogn) Quick sort 两个挡板 i j, 三个区域 a) b) c) 的思想: [o...i) : i 的左侧(不包含i) 全部为比pivot小的数 [i...j] : i 和 j 之间为未知探索区域 (j...n-1] : j 的右侧(不包含j)全部为比pivot大或等于的数字 Recursive rule: Quicksort all numbers to the left of 5, Quicksort all numbers to the right of 5, Discussion: 1) What is the worst case scenario for quicksort? Can you provide an example? O(n^2) 每次的规模减小1个，即每次的pivot选择的都是最小或最大值。所以若对time complexity的bound比 较严格的话选择merge sort会好一些。 什么是面试中一个类型的题? (2.1) Array Shuffling 1: Given an array with integers, move all &quot;0s&quot; to the right-end of the array. (2个挡板，3个区域，相向而行) (2.2) Character removal from a string: (Will be discussed later in String) (2个挡板，3个区域，同向而行) Remove one or more types of characters from a string. (2.3) Quick Partition Problems (2个挡板，3个区域，相向而行) (2.4) Rainbow sort (abcccabbcbbacaa -&gt; aaaaa bbbbb ccccc) (3个挡板，4个区域，同向 + 相向而行) Answer: initialization: ¡= 0; all letters to the left-hand side of are all &quot;a&quot;s j= 0; (j is actually the current index) all letters in [i, j) are all &quot;b&quot;s , k= n-1 (all letters to the right-hand side of k are all &quot;c&quot;s). unknown area is [j...k] 若j位置是a，则 i, j互换 i++, j++ 若j位置是b，则 j++ 若j位置是c，则 j, k互换 k-- Discussion: What did we learn today? Time/Space complexity Sorting Algorithms Time/Space, and why? When to prefer to use one to another? Understand sorting algorithms with design problems? More to do :-) Recursion I Recursion 需要掌握的知识点: 1) 表象上: function calls itself 2) 实质上: Boil down a big problem to smaller ones (size n depends on size n-1, or n-2 or...n/2) 3) Implementation上: a) 1. Base case: smallest problem to solve b) 2. Recursive rule. how to make the problem smaller (if we can resolve the same problem but with a smaller size, then what is left to do for the current problem size n) 4) to be continued ... Recursion Question 1: Fibonacci sequence Base case: F(0)= 0; F(1)= 1; Recursive rule: F(n) = F(n-1) + F(n-2); Call Stack (Term): was designed to record all local variables that are allocated in the stack. content: Level1: n = 4 Level2: n = 3 Level3: n = 2 Level4: n = 1 There are n levels in the recursion tree, and this recursion tree is a binary tree. Thus, there are totally at most O(2^n) nodes in the tree. Time = O(2^n) Trick: 所有前面的node的个数的总和，都没有最后一层node的个数多，因此我们分析tree的time complexity,往往只看最后一层node的个数。 Space = O(n) because there are n levels of recursion function call, and thus there are n levels of call_ stack. In call_ stack, each level only stores 1 local variable, that is, int n. Recursion Question 2: How to calculate a^b (where a is an integer and b is also an integer, we do not care about the corner case where a = 0 or b &lt; 0 for now) 求 2^1000 a=2 b=1000 Binary Search what is binary search in the context of an array? 1) Array has to be sorted. ascending or descending 1 2 3 5 7 9 ... ?????? Not necessarily the case. 2) Problem to solve? Array 1 3 7 23 57 ... 100 99 86 44 32 21 find the maximum Essentially, the principle of binary search is to reduce the search space by 1/2 of its original size. In the meantime, you must guarantee that the target must not be ruled out. --- to find an element/number in an array, -&gt; sorted array. Example: a[7] = 1 2 4 5 7 8 9 whether 4 is in this array or not. index 0 1 2 3 4 5 6 A[7] 1 2 4 5 7 8 9 Iteration 1: L = 0, R = 6, M = 3 A[M] == A[3] == 5 &gt; target == 4, so R = M-1 = 2; Iteration 2: L = 0, R = 2, M = 1 A[M] == A[1] == 2 &lt; target == 4, so L = M+1=2; Iteration 3: L = 2, R = 2, M = 2 A[M] == A[2] == 4 == target , so Done!!! n element -&gt; time complexity O(log(n)); 1234567891011121314151617// Classical Version 1.0// return any target element's indexint binary_search(int a[], int size, int target) &#123; int left = 0; int right = size - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (a[mid] == target) &#123; return mid; &#125; else if (a[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1;&#125; 12345678910111213141516171819202122232425262728// 14. Classical Binary Search// jiuzhang versionpublic class Solution &#123; public int binarySearch(int[] array, int target) &#123; // Write your solution here if (array == null || array.length == 0) &#123; return -1; &#125; int left = 0, right = array.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (array[mid] == target) &#123; return mid; &#125; else if (array[mid] &lt; target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; if (array[left] == target) &#123; return left; &#125; if (array[right] == target) &#123; return right; &#125; return -1; &#125;&#125; Apply binary search in 2D space Variant 1.0 application: 2D matrix, sorted on each row, first element of next row is larger (or equal) to the last element of previous row, now giving a target number, returning the position that the target locates within the matrix 1 2 3 4 5 6 7 8 target == 7 9 10 11 12 Solution1: Step1: Run binary search in the 0-th column to find the possible row that contains target Step2: Run 2nd binary search, in the particular row to find target (if any) Time = O(logm + logn) = O(log(m*n)) Solution2: Run only 1 time of binary search Left= [0] [0], Right =[m-1]x[n-1], 1D =mxn-1 Mid[row] [col]= (left + right) / 2 = mid_size row= mid_ size / col; col = mid_ size % col; Time = O(log (m*n) ) Variant 1.1 how to find an element in the array that is closest to the target number? // e.g int a[5] = {1, 2, 3, 8, 9}; target = 4 should return 3 only need to contain the wanted target in the range, not rule out the target number. 123456789101112131415161718192021int binary_search(int a[], int size, int target) &#123; int left = 0; int right = size - 1; while (left + 1 &lt; right) &#123; // avoid infinite loop int mid = left + (right - left) / 2; if (a[mid] == target) &#123; return mid; &#125; else if (a[mid] &gt; target) &#123; right = mid; &#125; else &#123; left = mid; &#125; &#125; // post-processing if (Math.abs(a[left] - target) &lt; Math.abs(a[right] - target)) &#123; return left; &#125; else &#123; return right; &#125;&#125; 其中 line10 right = mid 不能改为 right = mid - 1 其中 line11 left = mid 不能改为 left = mid + 1 反例 [1, 2, 8, 10] target = 3 如果更改了right或left 有可能删掉了想要的index 其中 line5 while 循环条件 start + 1 &lt; end 可以保证循环内 start 和 end 不相邻，从而避免死循环 Variant 1.2 return the index of the first occurrence of an element, say 5 index 0 1 2 3 4 5 6 A[7] 4 5 5 5 5 5 5 Iteration 1: L = 0, R = 6, M = 3 A[M] == A[3] == 5 == target, so R = M = 3; Iteration 2: L = 0, R = 3, M = 1 A[M] == A[1] == 5 == target, so R = M = 1; 因为左右边界相邻，我们 terminate binary search，再做 post processing. Variant 1.3 return the index of the last occurrence of an element e.g. inta[6] = [4, 5, 5, 5, 5, 5]; if target == 5; then index 5 is returned; if target == 10; then -1 is returned; Variant 1.4 how to find closest k elements in the array that is closest to the target number? e.g int a[5] = {1, 2, 3, 8, 9}; Target == 4; k = 3, solu = {3, 2, 1} Solution: Step1: we first move L and R by using binary search to make it close to the target number, until there are two or less elements in between L and R. Step2: 谁小移谁 Time = O(logn+ k) Variant 1.5 how to find the smallest element that is larger than a target number? Binary Search Variant 2.0: Important Question: Given a sorted dictionary with unknown size, how to determine whether a word is in this dictionary or not. Example: dictionary[x] = { 1 3 5 7 9 ..... 100 .... 1000000000 ..... } Target == 9999 assumption if dictionary[index] == NULL then we know the size of dictionary is &lt; index; Step1 jump out step = 2 Step2 jump out step = 2^2 = 4 Step3 jump out step = 2^3 = 8 Step4 jump out step = 2^4 = 16 Stepk until dictionary[2^k] &gt;= target OR dictionary[2^k] == null // target can exist and its 2^(k-1) &lt; index &lt; 2^k Further discussion about binary search: Why not jump_ step = jump_ step * 10, instead of jump_ step = jump_ step * 2 10Times: log_10 (n) + log_2 (10n) 2 Times: log_2 (n) + log_2 (2n) 比较10 times - 2 times即可 Discussion When to use binary search 1) very very classical problem: when the input is completely/partially sorted a. sorted array b. sorted array but shifted C. two sorted order array but Array 1 3 7 23 57 .... 100 99 86 44 32 21 2) has some logic rule under the hood. but you can figure out proof that you can disregard 1/2 searching range each time ARRAY 1 XXXXXXXXXXXXXXXXXXX m ARRAY 2 YYYYYYYYYYYYYYYY n (m+n)/2 no no no!!!! FIND THE K-th smallest element in the array Yes: reduce the search range from k to k/2 Queue &amp; Stack Queue 1.1. Example: wait in a line, FIFO == First in first out 1.2. Usages: Breadth-First Search related problems 1.3. C++ reference http://www.cplusplus.com/reference/queue/queue/ 1.4. 典型问题 1.4.1. Tree print out by level 1.4.2. Sliding window problems (Deque: double ends manipulation) poll() -- take the element from head peek() -- look at the element at the head offer() -- insert the element at the tail Stack LIFO Last in first out: like a box e.g. insertion order 1.2.3.4, then in the stack, it looks like 5 &lt;- top of the stack. All operations can only be done to this element 4 3 2 1 &lt;- bottom of the stack All operations available: push(), pop(), top() Implementation: popular data structure: array or vector Four popular interview questions: Question 1: How could we implement a queue by using two stacks? head tail 1 2 3 4 lI II 5 6 7 8 9 stack1 stack2 stack 1 -&gt; responsible for poll() -&gt; stack1.pop() stack 2 -&gt; responsible for offer() -&gt; stack2.push() case1. if stack1 is not empty, stack1.pop() case2. if stack2 is empty -&gt; pop elements from stack2 and push them into stack1 Time Complexity: offer() - O(1) poll() - worst case - case2 O(n) Amortized Analysis: for the n elements: for the first element - worst case (2n + 1) pop all from stack2 and push all into the stack 1 and pop 1 element from stack1 for the following n-1 elements - 1 * (n-1) total 2n + 1 + n - 1 = 3n O(3n)/n = O(3) = O(1) -- Amortized Time Complexity. Question 2: How to implement the min() function when using stack with time complexity O(1); stack1 II 5 4 3 4 5 stack2 II 5 4 3 3 3 stack2: maintain the corresponding min value according to stack1. Follow up Question: how to optimize the space when there are a lot of duplicate elements in stack1?stack1 II 5 4 3 3 3 3 3 3 3 3 3 stack2 II 5 4 3 3 3 3 3 3 3 3 3 stack1 II 5 4 3 3 3 3 3 3 3 3 3 stack2 II &lt;5, 0&gt; &lt;4, 1&gt; &lt;3, 2&gt; 1234class Wrapper &#123; int min; int pos;&#125; pop only when -&gt; stack1.size() == stack2.peek().pos + 1 Question 3: How to sort numbers with two stacks stack1 II 1 2 2 2 4 3 stack2 II 1 stack2 to maintain the numbers in sorted order. two variable: globalMin and counter while (stack2.top() &gt;= globalMin) { } laicode 280. Question 4: How to use multiple stacks to implement a de-queue(double ended queue) head tail 1 2 3 4 lI II 5 6 7 8 9 stack1 stack2 pushL stack1.push() pushR stack2.push() popL case1: stack1 is not empty, O(1) case2: if stack1 is empty, we need to pop all the elements from stack2 and push them to stack1 popR case1: stack2 is not empty, O(1) case2: if stack2 is empty, we need to pop all the elements from stack1 and push them to stack2 Worst case: amortized Time Complexity O(n) e.g. stack1: empty stack2: empty pushR(5, 6, 7, 8, 9) - n elements popL - n popR - n-1 popL - n-2 popR - n-3 ...... Total: O(n + n-1 + n-2 + ... + 1) = O(n^2), O(n^2) / n = O(n) How to optimize to O(1)? 分析复杂度高的原因是每次都将所有元素移动，如果借助一个辅助栈只移动一半元素，时间平摊到其他操作则会大幅度降低复杂度。 intuition: move half of the elements in stack2 to stack1. 第一次操作： stack2移动一半元素到stack3 O(n) stack2移动剩余一半元素到stack1 O(n) stack3移动回元素到stack2 O(n) 0.5n个元素其余次操作: O(1) amortized Time Complexity: ( O(n) + O(n) + O(n) + O(0.5n) ) / 0.5n = O(7) = O(1) Discussion: 什么问题要往Stack上考虑? 从左到右linear scan一个array/string时, 如果要不断回头看左边最新的元素时往往要用到stack 1) Histogram中找最大的长方形 2) reverse polish notation逆波兰表达式的计算a* (b+c) → abc+* 3) String的repeatedly deduplication. cabba → caa → c LinkedList Key points: 1) When you want to de-reference a ListNode, make sure it is not a NULL pointer 2) Never ever lost the control of the head pointer of the LinkedList Question: How to reverse a linked list? Node1(head) --&gt; Node2 --&gt; Node3 --&gt; Node4 .... --&gt; NodeN --&gt; NULL reversed: NULL &lt;-- Node1&lt;-- Node2 &lt;-- Node3 &lt;-- .... &lt;-- NodeN( head) Iterative Solution: 123456789101112// Solution1: create a new linked listpublic ListNode reverse(ListNode head) &#123; ListNode newHead = null; ListNode cur = head; while (cur != null) &#123; ListNode next = cur.next; cur.next = newHead; newHead = cur; cur = next; &#125; return newHead;&#125; 123456789101112131415// Solution2: 原地反转指针指向public ListNode reverse(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode next = head.next; head.next = null; while (next != null) &#123; ListNode cur = next; next = next.next; cur.next = head; head = cur; &#125; return head;&#125; Recursive Solution: 123456789// Recursive way:public ListNode reverseLinkedList(ListNode head) &#123; if (head == NULL || head.next == NULL) return head; // base case ListNode newHead = reverseList(head.next); // breaking point.. head.next.next = head; head.next = null; return newHead;&#125; 常见考题: Q1. How to find the middle node of a linked list? 快慢指针 偶数个节点选左边的那个，因为左边的next node就是右边的。 Q2. 用快慢指针判定一个linkedlist是否有环。 Q3. Insert a node in a sorted linked list (simple) N1 &lt; node &lt; N2 找到N1和N2 Q4. How to merge two sorted linked list into one long sorted linked list 有可能插头或插尾，处理corner case使用dummy node step 1: find mid node step 2: reverse the second half list step 3: merge two sub lists. Q6. Partition List: Given a linked list and a value x, partition it such that all nodes less than x come first, then all nodes with value equal to x or greater than or equal to x. The original relative order of the nodes in each of the two partitions should be preserved. For example, Input: 1 -&gt; 6 -&gt; 3 -&gt; 2a -&gt; 5 -&gt; 2b and target x = 4, result: 1 -&gt; 3 -&gt; 2a -&gt; 2b -&gt; 6 -&gt; 5. Solution: Step1: allocate two new linked list heads; Step2: Iterate over every single element in the list, and compare with the current node's value with the target's value. Case1 if current.value &lt; target.value: Add the current node to the tail of the first linked list . Case2: otherwise, add the current node to the tail of the second linked list. 1st half (small values ) 2nd half (large values ) Step3: Concatenate the tail of the first half to the head of the 2nd linked list. Step4: The tail of the large list.next == NULL 1234567891011121314151617181920212223public class PartitionLinkedList &#123; public ListNode partition (ListNode head, int x) &#123; if (head == null) return null; ListNode fakeHeadSmall = new ListNode(0); ListNode fakeHeadLarge = new ListNode(0); ListNode smallTail = fakeHeadSmall; ListNode largeTail = fakeHeadLarge; ListNode current = head; while (current != null) &#123; if (current.val &lt; x) &#123; smallTail.next = current; smallTail = current; &#125; else &#123; largeTail.next = current; largeTail = current; &#125; current = current.next; &#125; largeTail.next = null; // terminate the list with null smallTail.next = fakeHeadLarge.next; return fakeHeadSmall.next; &#125;&#125; Binary Tree &amp; Binary Search Tree Definition: at most two children node. Example: Trick: base case usually refers to the null ChildNode below the leaf node. 基本概念 Balanced binary tree: is commonly defined as a binary tree in which the depth of the left and right subtrees of every node differ by 1 or less. Complete binary tree: is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Binary Search tree: for every node in the tree, the values in its left subtree are all smaller than its value, and the values in its right subtree are all larger than its value. Discussion (High Level) Binary tree往往是最常见的，和recursion 结合最紧密的面试题目类型。 Reasons: 每层的node具备的性质，传递的值和下一层的性质往往一致。比较容易定义recursive rule. Base case (generally): null pointer under the leaf node Example1: int getHeight (Node root) Example2: 统计tree里边有多少个node? Fundamental Knowledge: Traversal of a binary tree Definition Balanced binary tree Complete binary tree Binary search tree (BST) Binary Tree Q1. Get height of a binary tree 123456public int getHeight(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return 1 + Math.max(getHeight(root.left), getHeight(root.right));&#125; Time = O(n) where n is the total number of the nodes Space = O(n) == O(height) Q2. How to determine whether a binary tree is a balanced binary tree? 1234567891011public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123; return false; &#125; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125; image-20200114205944605 Q3. How to judge whether a binary tree is symmetric? 12345678910public boolean isSymmetric (TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; else if (left == null || right == null) &#123; return false; &#125; else if (left.value != right.value) &#123; return false; &#125; return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);&#125; Time = O(n) Space = O(n) Q3. Let's assume if we tweak the Ichild with rchild of an arbitrary node in a binary tree, then the &quot;structure&quot; of the tree are not changed. Then how can we determine whether two binary trees' structures are identical. 1234567891011public boolean isIdentical (TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; else if (left == null || right == null) &#123; return false; &#125; else if (left.value != right.value) &#123; return false; &#125; return isIdentical(left.left, right.left) &amp;&amp; isIdentical(left.right, right.right) || isIdentical(left.left, right.right) &amp;&amp; isIdentical(left.right, right.left);&#125; image-20200114213236663 Total number of nodes in this quad tree = 4^(log2(n)) = 2^(2log2(n)) = O(n^2) Binary Search Tree Q1. How to determine a binary tree is a BST? 12345678910public boolean isBSTHelper(TreeNode root, int min, int max) &#123; if (root == null) &#123; return true; &#125; if(root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return isBSTHelper(root.left, min, root.val) &amp;&amp; isBSTHelper(root.right, root.val, max);&#125; Time = O(n) Space = O(height) = O(n) Discussion Recursion在tree题目的基本应用大致分为2类用法（存疑） 把value从上往下传递(then从下往上)的题目 BST判定方法 把value从下往上传递(更为常见，必须熟练掌握) getHeight(TreeNode root) 是经典的把integer value从下往上传递的题 isBalanced(TreeNode root)是把boolean value从下往上传递的题目 isSymmetric(TreeNode root1, TreeNode root2)是把boolean value从下往上传递的题目 Assign the value of each node to be the total number of nodes that belong to its left subtree. (是把integer value从下往上传递的题目) Q2. Print BST keys in the given range Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree. Print all the keys of tree in range k1 to k2. i.e. print all x such that k1 &lt;= x &lt;=k2 and x is a key of given BST. Print all the keys in an increasing order. 1234567891011121314public void rangeInOrder(TreeNode root, int k1, int k2) &#123; if (root == null) &#123; return; &#125; if (root.value &gt; k1) &#123; rangeInOrder(root.left, k1, k2); &#125; if (root.value &gt;= k1 &amp;&amp; root.value &lt;= k2) &#123; System.out.println(root.value); &#125; if (root.value &lt; k2) &#123; rangeInOrder(root.right, k1, k2); &#125;&#125; Heap 堆 (英语: heap) 亦被称为: 优先队列 (英语: priority queue) Example index 0 1 2 3 4 5 value 1 3 2 5 4 7 Heap: is an unsorted array but have special rules to follow 性质: 堆的实现通过构造二叉堆(binary heap), 这种数据结构具有以下性质 1. 任意节点小于它的所有后裔，最小元素在堆的根上(堆序性)。 2. 堆总是一棵完全树。complete tree 3. 将根节点最大的堆叫做MAX HEAP，根节点最小的堆叫做最小堆MIN HEAP 4. index of lChild = index of parent X 2 + 1 5. index of rChild = index of parent X 2 + 2 6. unsorted but follow rules above 支持的基本操作 1. insert: 向堆中插入一个新元素；时间复杂度O(log(n)) 2. update: 将新元素提升使其符合堆的性质；时间复杂度O(log(n)) 3. get/top: 获取当前堆顶元素的值；时间复杂度O(1) 4. pop: 删除堆顶元素；时间复杂度O(log(n)) 5. heapify: 使得一个unsorted array变成一个堆。时间复杂度O(n) 经典考题 Q1 Find smallest k elements from an unsorted array of size n. Solution1: sort it and return the first k element! Time = O(nlogn) Solution2: e.g. k= 3, Use selection sort principle 1st iteration to find 1st smallest element to return 2nd iteration to find 2nd smallest element to return ... k-th iteration to find the k-th smallest Time = O(k * n) Solution3: MIN-HEAP of size n Step1: heapify the whole array to make it a MIN-heap. O(n) Step2: keep popping k times k*log(n) Total time = O(n) + O(klog(n)) Solution4: MAX-HEAP of size k xxxxxx Yxxxxxxxxxxxxxxxxxxxx size= k k+1 Step1: insert all first k elements into a max-heap (optimization heapify first k element) O(k) Step2: from the k+1-th element to the n-th element, if the current element Y case2.1 Y &lt; max-heap.top(), we call max-heap.pop(), and then max-heap.insert(Y) case2.2 Y &gt;= max-heap.top(), do nothing. Time = O(k) + O((n-k) * log(k) COMPARISON:3, 4 MIN-HEAP MAX-HEAP Time Complexity O(n) + O(klog(n)) O(k) + O((n-k) * log(k) Case1 k &lt;&lt;&lt; n O(n) O(n) * log(k) hard to say Case2 k~n O(nlogn) O(nlogn) hard to say Solution5: average time = O(n)on average= on average = O(n + n/2 + n/4 + n/8+ 1...) = O(n) worst case = O(n^2) Graph Search Algorithms I image-20200113190008687 Node / State Edge / action Directed vs undirected graph Representation of the graph Adjacency Matrix Pros: Representation is easy to implement. Edge removal takes O(1) time. Queries like whether there is an edge from vertex 'u' to vertex 'V' are efficient and can be done O(1). Adjacency List Vertices/nodes: IVI Edges: IEI Pros: Space complexity= O(lVI+lEl) . Adding a vertex/node to the graph is easier. Cons: Time complexity is O(V) to check whether there is an edge from a node to the other. (compared to O(1) in adjacent matrix) Use a hash_table &lt;key = node, value = set of successors&lt; Node &gt;&gt; 图里常用的search算法 Breadth-First Search (BFS-1): print/visit = 1 32 547 9 11 How to describe a relatively complex algorithm: what kind of data structure that this algorithm uses queue what are the actions of this algorithm step by step initial state: insert the start node into the queue queue = {1} process: while the queue is not empty, pop the left-most element out of the queue and expand it, generate all its successors and insert all of them into the tail of the queue termination condition: when the queue is empty 经典例题1：分层打印一个binary tree 12345678910111213141516171819202122// param: root - the root of the treepublic void BFS(Node root) &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;(); q.offer(root); while(!q.empty()) &#123; int size = q.size(); // size = # of generated nodes in the next layer. for (int i = 0; i &lt; size; i++) &#123; Node n = q.remove(); if (n.left != null) &#123; q.offer(n.left); &#125; if (n.right != null) &#123; q.offer(n.right); &#125; System.out.print(n.val + " "); &#125; System.out.println(); &#125;&#125; 经典例题2: Bipartite : whether a graph's node can be divided into two group, such that the nodes in each group do not have direct edges between the nodes that belong to the same group. 12345class GraphNode &#123; int value; char set; // u or v? ArrayList&lt;GraphNode&gt; succesors;&#125; 经典例题3: Determine whether a binary tree is a complete binary tree Solution: after detecting the first node that misses one child, then check if all following nodes expanded have any node generated (if any, then false) Discussion: When to consider to use BFS? When we want to deal with the node relationship in the same level (Common mistake): BFS1 is NOT the right algorithm to find the shortest path from point A to point B in an arbitrary graph (cost might not be the same). if the edge costs in the graph are all the same (= uniform) then BFS1 can find the shortest path. Best First Search (BFS-2) 经典算法: Dijkstra's Algorithm (runtime efficiency improvement: A * algorithm) Usages: Find the shortest path from a single node (source node) to any other nodes in that graph (点到面(==所有点)的最短距离算法)/ Example problem: 从北京到中国其他所有主要城市的最短距离是多少 Data structure: priority_queue (MIN_HEAP) 解题思路 4.1 Initial state (start node) 4.2 Node expansion/Generation rule: 4.3 Termination condition: 所有点都计算完毕才停止，也就是p_ queue变空 Example image-20200113195544938 initial state: no nodes have been expanded, p_queue = {node(4,0)} process: p_queue.pop(), pop node(4,0) out of the p_queue, expand node(4,0) generate three successors: node(5,10), node(3,1), node(6,1), p_queue = {node(5,10), node(3,1), node(6,1)} tie breaking strategy: random pop node(6,1) generate nothing, p_queue = {node(5,10), node(3,1)} pop node(3,1) generate node(2, cost == parent cost + 1) = (2,2), p_queue = {node(5,10), node(2,2)} pop node(2,2) generate node(5, 2+1) and node(1,2+1), p_queue = {node(5,3), node(1,3)} pop node(5,3), p_queue = {node(1,3)} pop node(1,3), p_queue = {} terminate properties one node can be expanded once and only once one node can be generated more than once. (cost can be reduced over time) all the cost of the nodes that are expanded are monotonically non-decreasing (所 有从priority queue里面pop出来的元素的值是单调非递减 -&gt; 单调递增) time complexity, for a graph with n node is O(nlogn) when a node is popped out for expansion, its value is fixed which is equal to the shortest distance from the start node. 经典考题: (运用Dijkstra's Algorithm的性质) Given a matrix of size NxN, and for each row the elements are sorted in an ascending order, and for each column the elements are also sorted in an ascending order. How to find the k-th smallest element in it? image-20200113211643029 Solution: Initial state: start node = [0] [0] Node expansion/ generation rule: expand [i] [j] generate [i] [j+1] and [i+1] [j] Termination condition: when the k-th element is popped out of the p-queue Analysis: there are totally k nodes to be popped out of the p-queue (= k iterations) for each iteration pop 1 element out of the p-queue (p-queue size &lt; 2k) time = log(2k) generate 2 elements and insert them into the p-queue time = 2log(2k) Total time for each iteration = 3log(2k) Since there are k iterations, the total time = k * 3log(2k) = 3k(log2k) = k log(k) image-20200113213713121 1 2a 2b 3a 3b 3b 3c 4 k= 7 your solution return 3c, correct answer should be 4. The reason is due to the fact that 3b was generated twice! Our question is how to de-duplicate 3b 3b? method1: we can use a hash_ set &lt;pair&lt;x, y&gt;&gt; method2: use another 2D matrix to save if a node is visited or not Graph Search Algorithms II (DFS) image-20200227214109152 ##Hash table image-20200227215141422 String I image-20200227215830965 String II image-20200227220624305 Recursion II image-20200227221324735 Dynamic Programming I image-20200228013638237 Dynamic Programming II image-20200228013825791 Probability, Sampling, Randomization, etc. image-20200228014427275 Recursion III Q1. Tree + Recursion 第一类问题: Use recursion to return values in a bottom-up way in binary tree Q1.1 Determine whether a binary tree is a balanced binary tree (O(nlogn) solution). What's the definition of &quot;balanced&quot;? It could be: the tree has a minimum possible overall height no leaf is too further away. i.e. 0 or 1, from root to any other leaf left and right sub-tree have similar height, i.e. difference is 0 or 1 (balanced height) 旧的解法 O(nlogn) 1234567891011public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123; return false; &#125; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125; Q1.2 Determine whether a binary tree is a balanced binary tree (O(n) solution). 1234567891011121314151617181920212223public boolean isBalanced(TreeNode root) &#123; int result = getHeight(root); if (result &gt; 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;// helperpublic int getHeight(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int leftHeight = getHeight(root.left); // step 1 int rightHeight = getHeight(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123; // step 2 return -1; &#125; return Math.max(leftHeight, rightHeight) + 1; // step 3&#125; Q1.3 Given a binary tree in which each node element contains a number. Find the maximum possible sum from one leaf node to another. The maximum sum path may or may not go through root. For example, in the following tree, the maximum sum is 27( 3 + 6 + 9 + 0 - 1 + 10). Expected time complexity is O(n). Way of thinking (Tricks) What do you expect from your lchild / rchild ? Max single path in my left subtree (1) Max single path in my right subtree (2) What do you want to do in the current layer ? update global_max = left + right + root.value if feasible What do you want to report to your parent ? it is usually the return type of the recursion function 12345678910111213141516171819private int max = Integer.MIN_VALUE;public int maxPathSum(TreeNode root) &#123; maxPath(root); return max;&#125;public int maxPath(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = maxPath(root.left); int right = maxPath(root.right); if (root.left != null &amp;&amp; root.right != null) &#123; max = Math.max(max, root.key + left + right); return Math.max(left, right) + root.key; &#125; return root.left == null ? root.key + right : root.key + left;&#125; Q1.4 (人字形Path问题) Get Maximum sum of the path cost from any node to any node (not necessarily from leaf to leaf). Way of thinking (Tricks) What do you expect from your lchild / rchild ? Max single path in my left subtree (ended at the left child node) If this value is negative, we discard it Max single path in my right subtree (ended at the right child node) If this value is negative, we discard it What do you want to do in the current layer ? update global_max = left + right + root.value if feasible What do you want to report to your parent ? it is usually the return type of the recursion function 123456789101112131415161718192021222324public class MaximumPathSumBinaryTree2 &#123; private int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; helper(root); return max; &#125; private int helper(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = helper(root.left); int right = helper(root.right); left = left &lt; 0 ? 0 : left; right = right &lt; 0 ? 0 : right; max = Math.max(max, root.key + left + right); return root.key + Math.max(left, right); &#125; // Time complexity is O(n). // Space complexity is O(n), because of call-stack, if the binary tree is highly unbalanced.&#125; Q2. Tree + Recursion 第二类问题: (Path Problem in binary tree) Discussion: Note that: Tree相关问题，路径种类可以分为两大类 Class 1: 人字形path，这类题一般需要从下往上传integer value (E.g., Q1.1 - 1.4 above) Class 2: 从root往下（直上直下）path Key point: carry a 直上直下 path prefix（非人字形）while traversing the tree: ​ a. complete path from leaf to root ​ b. sub-section of complete path from leaf to root ​ 10 ​ / ​ -2 7 / 8 -4 Prefix_of_path = {10, -2, -4} Q2.1 Given a binary tree in which each node contains an integer number. Find the maximum possible sub-path sum from root node to leaf node. 12345678910111213141516// Assumption: root != nullpublic class MaximumPathSumBinaryTree4 &#123; public int maxPathSum(TreeNode root) &#123; if (root.left == null &amp;&amp; root.right == null) &#123; return root.key; &#125; int left = (root.left == null) ? 0 : maxPathSum(root.left); int right = (root.right == null) ? 0 : maxPathSum(root.right); return root.key + Math.max(left, right); &#125; // Time complexity is O(n). // Space complexity is O(n), if the binary tree is highly unbalanced.&#125; 123456789101112void maxPath(TreeNode* root, int sum, int&amp; globalMax) &#123; if (root == NULL) &#123; return; // base case 1 &#125; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; globalMax = max(sum + root-&gt;val, globalMax); return; // base case 2 &#125; maxPath(root-&gt;left, sum + root-&gt;val, globalMax); // go left maxPath(root-&gt;right, sum + root-&gt;val, globalMax);// go right&#125; Q2.2 Given a binary tree in which each node contains an integer number. Determine if there exists a path (the path can only be from one node to itself or to any of its descendants), the sum of the numbers on the path is the given target number. recursion function + dp past prefix trick 123456789101112131415161718192021222324252627282930313233343536373839import java.util.HashSet;import java.util.Set;public class BinaryTreePathSumToTarget3 &#123; public boolean exist(TreeNode root, int target) &#123; if (root == null) &#123; return false; &#125; Set&lt;Integer&gt; prefixSums = new HashSet&lt;&gt;(); prefixSums.add(0); return DFS(root, target, 0, prefixSums); &#125; private boolean DFS(TreeNode root, int target, int prefixSum, Set&lt;Integer&gt; prefixSums) &#123; prefixSum += root.key; if (prefixSums.contains(prefixSum - target)) &#123; return true; &#125; // add boolean needRemove = prefixSums.add(prefixSum); // dfs if (root.left != null &amp;&amp; DFS(root.left, target, prefixSum, prefixSums)) &#123; return true; &#125; if (root.right != null &amp;&amp; DFS(root.right, target, prefixSum, prefixSums)) &#123; return true; &#125; // remove if (needRemove) &#123; prefixSums.remove(prefixSum); &#125; return false; &#125; // Time complexity is O(n). // Space complexity is O(n), if binary tree is highly unbalanced &#125; 那个remove的标记逻辑是这样的， 1） 如果加的prevsum不在集合中存在，就是true，也好理解，就是你如果当前节点探索完了，你就回到父亲节点，刚才的prevsum值应该无效了，因为set中保留的是相对当前考察节点有意义的累加值集合，就是它上边一直到根节点的所有可能累加值。删掉的是刚才子节点对应的prevsum。 2）而如果prevsum的值已经出现过，那说明不是因为当前的prevsum插入导致的，而是直到根节点的路径上某个节点导致的，这样就不应该删，那个数还有用。 比如： ​ 4 ​ / ​ 2 -3 ​ / ​ 4 2 ​ / ​ -4 处理到-3，prevsum应该是4+(-3)=1 此时1在返回前删 处理到-4，prevsum应该是4+(-3)+4+(-4)=1 此时1在递归返回前不删 带这个逻辑的递归保证了只在第一次出现那个数的地方删。 Q2.3 Given a binary tree in which each node contains an integer number. Find the maximum possible sub-path sum (both the starting and ending node of the sub-path should be on the same path from root to one of the leaf nodes, and the sub-path is allowed to contain only one node). DP solution: 从上往下的 max subarray sum 1234567891011121314151617181920212223// sum represents [from the root node to the current node] the largest sum of the path prefix (must including the current node)public class Solution &#123; public int maxPathSum(TreeNode root) &#123; // Write your solution here int[] max = &#123;Integer.MIN_VALUE&#125;; int sum = Integer.MIN_VALUE; helper(root, max, sum); return max[0]; &#125; public void helper(TreeNode root, int[] max, int sum) &#123; if (root == null) &#123; return; &#125; if (sum &lt; 0) &#123; sum = root.key; &#125; else &#123; sum += root.key; &#125; max[0] = Math.max(max[0], sum); helper(root.left, max, sum); helper(root.right, max, sum); &#125;&#125; 从下往上的 max subarray sum 12345678910111213141516171819202122232425public class MaximumPathSumBinaryTree3 &#123; private int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; helper(root); return max; &#125; private int helper(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = helper(root.left); int right = helper(root.right); left = left &lt; 0 ? 0 : left; right = right &lt; 0 ? 0 : right; max = Math.max(max, root.key + Math.max(left, right)); return root.key + Math.max(left, right); &#125; // Time complexity is O(n). // Space complexity is O(n), because of call-stack, if the binary tree is // highly unbalanced.&#125; Q3. Tree + Recursion 第三类问题: Tree Serialization Problem Q3.1 Given a binary tree, convert it to a doubly linked list with its in-order sequence. Key Points: When traverse to a current node, we need to know which node was the previous node Never ever lost the control over the new head. (We need to return the new Head) 1234567891011121314151617181920212223242526public class BinaryTreeToDoublyLinkedList &#123; static Node prev = null; public Node convert(Node root) &#123; Node[] head = new Node[] &#123; null &#125;; helper(root, head); return head[0]; &#125; private void helper(Node root, Node[] head) &#123; // base case if (root == null) &#123; return; &#125; helper(root.left, head); if (prev == null) &#123; // initially head[0] = root; &#125; else &#123; root.left = prev; prev.right = root; &#125; prev = root; helper(root.right, head); &#125;&#125; Find the node with max different JAVA 答案的疑问 闫老师在存node和max different的时候，实用数组来储存的，node[0]和diff[0]。想请教下闫老师处于什么考虑用数组来存这两个值，而不用单个一个TreeNode node 和 int diff来存？ 这个是pass by value和pass by reference的区别。 java passes the object reference 'by value'. When an object is passed as argument to a method, actually the reference to that object is passed. The formal parameter is a mapping of the reference to the actual. 体会下下面两个的区别。 12345678910111213141516public static void foo1(int diff) &#123; diff = 2;&#125;public static void foo2(int[] diff) &#123; diff[0] = 2;&#125;public static void main(String[] args) &#123; int a = 0; int[] b = &#123;0&#125;; foo1(a); foo2(b); System.out.println(a); System.out.println(b[0]);&#125; Q4. Tree + Recursion 第四类问题: Tree De-serialization Problem Discussion: Reconstruct a tree by using xxx-order and in-order traversal sequences 此类问题的要点是把global的问题一分为二 (recursively), 每半边返回一个subtree的root node. Recursion 需要掌握的知识点: 表象上: function calls itself 实质上: Boil down a big problem to smaller ones (size n depends on size n-1, or n-2 or...n/2) Implementation上: a) 1. Base case: smallest problem to solve b) 2. Recursive rule. how to make the problem smaller (if we can resolve the same problem but with a smaller size, then what is left to do for the current problem size n) 4) In more details (Recursive Function Signature must keep the same logic) Q4.1 Given the pre-order and in-order traversal sequence of a binary tree, reconstruct the original tree. ​ 10 ​ / ​ 5 15 ​ / / ​ 2 7 12 20 Index: 0 1 2 3 4 5 6 Preorder: 10 5 2 7 15 12 20 Inorder: 2 5 7 10 12 15 20 1234567891011121314151617181920public class Solution &#123; public TreeNode reconstruct(int[] inorder, int[] preorder) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; inorder.length; i++) &#123; map.put(inorder[i], i); &#125; return helper(preorder, inorder, 0, inorder.length - 1, 0, preorder.length - 1, map); &#125; private TreeNode helper(int[] preorder, int[] inorder, int inL, int inR, int preL, int preR, Map&lt;Integer, Integer&gt; map) &#123; //base case if(inL &gt; inR) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preL]); int size = map.get(preorder[preL]) - inL; root.left = helper(preorder, inorder, inL, inL + size - 1, preL + 1, preL + size, map); root.right = helper(preorder, inorder, inL + size + 1, inR, preL + 1 + size, preR, map); return root; &#125;&#125; Q4.2 Given the postorder and inorder traversal sequence of a binary tree, reconstruct the original tree. 12345678910111213141516171819202122232425262728293031323334353637import java.util.HashMap;import java.util.Map;// Assumption:// 1. The given sequences are not null and they have the same length// 2. There are no duplicate keys in the binary treepublic class ReconstructBinaryTreeWithPostorderAndInorder &#123; public TreeNode reconstruct(int[] in, int[] post) &#123; Map&lt;Integer, Integer&gt; map = indexMap(in); return helper(post, map, 0, in.length - 1, 0, post.length - 1); &#125; private Map&lt;Integer, Integer&gt; indexMap(int[] in) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; in.length; i++) &#123; map.put(in[i], i); &#125; return map; &#125; private TreeNode helper(int[] post, Map&lt;Integer, Integer&gt; map, int inLeft, int inRight, int postLeft, int postRight) &#123; if (inLeft &gt; inRight) &#123; return null; &#125; TreeNode root = new TreeNode(post[postRight]); int inMid = map.get(root.key); root.left = helper(post, map, inLeft, inMid - 1, postLeft, postLeft + inMid - inLeft - 1); root.right = helper(post, map, inMid + 1, inRight, postLeft + inMid - inLeft, postRight - 1); return root; &#125; // Time complexity is O(n). // Space complexity is O(n).&#125; Q4.3 Given the levelorder and inorder traversal sequence of a binary tree, reconstruct the original tree. ​ 20 ​ / ​ 8 22 ​ / ​ 4 12 ​ / ​ 10 14 Index: 0 1 2 3 4 5 6 In-order: 4 8 10 12 14 20 22 Level-order: 20 8 22 4 12 10 14 20 index in in-order 5 Level-order left = {8, 4, 12, 10, 14} Level-order right = {22} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;// Given the levelorder and inorder traversal sequence of a binary tree, reconstruct the original tree.// Assumption:// 1. The given sequences are not null and they have the same length// 2. There are no duplicate keys in the binary treepublic class ReconstructBinaryTreeWithLevelorderAndInorder &#123; public TreeNode reconstruct(int[] in, int[] level) &#123; Map&lt;Integer, Integer&gt; map = indexMap(in); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i : level) &#123; list.add(i); &#125; return helper(map, list); &#125; private Map&lt;Integer, Integer&gt; indexMap(int[] in) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; in.length; i++) &#123; map.put(in[i], i); &#125; return map; &#125; private TreeNode helper(Map&lt;Integer, Integer&gt; map, List&lt;Integer&gt; list) &#123; // base case if (list.isEmpty()) &#123; return null; &#125; TreeNode root = new TreeNode(list.get(0)); List&lt;Integer&gt; left = new ArrayList&lt;&gt;(); List&lt;Integer&gt; right = new ArrayList&lt;&gt;(); for (int i : list) &#123; if (map.get(i) &lt; map.get(root.key)) &#123; left.add(i); &#125; else if (map.get(i) &gt; map.get(root.key)) &#123; right.add(i); &#125; &#125; root.left = helper(map, left); root.right = helper(map, right); return root; &#125; // Time complexity is O(n^2) in the worst case, but O(n*log(n)) in the // average case. // Space complexity is O(n).&#125; Q4.4 Construct a BST tree from Pre-order traversal only. ​ 10 ​ / ​ 5 15 ​ / / ​ 2 7 12 20 Index: 0 1 2 3 4 5 6 Preorder: 10 5 2 7 15 12 20 ​ 10 ​ ?L ?R ​ smaller than 10 bigger than 10 123456789101112131415161718192021222324// Assumption:// 1. The given sequence is not null// 2. There are no duplicate keys in the binary search treepublic class ReconstructBSTWithPreorder &#123; public TreeNode reconstruct(int[] pre) &#123; int[] index = new int[] &#123; 0 &#125;; return helper(pre, index, Integer.MAX_VALUE); &#125; private TreeNode helper(int[] pre, int[] index, int max) &#123; if (index[0] &gt;= pre.length || pre[index[0]] &gt; max) &#123; return null; &#125; TreeNode root = new TreeNode(pre[index[0]++]); root.left = helper(pre, index, root.key); root.right = helper(pre, index, max); return root; &#125; // Time complexity is O(n). // Space complexity is O(n).&#125; End]]></content>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg]]></title>
    <url>%2F2020%2F02%2F10%2Fffmpeg%2F</url>
    <content type="text"><![CDATA[如果一个视频只有一个声道有声音，如何通过串流让左右声道都能听见声音呢？ 安装ffmpeg 从视频中提取声音 ffmpeg -i video.mp4 -vn a.mp3 单声道混合成双声道 ffmpeg -i a.mp3 -filter_complex channelsplit=channel_layout=stereo out.mka 视频加载外挂声音文件 截取视频片段 ffmpeg -ss 00:00:00 -t 02:55:00 -i /Volumes/sed/Class177.mp4 -vcodec copy -acodec copy /Volumes/sed/Class17.mp4]]></content>
  </entry>
  <entry>
    <title><![CDATA[Karabiner]]></title>
    <url>%2F2020%2F02%2F07%2FKarabiner%2F</url>
    <content type="text"><![CDATA[Solve virtual_hid_device_client not connected yet problem It seems there is some error around loading kext. Could you execute the following command in Terminal app? (The root password will be required in order to run kextutil command.) 1sudo kextutil -t '/Library/Application Support/org.pqrs/Karabiner-VirtualHIDDevice/Extensions/org.pqrs.driver.Karabiner.VirtualHIDDevice.v061000.kext' Setting image-20200207153351446 image-20200207153408932]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDE实践1]]></title>
    <url>%2F2020%2F01%2F29%2FSDE%E5%AE%9E%E8%B7%B51%2F</url>
    <content type="text"><![CDATA[interface vs. abstract class A class must be declared abstract when it has one or more abstract methods. A method is declared abstract when it has a method heading, but no body - which means that an abstract method has no implementation code inside like normal methods do. 1234567891011121314151617181920abstract class Figure &#123; public abstract float getArea(); public void print() &#123; System.out.println("This is a Figure"); &#125;&#125;class Circle extends Figure &#123; private float radius; public float getArea() &#123; return (3.14f * (radius * radius)); &#125;&#125;class Rectangle extends Figure &#123; private float length, width; public float getArea() &#123; return length * width; &#125;&#125; An interface differs from an abstract class has only abstract methods. 123456789101112131415161718192021222324252627282930313233343536373839404142434445interface CanBark &#123; public void bark();&#125;class Husky implements CanBark &#123; public void bark() &#123; System.out.println("wuuuuu!"); &#125;&#125;class Wolf implements CanBark &#123; @Override public void bark() &#123; System.out.println("ooooooouu!"); &#125;&#125;class Cat implements CanBark &#123; @Override public void bark() &#123; System.out.println("meow"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; List&lt;CanBark&gt; myTeam = new LinkedList&lt;&gt;(); Husky myHusky = new Husky(); Wolf myWolf = new Wolf(); Cat myCat = new Cat(); myTeam.add(myHusky); myTeam.add(myWolf); myTeam.add(myCat); for (CanBark player : myTeam) &#123; player.bark(); &#125; &#125;&#125;/* wuuuuu!ooooooouu!meow*/ Difference: Java does not allow multiple inheritance. In Java, a class can only derive from one class, whether it's abstract or not. However, a class can implement multiple interfaces. 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; A a = new A(); a.printOut(); // "hey, it's class A" B b = new B(); b.printOut(); // “hey, it's class B” C c = new C(); c.printOut(); // ??? &#125;&#125;class A &#123; public void printOut() &#123; System.out.println("hey, it's class A"); &#125;&#125;class B &#123; public void printOut() &#123; System.out.println("hey, it's class B"); &#125;&#125;// if we allow multiple inheritanceclass C extends A, B &#123;&#125; 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; C c = new C(); c.printOut(); &#125;&#125;interface A &#123; public void printOut();&#125;interface B &#123; public void printOut();&#125;class C implements A, B &#123; @Override public void printOut() &#123; System.out.println("hey, it's class C"); &#125;&#125; An abstract class may provide some methods with definitions - so an abstract class can have non-abstract methods with actual implementation details. An abstract class can also have constructors and instance variables as well. An interface, however, can not provide any method definitions - it can only provide method headings. Any class that implements the interface is responsible for providing the method definition/implementation. abstract: is a ; interface: has a function 1234567891011121314public abstract class Door &#123; abstract void open(); abstract void close();&#125;public interface Alarm &#123; void alarm();&#125;public class AlarmDoor extends Door implements Alarm &#123; void open() &#123;...&#125; void close() &#123; &#125; void alarm() &#123; &#125;&#125; Interview Question: When will you use abstract class vs. interface? An abstract class is good if you think you will plan on using inheritance since it provides a common base class implementation to derived classes. An abstract class is also good if you want to be able to declare non-public members. In an interface, all methods must be public. If you think you will need to add methods in the future, then an abstract class is a better choice. Because if you add new method headings to an interface, then all of the classes that already implement that interface will have to be changed to implement the new methods. Interfaces are a good choice when you think that the API will not change for a while. Interfaces are also good when you want to have something similar to multiple inheritance, since you can implement multiple interfaces. Access Modifier Definition public - everyone can access private - only myself can access (but only at class level, other objects of the same class can access as well) protected - only my children and same package can access default - only the same package can access Use the possibly strictest access modifier! Modifier Class Package Subclass World public Y Y Y Y protected Y Y Y N no modifier Y Y N N private Y N N N Exceptions An Exception indicates conditions that a reasonable application might want to catch.An Error indicates serious problems that a reasonable application should not try to catch: StackOverflowError, Both Error and Exceptions extend from Throwable. image-20200129153755879]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDE实践]]></title>
    <url>%2F2020%2F01%2F17%2FSDE%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[List ListNode 123456789101112class ListNode &#123; public int value; // any type public ListNode next; // public ListNode prev; public ListNode(int value) &#123; this.value = value; this.next = null; &#125;&#125;ListNode head = new ListNode(3);head.next image-20200118131650193 temp.next = temp.next.next // is okay what if: current.next = current.next.next // NullPointerException Examples of Linked List Operations: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// length() 1 -&gt; 2 -&gt; 3 -&gt; nullint length(ListNode head) &#123; int length = 0; while (head != null) &#123; length++; head = head.next; &#125; // head == null return length;&#125;/*** get(index)* 1 -&gt; 2 -&gt; 3 -&gt; null* index = 0 -&gt; return 1* index = 4 -&gt; return null*/ListNode get(ListNode head, int index) &#123; while (index &gt; 0 &amp;&amp; head != null) &#123; head = head.next; index--; &#125; // index &lt;= 0 || head == null return head;&#125;// appendHead()ListNode appendHead(ListNode head, int value) &#123; ListNode newHead = new ListNode(value); newHead.next = head; return newHead;&#125;//appendTail()ListNode appendTAil(ListNode head, int value) &#123; // 1. head == null if (head == null) &#123; return new ListNode(value); &#125; // 2. head != null, find the last node in the list. ListNode prev = head; while (prev.next != null) &#123; prev = prev.next; &#125; // exit the while loop when prev.next == null prev.next = new ListNode(value); return head;&#125; head could be changed - we need to return the new head if changed usually need to consider head == null head.next = null while loop - we need to understand what is the terminate condition List Interface An ordered collection (sometimes called a sequence). Lists can contain duplicate elements. The user of a List generally has precise control over where in the list each element is inserted and can access elements by their index. Provided functionalities(interfaces) Random Access: set(int index, E e) get(int index) add(int index, E e), add(E e) remove(int index) Search Iterator Range-View Other useful methods: isEmpty(); size(); Most popular implementation class: ArrayList, LinkedList. Abstract class, interface Both can have methods declared without implementation (abstract methods). 1234567891011121314151617181920212223242526272829interface Dictionary &#123; // index out of bound, it will return null. public Integer get(int index);&#125;Dictionary myDict = new Dictionary(); // Wrong!class Dictionarylmpl implements Dictionary &#123; @Override public Integer get(int index) &#123; &#125;&#125;//abstract class/Interface: you cannot instantiate an object by abstract class or interfacepublic int search(Dictionary dict, int target) &#123; return dict.get(target);&#125;interface A &#123; public void print();&#125;class B implements A &#123; @Override public void printf() &#123; System.out.println("B"); &#125;&#125; Declare into a general type, initialize into a concrete type (Interfaces are also types): 1234List&lt;Node&gt; myList = new LinkedList&lt;Node&gt;();myList.get(5); // finemyList.set(5,7);// finemyList.poll(); // not fine Preserve the general semantic of a List Can only use methods in a List interface Not to make any assumptions on implementation Make sure interchangeable in future Provide concrete implementation by using LinkedList Choose the best implementation for the current use case list: size() is O(1) time complexity because of eager computation 123isEmpty() &#123; return (size == 0);&#125; 节省代码量，同时使逻辑更清晰。 Comparison Operation ArrayList LinkedList get(int index) at head/tail O(1) O(1) - maintain both head and tail get(int index) in middle O(1) O(n) set(int index) at head/tail O(1) O(1) set(int index) in middle O(1) O(n) add(int index, E e) in middle O(n) O(n) add(int index, E e) at head O(n) O(1) add(E e) at tail amortized: O(1) O(1) remove(int index) at head O(n) O(1) remove(int index) at tail O(1) O(1) remove(int index) at middle O(n) O(n) size() O(1) O(1) isEmpty() O(1) O(1) When to choose what? ArrayList or LinkedList? If you have a lot of random access operations, use ArrayList. If you always add/remove at the end, use ArrayList When the time complexity is similar for using ArrayList and LinkedList, use ArrayList. (ArrayList use memory more efficiently - For each element LinkedList need to create different ListNode in memory, there is extra cost of storing the &quot;next&quot;, &quot;prev&quot; reference, and the allocation is not contiguous). Stack and Vector class are not recommended, whenever you need a Vector, use ArrayList, whenever you need a Stack, use LinkedLIst. E.g. reason: http://stackoverflow.com/questions/25922201/linkedlist-vs-stack image-20200119125154342 ArrayList ArrayList is regarded as a resizable array. maintain an array with potential unused cells will expand the array if there is no unused cells available by replacing the maintained array with a new larger array (1.5 times larger by default) 123456class ArrayList&lt;E&gt; &#123; private E[] array; // the maintained array, the current maximum capacity is array.length private int size; // the number of actually used cells in the maintained array // But, you don't have direct access to these internal implementation details. ……&#125; get(int index): array[index] set(int index, E e): array[index] = e size(): // size means the number of used cells, not the capacity. when call add(), remove(), size is modified as well call add(11): array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, size = 10, capacity = 10 (array.length). call add(11): check if it is full (size = capacity) if it is full, create a new array1, array1's size= 1.5 * array's size, copy all the element in array to array1, and change the maintained array to array1. array1 = new Integer[size * 1.5] array1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, null, null, null, null, null} size = 10, capacity= 15 array = array1 set the 11th element's value to 11, size++. array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, null, null, null, null} size= 11, capacity= 15 call add(int index, E e): expand if necessary then right move all the elements after index by 1, set the element at index. Example: array= {1, 3, 4, 5, 6, null, null, null, null, null}, size = 5, capacity = 10 call add(1, 2) - add Integer 2 at index 1 do not need to expand since size &lt; capacity move all the elements of {3, 4, 5, 6} right by 1 position, size++ array= {1, 2, 3, 4, 5, 6, null, null, null, null}, size = 6, capacity = 10 set index 1 as Integer 2 array = {1, 2, 3, 4, 5, 6, null, null, null, null} call remove(1): remove the element at index 1 check if index out of bound first. move all the elements of {3, 4, 5, 6} left by 1 position, size-- LinkedList backend by a doubly linked list, wrap the size, head and tail information. 123456789101112131415class ListNode&lt;E&gt; &#123; E e; private ListNode&lt;E&gt; prev; private ListNode&lt;E&gt; next;&#125;class LinkedList&lt;E&gt; &#123; private ListNode&lt;E&gt; head; private ListNode&lt;E&gt; tail; private size;&#125;public E get(int index) &#123; // traverse from head and find the node at index.&#125; get(int index) - from the head/tail, traverse the list to get the element at index set(int index, E e) - from the head/tail, traverse the list to the get the element at index, and change it add(int index, E e), add(E e) at tail - append new node after tail and update tail to the new added node at head - insert in front of the head, and update head to the new added node at middle remove(int index) at head - update the head to head.next at tail - update the tail to tail.prev at middle · from head/tail, traverse the list to get the element at index, and remove it. size() - O(1) - eager computation. isEmpty() Something about coding null &amp; empty collections, array 12345int[] array = null;int[] array = new int[O]; // can contain 0 element. is okay!ArrayList&lt;lnteger&gt; list = null;ArrayList&lt;lnteger&gt; list = new ArrayList&lt;Integer&gt;(); They are DIFFERENT! null - there is no array object associated with the reference empty array/list - there is an array/list object, but the array/list object does not contain any element, yet (length/size == 0). Example 12345678910111213141516171819202122// 1 ArrayList&lt;Integer&gt; list = null;if (list.isEmpty()) &#123; // NullPointerException System.out.println(list.size());&#125;System.out.println(list.get(0)); // 2ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();if (list.isEmpty()) &#123; System.out.println(list.size());&#125;System.out.println(list.get(0)); // ArraylndexOutOfBoundException // 3int[] array = null;System.out.println(array[0]); // NullPointerException// 4int[] array = new int[0];System.out.println(array[0]); // ArraylndexOutOfBoundException Check corner cases &amp; boundary conditions if (array.length == 0 || array == null) X NullPointerException if (array == null || array.length == 0) Remember: always do null check before any ofher checks. The logic expressions are evaluated from left to right (short circuit) The things to keep in mind Check null - check at very first place Check length/size/head == null/head.next == null/other initial check conditions. Check index out of bound/NullPointer (even inside the for/while loop) keep in mind any index can not be out of range(&lt; 0 ll &gt;= array.length). keep in mind some ListNode reference might be null. What is the termination condition of for/while loop Make some concrete examples to determine if the logic is correct. About dummy node It is not a must, but can make your life much easier, there are several suitable conditions using dummy will be very handy. the head could be changed when solving the problem Example - insert a value into a sorted list 1-&gt; 3 -&gt; 5 insert 4 dummy -&gt; 0 -&gt; 1 -&gt; 3 -&gt; 5. prev while (prev.next != null &amp;&amp; prev.next.val &lt; val){ prev = prev.next; } 1). With dummy node's help 12345678910111213public ListNode insert(ListNode head, int val) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode newNode = new ListNode(val); ListNode curr = dummy.next, prev = dummy; while (curr != null &amp;&amp; curr.val &lt; val) &#123; prev = curr; curr = curr.next; &#125; prev.next = newNode; newNode.next = curr; return dummy.next;&#125; 2). Without dummy node's help 123456789101112131415161718public ListNode insert(ListNode head, int val) &#123; ListNode newNode = new ListNode(val); // check head. if (head == null || val &lt;= head.val) &#123; newNode.next = head; return newNode; &#125; // the inserted node is not the new head. ListNode cur = head; // find first node &gt;= val cur, cur.next while (cur.next != null &amp;&amp; cur.next.val &lt; val) &#123; cur = cur.next; &#125; // cur.next == null || cur.next.val &gt;= val newNode.next = cur.next; cur.next = newNode; return head;&#125; not sure yet which node will be head when constructing the list 3 -&gt; 5 4 -&gt; 6 dummy -&gt; 1 -&gt; 2 -&gt; …… Example - merge two sorted list 1). With dummy node's help 1234567891011121314151617181920212223public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode dummy = new ListNode(0); ListNode curr = dummy; while (h1 != null &amp;&amp; h2 != null) &#123; if (h1.value &lt;= h2.value) &#123; curr.next = h1; h1 = h1.next; &#125; else &#123; curr.next = h2; h2 = h2.next; &#125; curr = curr.next; &#125; if (h1 != null) &#123; curr.next = h1; &#125; if (h2 != null) &#123; curr.next = h2; &#125; return dummy.next;&#125; 2). Without dummy node's help 1234567891011121314151617181920212223242526272829303132333435public ListNode merge(ListNode h1, ListNode h2) &#123; if (h1 == null) &#123; return h2; &#125; if (h2 == null) &#123; return h1; &#125; ListNode head = null; if (h1.val &lt;= h2.val) &#123; head = h1; h1 = h1.next; &#125; else &#123; head = h2; h2 = h2.next; &#125; ListNode curr = head; while (h1 != null &amp;&amp; h2 != null) &#123; if (h1.value &lt;= h2.value) &#123; curr.next = h1; h1 = h1.next; &#125; else &#123; curr.next = h2; h2 = h2.next; &#125; curr = curr.next; &#125; if (h1 != null) &#123; curr.next = h1; &#125; if (h2 != null) &#123; curr.next = h2; &#125; return head;&#125; Tips: 尽量不使用global variable image-20200119190001164 Queue &amp; Stack &amp; Deque In Java In Java, we usually refer it to Queue and Deque interface. A collection to hold multiple elements prior to processing. Contains a buffer and specifies a mechanism to choose which is the next element to process. Queue - FIFO (exception: PriorityQueue) http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html offer() - offer at the tail poll()- poll at the head peek() - look at the head without polling it out Deque - FIFO &amp; LIFO (both queue and stack) http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html provide both offer at head/tail, poll at head/tail, and peek at head/tail so it can be used as a queue, or a stack. Common APIs image-20200119190313790 Use the same set of APIs What's the point: java Queue中 add/offer，element/peek，remove/poll区别 image-20200119191230171 Other useful methods: isEmpty(); size(); All the operations' cost is O(1). Most popular implementation class: LinkedList, ArrayDeque(Java 6 onwards). When you need a queue or stack, you can just use LinkedList, as it implements both Queue and Deque interfaces. (Do not use Stack class. ) ArrayDeque: no null values in deque. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.ArrayList;import java.util.Deque;import java.util.LinkedList;import java.util.Queue;public class Main &#123; public static void main(String[] args) &#123; // head(first) -&gt; &#123;1, 2, 3&#125; &lt;- tail(last) Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(1); queue.offer(2); queue.offer(3); while (!queue.isEmpty()) &#123; System.out.println(queue.peek()); System.out.println(queue.poll()); &#125; System.out.println(queue.peek()); System.out.println(queue.poll()); /** * If you are using deque as stack, you can choose the group of methods: * offerFirst() - push() * pollFirst() - pop() * peekFirst() - peek() */ // head(first) -&gt; &#123;3, 2, 1&#125; &lt;- tail(last) Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); stack.offerFirst(1); stack.offerFirst(2); stack.offerFirst(3); while (!stack.isEmpty()) &#123; System.out.println(stack.peekFirst()); System.out.println(stack.pollFirst()); &#125; System.out.println(stack.peekFirst()); System.out.println(stack.pollFirst()); // head(first) -&gt; &#123;3, 2, 1, 4, 5, 6&#125; &lt;- tail(last) // 3, 6, 2, 5, 1, 4, null, null, null, null Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); deque.offerFirst(1); deque.offerFirst(2); deque.offerFirst(3); deque.offerLast(4); deque.offerLast(5); deque.offerLast(6); int size = deque.size(); for (int i = 0; i &lt; size; i++) &#123; if (i % 2 == 0) &#123; System.out.println(deque.peekFirst()); System.out.println(deque.pollFirst()); &#125; else &#123; System.out.println(deque.peekLast()); System.out.println(deque.pollLast()); &#125; &#125; System.out.println(deque.peekFirst()); System.out.println(deque.pollFirst()); System.out.println(deque.peekLast()); System.out.println(deque.pollLast()); &#125;&#125; Our Own Implementation Stack, Queue and Deque are not premier data structures, their implementation depend on other data structures - what could be the candidates? - sequence type(线性的) In general, two ways: use array use Linked list Let's see how to use Linked List to do so. Usually, when we use Linked List, we might want to determine singly linked list? doubly linked list? Stack implemented by Linked List 12345678910111213141516171819202122232425262728293031323334353637class ListNode &#123; int value; ListNode next; public ListNode(int value) &#123; this.value = value; &#125;&#125;public class Stack &#123; private ListNode head; public Stack() &#123; head = null; &#125; public void push(Integer value) &#123; ListNode newNode = new ListNode(value); newNode.next = head; head = newNode; &#125; public Integer pop() &#123; if (head == null) &#123; return null; &#125; ListNode temp = head; head = head.next; temp.next = null; // 好习惯，可省略 return temp.value; &#125; public Integer peek() &#123; if (head == null) &#123; return null; &#125; return head.value; &#125;&#125; Queue implemented by Linked List 123456789101112131415161718192021222324252627282930313233343536public class Queue &#123; ListNode head; ListNode tail; public Queue() &#123; head = tail = null; &#125; public void offer(Integer ele) &#123; if (head == null) &#123; head = new ListNode(ele); tail = head; &#125; else &#123; tail.next = new ListNode(ele); tail = tail.next; &#125; &#125; public Integer poll() &#123; if (head == null) &#123; return null; &#125; ListNode node = head; head = head.next; if (head == null) &#123; tail = null; &#125; node.next = null; return node.value; &#125; public Integer peek() &#123; if (head == null) &#123; return null; &#125; return head.value; &#125;&#125; Queue implemented by array Let's make a simpler case first, assume the capacity of the queue is bounded. First, we need to maintain the position of head and tail - use two pointers. offer = put one element, tail++ (tail points to the next available position) poll = grab element at head, head++ (head points to the next element in queue) What is the problem here? what if tail == array.length - 1 and we need to do tail++? Circular Array - we can connect the start and end of the array, so that it is a cycle. index of array.length &lt;=&gt; index of 0 Quick tip: head = head + 1 == array.length ? 0 : head + 1; // (head + 1) % array.length; Second, we need to know when empty, when full. head == tail -&gt; empty head == tail -&gt; full two solutions: record size, size = 0 (empty), size == array.length (full) head + 1 == tail -&gt; empty, head == tail -&gt; full, capacity =array.length- 1(next of head points to the head of the queue) 12345678910111213141516171819202122232425262728293031323334353637383940public class BoundedQueue &#123; int head; int tail; int size; Integer[] array; public BoundedQueue(int cap) &#123; array = new Integer[cap]; head = tail = 0; size = 0; &#125; public boolean offer(Integer ele) &#123; // 1. if (size == array.length) &#123; return false; &#125; // 2. array[tail] = ele; tail = tail + 1 == array.length ? 0 : tail + 1; size++; return true; &#125; public Integer poll() &#123; if (size == 0) &#123; return null; &#125; Integer result = array[head]; head = head + 1 == array.length ? 0 : head + 1; size--; return result; &#125; public Integer peek() &#123; if (size == 0) &#123; return null; &#125; return array[head]; &#125;&#125; Stack implemented by array 12345678910111213141516171819202122232425public class BoundedStack &#123; int[] array; int head; public BoundedStack(int cap) &#123; // check cap array = new int[cap]; head = -1; &#125; public boolean push(int ele) &#123; if (head == array.length - 1) &#123; return false; &#125; array[++head] = ele; return true; &#125; public Integer pop() &#123; return head == -1 ?null : array[head--]; &#125; public Integer top() &#123; return head == -1 ? null : array[head]; &#125;&#125; Exercise We have done Queue and Stack, how about Deque? Use Linked List can we still use singly linked list or we need doubly linked list? Use Circular Array PriorityQueue It is a heap with the same Queue interface with offer(), peek(), poll(). But, it is not FIFO, when poll() or peek() we always look at the smallest/largest element (min heap/max heap). The PriorityQueue will arrange the elements based on the order of the elements (who is smaller/larger by comparing any two of them) and it is optimized for problems about &quot;who is the smallest/largest element'. Internally it is implemented using an array. offer(E e) - insert one element into the heap peek() - peek the top element in the heap (smallest/largest based on how to order the elements) poll() - remove the top element from the heap, and return it (smallest/largest based on how to order the elements) size() isEmpty() time complexity: offer(E e) - O(log n) peek() - O(1) poll() - O(log n) remove() - O(log n), from AbstractQueue, remove(Object) - O(n) 删除任意一个元素 size()- O(1) isEmpty · O(1) Order - The PriorityQueue need to know how to compare the elements and determine which one is smaller/larger. There are two ways to do so: The element type implementing Comparable interface Example: 123456789PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;();minHeap.offer(4);minHeap.offer(5);minHeap.offer(2);minHeap.offer(3);minHeap.offer(1);while (!minHeap.isEmpty()) &#123; System.out. println(minHeap.poll());&#125; How does the priorityqueue know how to compare the Integer objects? The element's class can implement Comparable interface and thus implement the required method compare To(), PriorityQueue will use this method to compare any two elements. 1234567891011121314151617181920interface Comparable&lt;E&gt; &#123; int compareTo(E ele);&#125;// part of the Integer class implementationclass Integer implements Comparable&lt;Integer&gt; &#123; private int value; public Interger(int value) &#123; this.value = value; &#125; @Override public int compareTo(Interger another) &#123; if (this.value == another.value) &#123; return 0; &#125; return this.value &lt; another.value ? -1 : 1; &#125;&#125; The return value of compareTo(another) method determines the order of this and another: 0 - this and another are of the same priority -1 (&lt; 0) - this has higher priority than another 1 (&gt; 0) - this has less priority than another Another Example using custom class: Suppose you have an integer matrix, each row is sorted by ascending order and each column is also sorted by ascending order, we need a class to representing each cell in the matrix, and we need to compare two cells with their value in the matrix. 123456789101112131415161718192021222324252627class Cell implements Comparable&lt;Cell&gt; &#123; public int row; public int col; public int value; public Cell(int row, int col, int value) &#123; this.row = row; this.col = col; this.value = value; &#125; @Override public int compareTo(Cell another) &#123; if (this.value == another.value) &#123; return 0; &#125; return this.value &lt; another.value ? -1 : 1; &#125;&#125;// We want to have a minHeap by the value of the Cell elements.PriorityQueue&lt;Cell&gt; minHeap = new PriorityQueue&lt;Cell&gt;();Cell c1 = new Cell(0, 0, 0);Cell c2 = new Cell(0, 1, 2);minHeap.offer(c1);minHeap.offer(c2);int result = c1.comparedTo(c2);System.out.println(result); Provide an extra Comparator object to compare the elements There is another interface Comparator, it is used to compare two elements with same type E. 123interface Comparator&lt;E&gt; &#123; int compare(E o1, E o2); &#125; 12345678910111213141516171819202122232425262728293031import java.util.Comparator;class Cell &#123; public int row; public int col; public int value; public Cell(int row, int col, int value) &#123; this.row = row; this.col = col; this.value = value; &#125;&#125;class MyComparator implements Comparator&lt;Cell&gt; &#123; @Override public int compare(Cell c1, Cell c2) &#123; if (c1.value == c2.value) &#123; return 0; &#125; return c1.value &lt; c2.value ? -1 : 1; &#125;&#125;PriorityQueue&lt;Cell&gt; minHeap = new PriorityQueue&lt;&gt;(11, new MyComparator());Cell c1 = new Cell(0, 0, 0);Cell c2 = new Cell(0, 1, 2);minHeap.offer(c1);minHeap.offer(c2);System.out.println(minHeap.size());System.out.println(minHeap.poll().value);System.out.println(minHeap.size()); If class E already implements Comparable interface, and we need another way of ordering the elements in our PriorityQueue, we can pass the new Comparator. 12345678910111213141516171819202122232425262728// I want a max heap here...// So I need to provide a new Comparator, the ordering defined by the Comparator is the reversed natural order provided by Integer classimport java.util.Comparator;public class Main &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(16, new ReverseComparator()); maxHeap.offer(4); maxHeap.offer(2); maxHeap.offer(5); maxHeap.offer(3); maxHeap.offer(1); while (!maxHeap.isEmpty()) &#123; System.out.println(maxHeap.poll()); &#125; &#125;&#125;class ReverseComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer i1, Integer i2) &#123; if (i1.equals(i2)) &#123; return 0; &#125; return i1 &lt; i2 ? 1 : -1; &#125;&#125; Or, there is a utility method Collections.reverseOrder(), it will return a comparator that reverses the natural order. equals() method of a comparator: if the incoming comparator equals the current comparator, not about orders! Conclusion: To make PriorityQueue work, there are two ways: The element class E implements Comparable interface Provide a Comparator&lt; E &gt; class to compare elements. and pass an comparator object to the PriorityQueue. if E already implements Comparable&lt; E &gt;, but still you provide a Comparator, PriorityQueue will choose the order specified in Comparator. Most frequently used constructors of PriorityQueue 1. PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(); initialize the internal array with default capacity(11) class Cell must implements Comparable&lt;Cell&gt; ! 2. PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(16); initialize the internal array with specified capacity(16) class Cell implements Comparable&lt;Cell&gt; ! 3. PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(16, new MyComparator(); initialize the internal array with specified capacity(16) class MyComparator implements Comparator&lt;Cell&gt; ! Be Careful the initial capacity has to be &gt; 0: // if k &lt;= 0, IllegalArgumentException will be thrown in the constructor. PriorityQueue&lt;Cell&gt; minHeap = new PriorityQueue&lt;Cell&gt;(k, new MyComparator(); Method 1 and 2, the object inside the PQ should be comparable! Otherwise, Java will throw runtime exception (it will cast anything inside into a Comparable to do the comparison). heapify() - convert an array to heap in O(n) time ArrayList list = new ArrayList(); PriorityQueue heap = new PriorityQueue(list); initialize the internal array with heapify() internally class Cell implements Comparable ! it is not exposed to outside from PriorityQueue class, it is a private method. the only way to utilize the heapify() is to use the constructor 1234567891011121314151617// Part of the PriorityQueue implementation……class PriorityQueue&lt;E&gt; &#123; private E[] heapArray; private int size; public PriorityQueue(Collection&lt;? extends E&gt; c) &#123; heapArray = c.toArray(); size = heapArray.length; heapify(); // the only place heapify is called. &#125; private void heapify() &#123; // heapify the heapArray. for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; percolateDown(i); &#125; &#125;&#125; Nested class: define a class within a class. Static nested class vs. non-static nested class: belong to class, or belong to instance. Anonymous class: nested class with no name. Often replaceable by lambda expressions in Java8. Something about coding: nested classes Nested class: A class within another class. Why? (Official tutorial) It is a way of logically grouping classes that are only used in one place: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such &quot;helper classes&quot; makes their package more streamlined. It increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world. It can lead to more readable and maintainable code: Nesting small classes within top-level classes places the code closer to where it is used. Static nested class: a nested class associated with the outside class. Can access class variables and methods. Inner class: a nested class associated with an instance of the class. Can access instance variables and methods. Anonymous inner class (defined in a method with just new and no definition) 123456789PriorityQueue&lt;Cell&gt; pQueue = new PriorityQueue&lt;&gt;(16, new Comparator&lt;Cell&gt;() &#123; @Override public int compare(Cell o1, Cell o2) &#123; if (o1.value == o2.value) &#123; return 0; &#125; return o1.value &lt; o2.value ? -1 : 1; &#125;&#125;); Heap Implement PriorityQueue (Heap) Definition Heap is a (binary) tree based data structure Across the entire tree, the relation between a parent node and a child node stays consistent. Example: min heap the parent node is always &lt;= its two child nodes (parent node is the smallest node in the subtree rooted at itself). the relation between the two child nodes can differ. The common implementation of a heap is using a complete binary tree. * A &quot;complete binary tree&quot; is a binary tree in which every level, except possibly the last level, is completely filled, and all nodes are as far left as possible. image-20200121202717092 image-20200121202754707 Representation it can also be represented as an array (by the level order traversal of the binary tree), since it is a complete binary tree. Why? - if it is a complete binary tree, the matching between the nodes and the index of the array is determined, and the relation of parent and child nodes can be well transferred to the relation between two indices. Example: index of parent = i, what is the index of the two child nodes? left child of index i = 2 * i + 1 right child of index i = 2 * i + 2 parent of index i = (i - 1) / 2 the root of the tree is at index 0. Basic Heap Internal Operations percolateUp() when to use? the element need to be moved up to maintain the heap's property, for example, when offering a new element into the heap. how? compare the element with its parent, move it up when necessary. do this until the element does not need to be moved. percolateDown() when to use? the element need to be moved down to maintain the heap's property, for example, when poll the root element from the heap. how? compare the element with its two children, if the smallest one of the two children is smaller than the element, swap the element with that child. do this until the element does not need to be moved. Heapify() convert an array into a heap in O(n) time.(percolateDown) how? for each node that has at least one child, we perform percolateDown() action, in the order of from the nodes on the deepest level to the root.(从底向上，从右向左) the time complexity of heapify() is O(n) image-20200122143516838 ​ {10, 11, 7, 2, 8, 4, 6, 13, 3} all the red nodes are the nodes has at least one child. perform percolateDown() on each of them following the order: 2, 7, 11, 10: image-20200122143731581 if the heap has n elements, n = 9 : range [0, 3] n = 8 : range [0, 3] n = 7 : range [0, 2] .... the range of indices need to perform percolateDown() is: [0, n / 2 - 1] last index's parent = ((n - 1) - 1) / 2 = (n - 2) / 2 = n / 2 - 1 image-20200122144437341 update() if you know the position of the element you want to update, it will take O(logn). how? either you need percolateUp(), or percolateDown() on that element. what if you do not know the position of the element? you need to find the position of the element first, if not asking for help with other additional data structures, this operation is O(n) image-20200122144847244 image-20200122144914975 Time Complexity: percolateUp() - O(height) == O(logn) percolateDown() - O(height) == O(logn) Key points child index -&gt; parent index parent = (child - 1) / 2 parent index -&gt; children index left child = parent * 2 + 1 right child = parent * 2 + 2 basic internal operations of heap: percolateUp(int index) offer() update() percolateDown(int index) poll() update() heapify() Sorting algorithms (and heap) 1234int[] array = &#123;4, 5, 0, 1, 2, 3&#125;Arrays.sort(array); // quicksort.Integer[] array;Arrays.sort(array); // mergesort. quicksort: wоrѕt саѕе О(n^2), аvеrаgе О(nlоgn), ѕрасе wоrѕt саѕе О(n), аvеrаgе О(lоgn) unstable sort mergesort: worst case O(nlogn), average O(nlogn), space worst case/average O(n) stable sort Stable sorting algorithms maintain the relative order of records with equal keys (i.e. values). That is, a sorting algorithm is stable if whenever there are two records R and S with the same key and with R appearing before S in the original list, R will appear before S in the sorted list. Why object sorting needs to be stable? Example: sorting by scores, then by gender. two male students m1 and m2, if m1's score is higher than m2, then after the sort the order is preserved. https://www.youtube.com/watch?v=ZZuD6iUe3Pc Sorting algorithm: time O(nlogn), space O(1) ? heapSort (not stable): heapify the input array to maxHeap. - O(n) n times poll operation. - O(nlogn) image-20200122150620960 1234567891011121314151617181920// max heapprivate void percolateDown(int index) &#123; // check if index is legal? while (index &lt;= (size - 2) / 2) &#123; int leftChildIndex = index * 2 + 1; int rightChildIndex = index * 2 + 2; int swapCandidate = leftChildIndex; // biggest one among left child and right child // update swapCandidate if right child exists and it is bigger than left child if (rightChildIndex &lt;= size - 1 &amp;&amp; array[leftChildIndex] &lt;= array[rightChildIndex]) &#123; swapCandidate = rightChildIndex; &#125; // swap if necessary if (array[index] &lt; array[swapCandidate]) &#123; swap(array, index, swapCandidate); &#125; else &#123; break; &#125; index = swapCandidate; &#125;&#125; count sort/bucket sort/radix sort/rainbow sort Heap Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import java.util.NoSuchElementException;/** * An example implementation of capacity limited min heap containing only int values * with the capability to do update and poll at a specific index. * * This is for demonstration of percolateUp/percolateDown methods and * how to utilize these methods to do basic heap operations. * * The public methods provided are: * size() * isEmpty() * isFull() * peek() * poll() * offer() * update(int index, int value) - update the element at index to a given new value * */public class MinHeap &#123; private int[] array; private int size; public MinHeap(int[] array) &#123; if (array == null || array.length == 0) &#123; throw new IllegalArgumentException("input array cannot be null or empty"); &#125; this.array = array; size = array.length; heapify(); &#125; private void heapify() &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; percolateDown(i); &#125; &#125; public MinHeap(int cap) &#123; if (cap &lt;= 0) &#123; throw new IllegalArgumentException("capacity cannot be &lt;= 0"); &#125; array = new int[cap]; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public boolean isFull() &#123; return size == array.length; &#125; private void percolateUp(int index) &#123; while (index &gt; 0) &#123; int parentIndex = (index - 1) / 2; if (array[parentIndex] &gt; array[index]) &#123; swap(array, parentIndex, index); &#125; else &#123; break; &#125; index = parentIndex; &#125; &#125; private void percolateDown(int index) &#123; // check if index is legal? while (index &lt;= (size - 2) / 2) &#123; int leftChildIndex = index * 2 + 1; int rightChildIndex = index * 2 + 2; int swapCandidate = leftChildIndex; // smallest one among left child and right child // update swapCandidate if right child exists and it is smaller than left child if (rightChildIndex &lt;= size - 1 &amp;&amp; array[leftChildIndex] &gt;= array[rightChildIndex]) &#123; swapCandidate = rightChildIndex; &#125; // swap if necessary if (array[index] &gt; array[swapCandidate]) &#123; swap(array, index, swapCandidate); &#125; else &#123; break; &#125; index = swapCandidate; &#125; &#125; private void swap(int[] array, int i, int j) &#123; int tmp = array[i]; array[i] = array[j]; array[j] = tmp; &#125; public int peek() &#123; if (size == 0) &#123; return -1; &#125; return array[0]; &#125; public int poll() &#123; if (size == 0) &#123; throw new NoSuchElementException("heap is empty"); &#125; int result = array[0]; array[0] = array[size - 1]; size--; percolateDown(0); return result; &#125; public void offer(int ele) &#123; if (size == array.length) &#123; int[] newArray = new int[(int)Math.round(array.length * 1.5)]; //copy(array, newArray); for (int i = 0; i &lt; array.length; i++) &#123; newArray[i] = array[i]; &#125; array = newArray; &#125; array[size] = ele; size++; percolateUp(size - 1); &#125; // return the original value. public int update(int index, int ele) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new ArrayIndexOutOfBoundsException("invalid index range"); &#125; int result = array[index]; array[index] = ele; if (result &gt; ele) &#123; percolateUp(index); &#125; else &#123; percolateDown(index); &#125; return result; &#125;&#125; Extensions: How to make it capacity unbounded? when size++ &amp;&amp; is Full, need to allocate a new larger array. How to pass in a Comparator and use the Comparator to compare and determine the priority of different elements. whenever you need to compare two elements Tree Tree nodes 12345678910class TreeNode &#123; int key; TreeNode left; TreeNode right; // TreeNode parent; // We can store parent reference as well, this will be useful for solving some problems. public TreeNode(int key) &#123; this.key = key; &#125;&#125; Usually, we use the root to represent the binary tree. General Tree, each node can have arbitrary number of children. image-20200122185120370 123456789class TreeNode &#123; int key; List&lt;TreeNode&gt; children; // TreeNode parent; public TreeNode(int key) &#123; this.key = key; children = new ArrayList&lt;TreeNode&gt;(); &#125;&#125; Tree is special kind of Graph: 12345678class GraphNode &#123; int key; List&lt;GraphNode&gt; neightbors; public GraphNode(int key) &#123; this.key = key; neighbors = new ArrayList&lt;GraphNode&gt;(); &#125;&#125; Other representation: Adjacency list Vertices are stored as records or objects, and every vertex stores a list of adjacent vertices. This data structure allows the storage of additional data on the vertices. Additional data can be stored if edges are also stored as objects, in which case each vertex stores its incident edges and each edge stores its incident vertices. When coding, you can use integers to represent vertex. In this way, a graph can be represented as: List&lt;List&lt; Integer &gt;&gt; graph = ... graph.get(1) -&gt; Node 1's neighbors graph.get(2) -&gt; Node 2's neighbors .... graph.get( i ) -&gt; Node i's neighbors for (Integer i : graph.get(1)) { // i is a neighbor of node 1 } LinkedList is a special kind of Tree (if there is only one child for each of the node in the binary tree, it can be reduced to a linked list) Binary Search Tree is a binary tree maintains the following property: for any of the nodes in the binary tree, all the nodes in its right subtree is larger than itself, all the nodes in its left subtree is smaller than itself (compared by the key stored in each of the nodes). image-20200122190629893 Basic Operations of Binary Search Tree search() - worst case O(n), average O(logn) insert() - worst case O(n), average O(logn) remove() - worst case O(n), average O(logn) Balanced Binary Search Tree search(), insert(), remove() operations are all guaranteed to be O(logn). Eg. AVL Tree, Red-Black Tree, etc. Red-Black tree in Java: TreeMap/TreeSet in C++: map/set. We are not going to implement balanced binary search tree, instead we are more interested in basic implementation. Traversals of Binary Tree preorder - root, left sub, right sub inorder - left sub, root, right sub postorder - left sub, right sub, root Like LinkedList, General ways of solving problems about binary (search) tree: Recursion divide and conquer is nature of binary tree - binary tree can be easily divided into three parts solve problem for left/right subtree solve the problem for root. Iterative could be complicated for binary tree but we need to know how. Level order traversal: Try to build one for your LaiCode test cases. Search in BST 12345678910111213// recursive public TreeNode search(TreeNode root, int target) &#123; // 1. process root if (root == null || root.key == target) &#123; // terminate condition return root; &#125; // 2. check left node if target less than root.key if (target &lt; root.key) &#123; return search(root.left, target); // break point &#125; else &#123; return search(root.right, target); &#125;&#125; Tail Recursion The recursive call is always the last execution statement. We can easily transfer the tail recursive to iterative solution. image-20200122195648939 Not a tail recursion: ... return isBst(root.left, ...) &amp;&amp; isBst(root.right, ...) 12345678910111213// iterativepublic TreeNode search(TreeNode root, int target) &#123; TreeNode currentNode = root; while (currentNode != null &amp;&amp; currentNode.key != target) &#123; // terminate condition if (target &lt; currentNode) &#123; currentNode = currentNode.left; &#125; else &#123; currentNode = currentNode.right; &#125; &#125; // exit while loop: currentNode = null || currentNode.key = target return currentNode;&#125; Insert in BST image-20200122210638563 Recursion I A very common way when the tree structure could be changed, in this case, we return the new root after the change (remind about the same case of Linked List? ). 123456789101112public TreeNode insert(TreeNode root, int key) &#123; if (root == null) &#123; TreeNode newRoot = new TreeNode(key); return newRoot; &#125; if (root.key &lt; key) &#123; root.right = insert(root.right, key); &#125; else if (root.key &gt; key) &#123; root.left = insert(root.left, key); &#125; return root;&#125; Recursion II (Remove redundant operation) 12345678910111213141516171819202122232425public TreeNode insert(TreeNode root, int target) &#123; if (root == null) &#123; return new TreeNode(target); &#125; helper(root, target); return root;&#125;public void helper(TreeNode root, int target) &#123; if (target == root.key) &#123; return; &#125; else if (target &lt; root.key) &#123; if (root.left == null) &#123; root.left = new TreeNode(target); &#125; else &#123; helper(root.left, target); &#125; &#125; else &#123; if (root.right == null) &#123; root.right = new TreeNode(target); &#125; else &#123; helper(root.right, target); &#125; &#125;&#125; (target == root.key) return; // terminate target &lt; root.key: root.left == null; root.left = new TreeNode(target); // terminate else: helper(root.left, target); target &gt; root.key: root.right == null; root.right = new TreeNode(target); //terminate else: helper(root.right, target); 第二种只做了一次赋值，第一种做了多次赋值，但第一种对以后的问题有启发。 Iterative I 12345678910111213141516171819202122232425public TreeNode insert(TreeNode root, int target) &#123; TreeNode newNode = new TreeNode(target); if (root == null) &#123; return newNode; &#125; TreeNode current = root; while (current.key != target) &#123; if (current.key &gt; target) &#123; if (current.left != null) &#123; current = current.left; &#125; else &#123; current.left = newNode; break; &#125; &#125; else &#123; if (current.right != null) &#123; current = current.right; &#125; else &#123; current.right = newNode; break; &#125; &#125; &#125; return root;&#125; Iterative II 1234567891011121314151617181920212223public TreeNode insert(TreeNode root, int target) &#123; if (root == null) &#123; return new TreeNode(target); &#125; TreeNode returnRoot = root; TreeNode pre = null; while (root != null) &#123; pre = root; if (root.key &lt; target) &#123; root = root.right; &#125; else if (root.key &gt; target) &#123; root = root.left; &#125; else &#123; return returnRoot; &#125; &#125; if (pre.target &lt; target) &#123; pre.right = new TreeNode(target); &#125; else if (pre.target &gt; target) &#123; pre.left = new TreeNode(target); &#125; return returnRoot;&#125; Delete in BST delete(root, 8) step one: find the node to be deleted - trivial? step two: delete it ... - not trivial? how many possible situations? image-20200122213854361 image-20200122213935139 image-20200123111451639 image-20200123111633573 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// return: the node that replace targetpublic TreeNode delete(TreeNode root, int target) &#123; if (root == null) &#123; return null; &#125; // find target node if (root.val &gt; target) &#123; root.left = delete(root.left, target); return root &#125; else if (root.val &lt; target) &#123; root.right = delete(root.right, target); return root; &#125; // guarantee root != null &amp;&amp; root.val == target if (root.left == null) &#123; // case 1, 2 return root.right; &#125; else if (root.right == null) &#123; // case 3 return root.left; &#125; // guarentee root.left != null &amp;&amp; root.right != null // 4.1 if (root.right.left == null) &#123; root.right.left = root.left; return root.right; &#125; //4.2 // 1. find and delete smallest node in root.right. TreeNode smallest = deleteSmallest(root.right); // 2. connect the smallest node with root.left and root.right. smallest.left = root.left; smallest.right = root.right; // 3. return the smallest node. return smallest;&#125;private TreeNode deleteSmallest(TreeNode cur) &#123; TreeNode prev = cur; cur = cur.left; while (cur.left != null) &#123; prev = cur; cur = cur.left; &#125; // cur is the smallest one, and prev is its parent. // invariance: cur (prev.left) does not have left child prev.left = prev.left.right; return cur;&#125; Binary Tree Traversals (iteratively) Too easy to use recursion to solve the traversal problem. 12345678public void inorder(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorder(root.left); System.out.println(root.key); inorder(root.right);&#125; Why do we need the Iterative solution? since we already have the simple, elegant recursive solution. Recall here for Java memory areas: STACK: storing the local variables and other information for each of the method calls HEAP: allocating spaces for dynamically created objects How recursion works 12345678910111213141516171819202122public void print(int x) &#123; if (x &lt;= 0) &#123; return; &#125; print(x-1); // bp System.out.println(x); //return;&#125;print(10) /*** 1* 2* 3* 4* 5* 7* 8* 9* 10*/ The unfinished methods must be retained in STACK before it can return: when we call print(10), what will happen? STACK: tail -&gt; { } &lt;- head Does recursion consume extra spaces? - YES, the method calls use spaces on STACK. Think about calling print(1000000) now, what will happen? The space consumed on STACK: O(# of method call levels). In Java, STACK is usually a size limited memory area. By default, a several thousands levels recursion call would easily eat up all the space and throw StackOverFlowException - this is something you have to keep in mind(especially when the solution is in recursive way). Iterative way is good because it needs much less space of STACK(There is probably only O(1) method call levels, so O(1) space on STACK). It is not easy to convert all recursion solutions to a &quot;while loop&quot; solution without any other auxiliary data structures' help. 12345678public void inorder(TreeNode root) &#123; if (root == null) &#123; return; &#125; inorder(root.left); System.out.println(root.key); inorder(root.right);&#125; There are two paths of recursion need to follow instead of one, and we need to finish the first branch, then the second one. In this case, we will need something else to help us: The recursion is internally done by using STACK to maintain the method call levels and directions, we can simulate this ourselves, so a stack will be needed. The difference is, we use our own stack and the space used by our own stack is on HEAP. The space consumed on STACK is trivial. - We do not change the total space consumption, but we move out the space consumption of STACK to HEAP. image-20200123201938717 Once the root is traversed, we can print it directly and we do not need to store it in the stack any more. We always print root first, then root can be eliminated from stack. We traverse left sub first, so the right sub should be retained in the stack before the left sub is done. image-20200123202142846 1234567891011121314151617public void preOrder(TreeNode) &#123; if (root == null) &#123; return; &#125; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); stack.offerFirst(root); while (!stack.isEmpty) &#123; TreeNode cur = stack.pollFisrt(); System.out.println(cur.value); if (cur.right != null) &#123; stack.offerFirst(cur.right); &#125; if (cur.left != null) &#123; stack.offerFirst(cur.left); &#125; &#125;&#125; image-20200123204430689 The problem is, we can not throw away the root in the stack before we traversed all the nodes in left subtree. How can we know we have already traversed all the nodes in left sub? The root is the top element in the stack, use a helper node to store the next &quot;visiting&quot; node and subtree. when helper node is not null, we should traverse the subtree, so we push helper and we go left when helper is null. means the left subtree of the root is finished, the root is the top element in the stack. We can print the top and let helper = top.right. (traverse the left subtree first, then top, then right subtree) do 1 and 2 until helper is null and there is no nodes left in the stack. image-20200123205810909 1234567891011121314151617181920public void inOrder(TreeNode root) &#123; // 1. initial check if (root == null) &#123; return; &#125; // 2. we need a stack and a helper node. Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode helper = root; // 3. while (helper != null || !stack.isEmpty()) &#123; if (helper != null) &#123; stack.offerFirst(helper); helper = helper.left; &#125; else &#123; helper = stack.pollFirst(); System.out.println(helper.value); helper = helper.right; &#125; &#125;&#125; image-20200123210455528 123456789101112131415161718192021public void postOrder(TreeNode root) &#123; if (root == null) &#123; return; &#125; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); Deque&lt;TreeNode&gt; temp = new LinkedList&lt;TreeNode&gt;(); stack.offerFist(root); while (!stack.isEmpty) &#123; TreeNode cur = stack.pollFirst(); temp.offerFirst(cur); if (root.left != null) &#123; stack.offerFirst(root.left); &#125; if (root.right != null) &#123; stack.offerFirst(root.right); &#125; &#125; while (!temp.isEmpty()) &#123; System.out.println(temp.pollFirst().value); &#125;&#125; What is the drawback of Method 1 if we print the nodes on the fly? Need to store everything in memory before we can get the whole post order traversal sequence. Method 2: The problem is, we need to traverse both left and right subtrees first, then we can eliminate the root from the stack. We need a mechanism to know, when we finished visiting all subtrees' nodes. image-20200123213157747 What we need to know? The Direction! we are visiting down? or returning from left? or returning from right? The root is the top element in the stack Maintain a previous Node, to record the previous visiting node on the traversing path, so that we know what the direction we are taking now and what is the direction we are taking next. root = stack.top if previous is null -&gt; going down (left subtree has priority) (初始情况) if previous is current's parent, -&gt; going down(left subtree has priority) if previous == current.left, -&gt; left subtree finished, going current.right if previous == current.right, -&gt; right subtree finished, pop current, going up 123456789101112131415161718192021222324252627282930313233343536public void postOrder(TreeNode root) &#123; // inital check if (root == null) &#123; return; &#125; // local variables Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); TreeNode prev = null; stack.offerFirst(root); while (!stack.isEmpty()) &#123; TreeNode current = stack.peekFirst(); // going down if (prev == null || current == prev.left || current = prev.right) &#123; if (current.left != null) &#123; stack.offerFirst(current.left); &#125; else if (current.right != null) &#123; stack.offerFrist(current.right); &#125; else &#123; System.out.println(current.value); stack.pollFirst(); &#125; &#125; else if (prev == current.left) &#123; // from left subtree if (current.right != null) &#123; stack.offerFirst(current.right); &#125; else &#123; System.out.println(current.value); stack.pollFirst(); &#125; &#125; else &#123; // from right subtree System.out.println(current.value); stack.pollFirst(); &#125; prev = current; &#125; &#125; This solution is important because this is the closest imitation of how actually the recursion is done in STACK, and it can be used as a general framework to iteratively do pre-order and in-order traversal as well. If you look closely, the recursion is actually a DFS procedure on the binary tree. pre-order, in-order, post-order are following the same DFS procedure, and the only difference is when you want to print the node. Map &amp; Set &amp; Hash Set A collection that can not contain duplicate elements. The Java platform contains three general-purpose Set implementations: HashSet, TreeSet, and LinkedHashSet. HashSet: which stores its elements in a hashtable, is the best-performing implementation; however it makes no guarantee concerning the order of iteration TreeSet: which stores its elements in a red-black tree(balanced binary search tree), orders its elements based on their values LinkedHashSet: it is a HashSet and also it is a LinkedList, it maintains the order when each of the elements is inserted into the HashSet. Map A collection that maps keys to values. A Map cannot contain duplicate keys; each key can map to one value. A collection that stores &lt;key, value&gt; pairs, such that no duplicate keys are allowed. The Java platform contains three general-purpose Map implementations: HashMap, TreeMap, and LinkedHashMap. HashMap Common API http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html V put(K key, V value) V get(K key) V remove(K key) boolean containsKey(K key) Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() - get the set view of all the entries in the hashmap Set&lt; K &gt; keySet() - get the set view of all the keys in the hashmap Collection&lt; V &gt; values() - get the collection view of all the values in the hashmap boolean containsValue(V value) - O(n) void clear() int size() boolean isEmpty() image-20200125192204047 1234567891011121314151617181920Map&lt;String, Integer&gt; employerNumbers = new HashMap&lt;&gt;();employerNumbers.put("yahoo", 1);System.out.println(employerNumbers); // &#123;yahoo=1&#125;employerNumbers.put("google", 2);System.out.println(employerNumbers); // &#123;yahoo=1, google=2&#125;Integer yc = employerNumbers.get("yahoo"); // yc = 1yc = employerNumbers.put("yahoo", 5); // yc is the previous value for key "yahoo"System.out.println(employerNumbers); // &#123;yahoo=5, google=2&#125;System.out.println(yc); // yc = 1yc = employerNumbers.get("yahoo"); // yc = 5Integer fc = employerNumbers.get("facebook"); // fc = null// if the key is not in the map, get(key) will return nullboolean fe = employerNumbers.containsKey("facebook"); // fe = falseSystem.out.println(fc); // nullSystem.out.println(fe); // falsefc = employerNumbers.remove("facebook");System.out.println(fc); // nullInteger gc = employerNumbers.remove("google");System.out.println(gc); // 2System.out.println(employerNumbers); // &#123;yahoo=5&#125; HashMap vs. Hashtable Similar to Vector vs. ArrayList Vector, Hashtable exist from Java 1.0 ArrayList, HashMap introduced from Java 5 Hashtable not allow null key, but HashMap allow one null key. Vector, Hashtable operations are synchronized (thread safe), introduce a lot of performance penalty We do not use Hashtable anymore. A Hashtable implementation. A table of buckets(an array of buckets), using the array index to denote each bucket. For each &lt;key, value&gt;, it goes to one of the buckets, the bucket index is determined by a hash function applied on key and the size of array. image-20200125195818722 Collision Control Collision - two keys mapped to the same bucket Separate Chaining(Close Addressing) - the element of each of the buckets is actually a single linked list. If different Keys are determined to use the same bucket, they will be chained in the list. image-20200125200213475 What are the elements in the buckets? Singly Linked List, each node contains one &lt;key, value&gt; pair 12345class Entry&lt;K, V&gt; &#123; K key; V value; Entry&lt;K, V&gt; next;&#125; https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html HashMap operations put(key, value) int hash = hash(key) -- hash int index = hash % table_size -- index search for the list resides in the bucket to see if the key already exists if not find the same key already existed, add a new Entry node to the list if find an Entry with the same key, update the value of that Entry get(key) int hash = hash(key) -- hash int index = hash % table_size -- index search for the list resides in the bucket to see if the key already exists HashMap can only has one null key, it is always mapped to bucket 0. Get into a little details about HashMap Implementation: array of entries each entry is actually a singly linked list (handle collision) contains the &lt;key, value&gt; pair Define the class for each entry: 123456789101112131415161718192021class Entry&lt;K, V&gt; &#123; final K key; V value; Entry&lt;K, V&gt; next; Entry(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public void setValue(V value) &#123; this.value = value; &#125;&#125; maintain an array of entries Entry&lt;K, V&gt;[] array To get(K key), put(K key, V value), remove(K key), we follow the steps hash(key) to hash# hash# to entry index in the array from the corresponding singly linked list, iterate all of the nodes to find if the same key exists. hash(key) to get the hash# 12345678private int hash(K key) &#123; // return the hash# of the key if (key == null) &#123; return 0; &#125; int hashNumber = key.hashCode(); // postprocessing to make the hashNumber non-negative.&#125; from the hash#, mapped to the entry index. 1234int getIndex(int hashNumber) &#123; // return the corrsponding index of array. return hashNumber % array.length;&#125; When iterate the corresponding entry for the given key, which is actually a singly linked list, we need compare each of the entry in the list, if the key is the same as the key we want, then it is the entry we want to find. 1234567Entry&lt;K, V&gt; cur = array[index];while (cur != null) &#123; K curKey = cur.getKey(); if (curKey is the same as given key) &#123; ... &#125;&#125; Two Questions Here: &quot;HashMap get(key), put(key, value), remove(key) is O(1)&quot;, is it always true? What is the major factor affecting the time complexity? hash(key) -&gt; key.hashCode() When we need to know if a key is already in the HashMap, we need to find its bucket, then traverse the linked list in that bucket to see if there is a same key already existed. how do we define &quot;the same key&quot;? key.equals(anotherKey) Very Important: HashMap use key.hashCode() to determine the entry index for the key key.equals() to determine whether two keys are the same keys. ==, equals(), hashCode() == determine if two primitive type has the same value. determine if two reference are pointed to the same object. equals(), hashCode() defined in Object class, Object is the root class for any Java class any Java class implicitly extends Object class, so if in the subclass these two methods are not overridden, it inherits what it defines in Object class. the default implementation of equals() is to check if the two references are pointed to the same object &quot;==&quot;. the default implementation of hashCode() returns a &quot;unique hash value&quot; for the object based on its memory address. 123456789101112class Object &#123; public boolean equals(Object obj) &#123; return this == obj; &#125;public int hashCode() &#123; // here it returns the object's hash value(based on its memory address) // it is unique for each object. &#125; public String toString() &#123; &#125;&#125; sometimes we do not want to compare the reference ... we want to compare the object's content. Example: (from an existing class) 1234567// s1 and s2 are different String objectsString s1 = "abc";String s2 = new String("abc");// this will return false, "==" always compare if they are the same objects1 == s2;// this will return true, equals() for String class actually checks the "value"s1.equals(s2); Why s1.equals(s2) == true ? in String class, the equals() method is overridden: 123456789101112131415161718192021class String &#123; char[] array; int offset; int length; @Override public boolean equals(Object obj) &#123; if (obj == this) return true; if (!(obj instanceof String)) return false; String another = (String) obj; // check each of the characters of the two String object if they are the same if (this.length != another.length) return false; for (int i = 0; i &lt; this.length; i++) &#123; if (this.array[this.offset + i] ! = another.array[another.offset + i] &#123; return false; &#125; &#125; // return true if they match return true; &#125;&#125; Example(our own class): class has to override equals(), hashCode() if you want to have a different meaning than comparing the references. 123456789101112131415// representing a (x, y) coordinate on the grid.class Coordinate &#123; public int x; public int y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;Coordinate one = new Coordinate(0, 0);Coordinate another = new Coordinate(0, 0);one == another; // falseone.equals(another); // false 12345678910111213141516171819202122232425262728293031public class Coordinate &#123; public int x; public int y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; if (!(obj instanceof Coordinate)) &#123; return false; &#125; Coordinate another = (Coordinate) obj; return this.x == another.x &amp;&amp; this.y == another.y; &#125; @Override public int hashCode() &#123; return x * 101 + y; &#125;&#125;Coordinate one = new Coordinate(0, 0);Coordinate another = new Coordinate(0, 0);one == another; // falseone.equals(another); // true What about hashCode() ? Remember, in Hashmap, key.hashCode() method determines which entry the key will go to, we need to guarantee the same keys always go to the same entry. (&quot;yahoo&quot;(1), 2) -- index = 1 put(&quot;yahoo&quot;(2), 5), -&gt; &quot;yahoo&quot;(2).hashCode() -- index, In Java, There is a contract between equals() and hashCode(), the developers need to maintain: If one.equals(two), it is a must that one.hashCode() == two.hashCode() If one.hashCode() == two.hashCode(), it is not necessary one.equals(two) When you want to override equals(), please definitely override hashCode() as well Only by doing this, you can make sure the HashMap will still work for the key type. Example: not override equals(), hashCode() 1234567891011121314151617181920212223242526public class Coordinate &#123; public int x; public int y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return "(" + x + "," + y + ")"; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Map&lt;Coordinate, Integer&gt; map = new HashMap&lt;&gt;(); Coordinate c1 = new Coordinate(1,2); map.put(c1, 5); Coordinate c2 = new Coordinate(1,2); map.put(c2, 6); System.out.println(map); &#125;&#125;// &#123;(1,2)=5, (1,2)=6&#125; override equals(), override hashCode() 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Coordinate &#123; public int x; public int y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return "(" + x + "," + y + ")"; &#125; @Override public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; if (!(obj instanceof Coordinate)) &#123; return false; &#125; Coordinate another = (Coordinate) obj; return this.x == another.x &amp;&amp; this.y == another.y; &#125; @Override public int hashCode() &#123; return x * 101 + y; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Map&lt;Coordinate, Integer&gt; map = new HashMap&lt;&gt;(); Coordinate c1 = new Coordinate(1,2); map.put(c1, 5); Coordinate c2 = new Coordinate(1,2); map.put(c2, 6); System.out.println(map); &#125;&#125;// &#123;(1,2)=6&#125; hashCode() is VERY important! The performance of HashMap solely depends on how good the hashCode() is. bad hashCode() can lead to linear time complexity in extreme case, for example, if all the keys has the same hash number returned by .hashCode(). easy, fast, efficient minimize collision, as evenly distributed as possible Common hashCode() implementation 123456789101112131415class Combo &#123; int a; B b; C c; public Combo(int a, B b, C c) &#123; this.a = a; this.b = b; this.c = c; &#125; @Override public int hashCode() &#123; return a * 31 * 31 + b.hashCode() * 31 + c.hashCode(); &#125;&#125; image-20200126142048373 一般直接采取自动生成的方式 Rehashing, load factor Rehashing is needed when there are too many &lt;key, value&gt; pairs maintained in the hashmap, -&gt; too many collisions. expand the array to a larger one and move all the &lt;key, value&gt; pairs to the new array (in HashMap by default, the array size is doubled each time.) Rehashing is global wise - meaning all the &lt;key, value&gt; pairs need to participate. load factor to control when rehashing is needed, maintain the ratio of number of &lt;key, value&gt; pairs / number of buckets default 0.75 when the the ratio exceeds the limit, rehashing will happen. HashSet It is backed up by a HashMap instance. Only care about the Key here. Common API https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html boolean add(E e) boolean remove(Object o) boolean contains(Object o) void clear() int size() boolean isEmpty() 1234567891011121314151617class HashSet&lt;K&gt; &#123; private HashMap&lt;K, Object&gt; map; // special object used for all the existing keys private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;K, Object&gt;(); &#125; public boolean contains(K key) &#123; return map.containsKey(key); &#125; public boolean add(K key) &#123; return map.put(key, PRESENT) == null; &#125; ...&#125; HashMap Implementation, Arrays, Collections Review About HashMap: where are equals() and hashCode() from? the difference between &quot;==&quot; and equals() The contract between equals() and hashCode() If o1.equals(o2) = true, then you have to guarantee o1.hashCode() == o2.hashCode() If o1.hashCode() == o2.hashCode(), it is not necessary o1.equals(o2) The performance of HashMap is controlled by hashCode() If hashCode() return the same int value for all the objects, what will happen? It will be transferred to a single linked list. HashMap Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222import java.util.Arrays;/** * A hashtable implementation of map, demonstration purpose, generic type is provided * * supported operations: * size() * isEmpty() * clear() * put(K key, V value) * get(K key) * containsKey(K key) * containsValue(V value) // check if the desired value is in the map. O(n) * remove(K key) */public class MyHashMap&lt;K, V&gt; &#123; // Node is a static class of MyHashMap, since it is: // very closely bonded to MyHashMap class. // we probably need to access this class outside from MyHashMap class. public static class Node&lt;K, V&gt; &#123; final K key; V value; Node&lt;K, V&gt; next; Node(K key, V value) &#123; this.key = key; this.value = value; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public void setValue(V value) &#123; this.value = value; &#125; &#125; // static final variable are global constants public static final int DEFAULT_CAPACIT = 16; public static final float DEFULT_LOAD_FACTOR = 0.75f; private Node&lt;K, V&gt;[] array; private int size; // how many key-value pairs are actually stored in the HashMap private float loadFactor; // determine when to rehash. public MyHashMap() &#123; this(DEFAULT_CAPACIT, DEFULT_LOAD_FACTOR); &#125; public MyHashMap(int cap, float loadFactor) &#123; if (cap &lt;= 0) &#123; throw new IllegalArgumentException("cap can not be &lt;= 0"); &#125; this.array = (Node&lt;K, V&gt;[])(new Node[cap]); // create an array and make it usable for generics this.size = 0; this.loadFactor = loadFactor; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; Arrays.fill(this.array, null); size = 0; &#125; // non-negative private int hash(K key) &#123; // 1. null key if (key == null) &#123; return 0; &#125; // 2. 3. hashCode() // int code = key.hashCode(); // return code &gt;= 0 ? code : -code; // int range = [-2^31, 2^31-1] // -Interger.MIN_VALUE = Integer.MIN_VALUE; -&gt; overflow. return key.hashCode() &amp; 0X7FFFFFFF; // guarantee non-negative // 01111111 11111111 11111111 11111111 // Reason: java's % return remainder rather than modulus. The remainder can be negative. &#125; private int getIndex(K key) &#123; return hash(key) % array.length; &#125; private boolean equalsValue(V v1, V v2) &#123; // v1, v2 all possibly to be null if (v1 == null &amp;&amp; v2 == null) &#123; return true; &#125; if (v1 == null || v2 == null) &#123; return false; &#125; return v1.equals(v2); // return v1 == v2 || v1 != null &amp;&amp; v1.equals(v2); &#125; // O(n), traverse the whole array, and traverse each of the linked list in the array. public boolean containsValue(V value) &#123; // special case. if (isEmpty()) &#123; return false; &#125; for (Node&lt;K, V&gt; node : array) &#123; while (node != null) &#123; // check if the value equals() // value, node.getValue() all possible to be null. if (equalsValue(node.value, value)) &#123; return true; &#125; node = node.next; &#125; &#125; return false; &#125; private boolean equalsKey(K k1, K k2) &#123; // k1, k2 all possibly to be null. if (k1 == null &amp;&amp; k2 == null) &#123; return true; &#125; if (k1 == null || k2 == null) &#123; return false; &#125; return k1.equals(k2); // return k1 == k2 || k1 != null &amp;&amp; k1.equals(k2); &#125; public boolean containsKey(K key) &#123; // get the index of the key int index = getIndex(key); Node&lt;K, V&gt; node = array[index]; while (node != null) &#123; // check if the key equals() // key, node.key() all possible to be null. if (equalsKey(node.key, key)) &#123; return true; &#125; node = node.next; &#125; return false; &#125; // if key does not exists in the HashMap, return null. public V get(K key) &#123; int index = getIndex(key); Node&lt;K, V&gt; node = array[index]; while (node != null) &#123; // check if the key equals() // key, node.key() all possible to be null if (equalsKey(node.key, key)) &#123; return node.value; &#125; node = node.next; &#125; return null; &#125; // insert/update // if the key already exists, return the old corresponding value. // if the key not exists, return null. public V put(K key, V value) &#123; int index = getIndex(key); Node&lt;K, V&gt; head = array[index]; Node&lt;K, V&gt; node = head; while (node != null) &#123; // check if the key equals() // key, node.key() all possible to be null if (equalsKey(node.key, key)) &#123; V result = node.value; node.value = value; return result; &#125; node = node.next; &#125; // append the new node before the head and update the new head // insert operation Node&lt;K, V&gt; newNode = new Node(key, value); newNode.next = head; array[index] = newNode; // new head is here. size++; if (needRehashing()) &#123; rehashing(); &#125; return null; &#125; private boolean needRehashing() &#123; // float loadFactor; float ratio = (size + 0.0f) / array.length; return ratio &gt;= loadFactor; &#125; private boolean rehashing() &#123; // new double sized array. // for each node in the old array. // do the put() operation to the new larger array. return true; &#125; // if the key exists, remove the &lt;key,value&gt; from the HashMap, return the value. // if the key not exists, return null. public V remove(K key) &#123; // get index // delete operation on the linked list. // size-- return node; &#125;&#125; What is a &quot;view&quot;? entrySet() -&gt; view public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Specified by: entrySet in interface Map&lt;K,V&gt; Specified by: entrySet in class AbstractMap&lt;K,V&gt; R Returns: a set view of the mappings contained in this map Efficient code accessing the HashMap Which is better？ 1234567891011121314151617181920212223// 1Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();for (char cur: s1.toCharArray()) &#123; if (map.containsKey(cur)) &#123; map.put(cur, map.get(cur) + 1); &#125; else &#123; map.put(cur, 1); &#125;&#125;// 2Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();for (char cur: s1.toCharArray()) &#123; Integer count = map.get(cur); if (count == null) &#123; count = 1; &#125; else &#123; count++; &#125; map.put(cur, count);&#125;// or, in Java 8, use getOrDefault(); 2方法更好，1方法访问了3次，2方法访问了2次。 Which is better? 1234567891011121314151617181920// 1 Set&lt;Character&gt; set = new HashSet&lt;&gt;();for (char cur: s.toCharArray()) &#123; if (!set.contains(cur)) &#123; System.out.println("adding new char to the set"); set.add(cur); &#125; else &#123; return false; &#125;&#125;// 2Set&lt;Character&gt; set = new HashSet&lt;&gt;();for (char cur: s.toCharArray()) &#123; if (set.add(cur)) &#123; System.out.println("adding new char to the set"); &#125; else &#123; return false; &#125;&#125; 2更好，set.add(cur) 同时可以返回信息 How to iterate each of the key, value pairs in a HashMap? 1234HashMap&lt;String, Interger&gt; map = new HashMap&lt;String, Interger&gt;();map.put("google", 1);map.put("yahoo", 2);... Which is better? A : 2 1234567891011// 1for (String key: map.keySet()) &#123; System.out.println(key); System.out.println(map.get(key));&#125;// 2for (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123; System.out.println(entry.getKey()); Syetem.out.println(entry.getValue());&#125; Remove when traverse 1234HashMap&lt;String, Interger&gt; map = new HashMap&lt;String, Interger&gt;();map.put("google", 1);map.put("yahoo", 2);... Which is correct? A : 2 12345678910111213141516// 1for (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123; if (entry.getValue() == 0) &#123; map.remove(entry.getKey()); &#125;&#125;// throw ConcurrentModificationException();// 2Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iter = map.entrySet().iterator();while (iter.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; cur = iter.next(); if (cur.getValue() == 0) &#123; iter.remove(); &#125;&#125; LinkedList -&gt; Tree in HashMap Optimization -&gt; from Java 8 Search() operation Balanced Binary Search Tree -&gt; O(logn) if the LinkedList is very short, we do not do this optimization. require order of the keys, but how? If the key does not implement Comparable, use a system hash function to decide the order. Data Structures vs. Java Implementations Data Structures array new int[5]; array(sorted) -- search O(n) -&gt; O(logn) O(1) random access(get by index) limitation of array, fixed size or resizable. linked list singly doubly O(n) random access(get by index) O(1) append at head/tail queue O(1) offer, poll, peek FIFO Circular Array stack O(1) push, pop, top LIFO deque O(1) insert/remove/peek at both end heap elements are ordered by their values O(1) peek smallest/largest O(logn) offer, poll hashtable elements are not ordered average O(1) search, insert, remove binary tree O(n) search balanced binary search tree elements are ordered O(logn) search, insert, remove O(logn) smallest/largest O(logn) nextLarger(), nextSmaller() Java Implementation array (int[] array, int[m] [n] matrix, ArrayList) linked list singly doubly (LinkedList) queue (LinkedList) stack (LinkedList) deque (LinkedList, ArrayDeque) heap (PriorityQueue) hashtable (HashMap, HashSet) Balanced Binary Search Tree (TreeMap, TreeSet) ...... Extra Reading Java Collection Framework The most most frequently used classes and APls during practices/interviews. The representation classes of data structures(called collections/containers). Collections Framework is available from Java 5 (a set of the classes and interfaces conducting a hierarchical structure, following the strong OO paradigm, containing all the interfaces and implementations) Official tutorial: https://docs.oracle.com/javase/tutorial/collections Interfaces/Classes Hierarchy image-20200127142607895 The arrows means &quot;implements&quot; Collection - Defines what operations should be provided for any classes that is a &quot;Collection&quot;. Any class that is a kind of collection should implement the defined method. http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html int size() boolean isEmpty() boolean add(E element) boolean contains(E element) boolean remove(E element) void clear() List - Defines a group of data structures, that can contain duplicate elements, maintain the order of insertion of the elements and provide the capability of random access by using index. http://docs.oracle.com/javase/7/docs/api/java/util/List.html E get(int index) E remove(int index) E set(int index, E element) ArrayList - A concrete implementation of List by resizable-array. http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html It is a List It is a Collection It implements all the methods specified in List and Collection. List list = new ArrayList(); ArrayList list = new ArrayList(); Queue - Defines a group of data structures, that is designated to 1). hold and buffer elements before processing 2). provide a way of choosing which element buffered is the next one to be processed 3). there are usually two ends of the Queue, and offer always at tail, poll() always at head. http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html boolean add(E element); E element(); E remove(); // group two operations boolean offer(E element); E peek(); E poll(); Deque - Defines a subtype of queue, where it is double ended. (FIFO &amp; LIFO are both provided) http://docs.oracle.com/javase/7/docs/api/java/uti/Deque.html boolean offerFirst(E element); boolean offerLast(E element); E pollFirst(); E pollLast(); E peekFirst(); E peekLast(); LinkedList - A List implementation that backed by a doubly linked list. It also can be used as queue/deque/stack. http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html It is a List lt is a Queue It is a Deque It is a Collection It implements all the methods specified in Collection, List, Queue, Deque. PriorityQueue - Defines a special implementation of queue, where it is using priority to determine which element is the next to process(using order). http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html It implements all the methods specified in Collection, Queue. Set - Defines a group of data structures, that contains no duplicate elements. http://docs.oracle.com/javase/7/docs/api/java/util/Set.html HashSet - A concrete implementation of Set using hashtable. http://docs.oracle.com/javase/7/docs/api/java/uti/HashSet.html It is a Set It is a Collection It implements all the methods specified in Set and Collection. SortedSet - Define a subtype of Set, that contains no duplicate elements, and the elements are sorted. It is a subtype of Set. http://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html E first(); // smallest one E last(); // largest one SortedSet headSet(E toElement); // all the elements smaller than toElement SortedSet tailSet(E fromElement); // all the elements larger than fromElement ... TreeSet - A concrete implementation of SortedSet using red-black tree. http://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html It is a SortedSet It is a Set : It is a Collection It implements all the methods specified in SortedSet, Set and Collection. Similar to Map, SortedMap, HashMap and TreeMap: http://docs.oracle.com/javase/7/docs/api/java/util/Map.html http://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html http://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html About Arrays and Collections They are the placeholders of a set of utility methods for manipulating arrays and collections objects. They are NOT the class for array and Collection All the methods in Arrays/Collections are static methods, so there is no need to create Arrays/Collections object to utilize them Arrays http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html Arrays.sort(int[] array) int[] array = new int[] {3, 2, 1}; Arrays.sort(array); // array = {1, 2, 3} Arrays.sort(T[], Comparator comparator) use the order defined in the comparator to sort the array. 123456789101112131415161718 class Cell &#123; int x; int y; int value;&#125; class CellComparator implements Comparator&lt;Cell&gt; &#123; @Override public int compare(Cell c1, Cell c2) &#123; if (c1.value == c2.value) &#123; return 0; &#125; return c1.value &lt; c2.value ? -1 : 1; &#125; &#125; Cell[] cells = ...; Arrays.sort(cells, new CellComparator()); Arrays.sort(int[] array); -&gt; quicksort Arrays.sort(Integer[] array); -&gt; optimized mergesort quicksort - average fastest comparison based sorting algorithm average time O(nlogn), space O(logn) worst time O(n^2) space O(n) not stable mergesort - guaranteed O(nlogn) time, O(n) space stable heapsort - O(nlogn) time, O(1) space {1, 4, 3, 2, 5} Stable sort: the order of entries with equal keys will be preserved. Example: Sort student on score first, then gender. Two male student with score 90 and 80 will preserve their order after the sort on gender. Arrays.asList(T... a) - convert an array to a List Returns a fixed-size list backed by the specified array. (Changes to the returned list &quot;write through&quot; to the array.) 12345678List&lt;Integer&gt; list = Arays.asList(1, 2, 3);//list is a List of [1, 2, 3] (Integer[])list.set(0, 4);//list is [4, 2, 3]list.add(5);// throw UnsupportedOperationException - fixed-sized Arrays.copyOf(original, int newLength) 12345int[] array = new int[] &#123;1, 2, 3&#125;;int[] copy = Arrays.copyOf(array, 1);// copy = &#123;1&#125;copy = Arrays.copyOf(array, 5);// copy= &#123;1, 2, 3, 0, 0&#125;, padding default values at the end Arrays.fill(original, value) 123int[] array = new int[] &#123;1, 2, 3&#125;;Arrays.fill(array, 1);// array = &#123;1, 1, 1&#125; Arrays.toString(int[] array), Arrays.deepToString(int[] [] matrix) 1234567int[] array = new int[] &#123;1, 2, 3&#125;;String s = Arrays.toString(array);// s = "[1, 2, 3]";int[][] matrix = new int[] &#123;&#123;1, 2&#125;, &#123;1, 2&#125;&#125;;String t = Arrays.deepToString(matrix);// t = "[[1, 2], [1, 2]]" Arrays.binarySearch(original, value) 12345int[] array = new int[] &#123;3, 2, 1&#125;;Arrays.sort(array);// the array must be guaranteed to be sorted before using binarySearchint i = Arrays.binarySearch(array, 2);// i = 1 Collections http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html Collections.sort(List list), Collections.sort(List list, Comparator comparator) Collections.binarySearch(List list) Collections.swap(List list, int i, int j) Collections.fill(List list, T value) Collections.reverse(List list) Collections.reverseOrder() : reverse the natural order defined by a class implementing Comparable interface // You can use Collections.reverseOrder() this way. PriorityQueue maxHeap = new PriorityQueue(11, Collections.reverseOrder()); Convert List to array(or, Collection to array) 12345678910111213interface Collection&lt;T&gt; &#123; ... Object[] toArray() T[] toArray(T[] array) ...&#125;interface List&lt;T&gt; implements Collection&lt;T&gt; &#123; &#125;List&lt;String&gt; list = new ArrayList&lt;String&gt;();Integer[] array = list.toArray(new Integer[list.size()]); in Java - The elements in the generic Collection can not be primitive type. There is no List, List ... etc. List to int[] array ? There is no existing utility / method in Java plain API, in another way, you have to write your own method to do this. Bit Representation 123456789101112public class Bit &#123; // print binary representation of a int value. public static void printBinary(int value) &#123; System.out.println(value + ":"); StringBuilder builder = new StringBuilder(); for (int shift = 31; shift &gt;= 0; shift--) &#123; builder.append((value &gt;&gt;&gt; shift) &amp; 1); &#125; System.out.println(builder.toString()); System.out.println(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Main &#123; public static void main(String[] args) &#123; // 0 int a = 0; Bit.printBinary(a); // positive number a = 5; Bit.printBinary(a); // negative number a = -5; Bit.printBinary(a); a = Integer.MIN_VALUE; Bit.printBinary(a); a = Integer.MAX_VALUE; Bit.printBinary(a); a = -1; Bit.printBinary(a); // signed shift - leftmost bit depends on previous leftmost bit int b = a &gt;&gt; 5; Bit.printBinary(b); // unsigned shift - leftmost bit "0" b = a &gt;&gt;&gt; 5; Bit.printBinary(b); &#125;&#125; &quot;&gt;&gt;&gt;&quot; vs. &quot;&gt;&gt;&quot; signed shift &quot;&gt;&gt;&quot; - arithmetical The leftmost position after signed shift depends on sign extension(the most significant bit) unsigned shift &quot;&gt;&gt;&gt;&quot; - logical The signed right shift operator &quot;&gt;&gt;&gt;&quot; shifts a zero into the leftmost position ![image-20200127204304752](SDE实践/image-20200127204304752.png) Note: There is no &quot;unsigned int&quot; in Java, but there is unsigned right shift. two view of int: 32 bits, each of which is either 0 or 1 arithmetic number http://stackoverflow.com/questions/1023373/findbugs-warning-integer-shift-by-32-what-does-it-mean Autoboxing and Unboxing Primitive type vs. Wrapper class int: Integer long: Long char: Character double: Double boolean: Boolean ...... A wrapper class is just a wrapper of the corresponding primitive type, the Object representation of primitive type values. Similar to String, all the wrapper class objects are IMMUTABLE - internal values can not be changed after initialization. It can help: Generic type can not be primitive type, List ; there can not be List It can help provide useful functionalities and contracts (json serializer: obj -&gt; json) How do you represent a &quot;not existed&quot; int value? &quot;null&quot; Prefer primitive types to wrapper classes. 1234567891011121314151617181920212223// example:class Integer implements Comparable&lt;Integer&gt; &#123; private final int value; // wrap the primitive type value inside. public Integer(int value) &#123; this.value = value; &#125; public int intValue() &#123; return value; &#125; public Integer plus(Integer another) &#123; return Integer.valueOf(value + another.intValue()); &#125; @Override public int compareTo(Integer another) &#123; if (value == another.value) &#123; return 0; &#125; return value &lt; another ? -1 : 1; &#125;&#125; autoboxing Autoboxing is the automatic conversion that the Java compiler makes between the primitive types and their corresponding object wrapper classes. For example, converting an int to an Integer, a double to a Double, and so on. 12345List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();for (int i = 0; i &lt; 50; i++) &#123; integerList.add(i); // ==&gt; integerList.add(Integer.valueOf(i));&#125; unboxing Unboxing is the reverse operation of autoboxing. 12Integer a = 4; // autoboxing =&gt; Integer a = Integer.valueOf(4);a += 4; What happened when Integer++? Integer is immutable, the int value of the Integer object can never change 123456789// a++:int temp = a.intValue();temp++;a = Integer.valueOf(temp); // a is pointing to another Integer object.// a += 4;int temp = a.intValue();temp += 4;a = Integer.valueOf(temp); // a is pointing to another Integer object. More Examples: +, -, *, /, &gt;, &lt;, &gt;=, &lt;= ... only applied to primitive type. 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Integer a = 1115; // autoboxing int b = 5; // primitive System.out.println(a &gt; b); // unboxing. =&gt; a.intValue() &gt; b false System.out.println(a + 2); System.out.println(a * 3); System.out.println(a == b); // unboxing, true Integer c = 1115; System.out.println(a &gt; c); // unboxing =&gt; a.intValue() &gt; c.intValue() false System.out.println(a &gt;= c); // unboxing =&gt; a.intValue() &gt; c.intValue() true System.out.println(a == c); // true // == both operand can be Object type and it is comparing if the two references are pointed to the same Object. a = 129; // Integer.valueOf(129); c = 129; // Integer.valueOf(129); System.out.println(a &gt; c); // false System.out.println(a &gt;= c); // true System.out.println(a == c); // false &#125;&#125; Integer class cache the Integer object with value from -128 to 127, so every time an Integer object within this range is needed, it will always return the corresponding object. The unboxing is done only when it is necessary, for example, a &gt; b. Be very careful about using &quot;==&quot; int[] vs. Integer[] They are totally different types, and there is no auto conversion directly between them. Integer[] objArray = new Integer[5]; int[] array = objArray; // compile error. But, Integer[] objArray = new Integer[5]; objArray[0] = 1; // will work. int[] array = new int[5]; Integer a = 5; array[0] = a; // will work. When you implement your own Comparator or override equals(), keep in mind: be very careful if you see &quot;==&quot; on Object type. Bad: 123456789class MyComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer i1, Integer i2) &#123; if (i1 == i2) &#123; // we do not want to check the references. return 0; &#125; return i1 &lt; i2 ? 1 : -1; &#125;&#125; 3 alternative ways: return i1.compareTo(i2); if (i1.equals(i2)) {} if (i1.intValue() == i2.intValue()) {} Bad: It could overflow. 123456class MyComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer i1, Integer i2) &#123; return i1 - i2; &#125;&#125; Good: 1234567891011121314151617181920212223class MyComparator implements Comparator&lt;Integer&gt; &#123; @Override public int compare(Integer i1, Integer i2) &#123; if (i1 &lt; i2) &#123; return -1; &#125; else if (i1 &gt; i2) &#123; return 1; &#125; return 0; &#125;&#125;class MyComparator implements Comparator&lt;Long&gt; &#123; @Override public int compare(Long i1, Long i2) &#123; if (i1 &lt; i2) &#123; return -1; &#125; else if (i1 &gt; i2) &#123; return 1; &#125; return 0; &#125;&#125; String a sequence of characters &quot;abc&quot; in Java, they are objects 1234567891011121314151617class String &#123; private final char[] value; // different String objects can reuse the same char array, // but can start with different offset index. private int offset; // maintains the length of the part in the char array // represented by this String object. private int count; public String() &#123; value = new char[0]; offset = 0; count = 0; &#125; ......&#125;char[] array = &#123;'a', 'b', 'c', 'd'&#125;;offset = 1; count = 2; // array(1, 2); "bc"; creating Strings String literal: a series of characters in your code that is enclosed in double quotes &quot;abc&quot; Whenever it encounters a string literal in your code, the compiler creates a String Object with its value(really?) String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); // true Pooling for String objects There is no need for maintaining several copies of String objects with the same literal, since String objects are immutable. Usually compiler and JVM will optimize for the number of String objects created, it will maintain an intern area in HEAP, for the same String literal it will only has one String object associated. String s1 = &quot;abc&quot;; String s2 = new String(&quot;abc&quot;); // String(String another) // how many Strings are created? System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // true The String objects created with &quot;new&quot; will not use the intern pool; Another Example: String sa = &quot;a&quot;; String sb = &quot;b&quot;; String sab = &quot;a&quot; + &quot;b&quot;; // compile time concat, &quot;ab&quot; // &lt;=&gt; String sab = &quot;ab&quot;; System.out.println(sab == &quot;a&quot; + &quot;b&quot;); // true System.out.println(sab == sa + &quot;b&quot;); // false, sa.concat(&quot;b&quot;); System.out.println(sab == sa + sb); // false, sa.concat(sb); The optimization is at compile time, the literals will be concatenated if possible before getting the String object. Question: how many String objects are created? 12345678for (int i = 0; i &lt; 100; i++) &#123; String s = new String("abc"); // new String(String another)&#125;for (int i = 0; i &lt; 100; i++) &#123; String temp = "abc"; String s = new String(temp);&#125; 100: if &quot;abc&quot; is in the pool 101: if &quot;abc&quot; is not in the pool Constructors - http://oracle.com/javase/7/docs/api/java/lang/String.html String() String(String value) String(char[] array) String(char[] array, int offset, int length) String(StringBuilder builder) Immutable the value of the String object cannot be changed after creation. String s1 = &quot;abc&quot;; String s2 = s1; // this is another String object, the previous object's value is not changed. s2 = &quot;def&quot; System.out.println(s1); // &quot;abc&quot; System.out.println(s2); // &quot;def&quot; String length s1.length() vs. int[] length; Concatenate Strings s1.concat(s2) // again, this will create a new String object rather than change the value of s1 or s2. s1 = &quot;abc&quot; + &quot;def&quot;; // 等价于s1 = &quot;abcdef&quot;, compile time concatenation. s1 = s1 + &quot;def&quot;; // &lt;==&gt; s1.concat(&quot;def&quot;); s1 = 1 + &quot;def&quot;; // String.valueOf(1), (1 -&gt; Integer(1) -&gt; Integer(1).toString()) -&gt; &quot;1&quot; s1 = &quot;id: &quot; + 2 + &quot;isStudent: &quot; + true + 'y'; Interface, Abstract Class, Access Modifier, Exceptions Inheritance Definitions: A class that is derived from another class is called a subclass (also a derived class, extended class, or child class). The class from which the subclass is derived is called a superclass(also a base class or a parent class). 1234567891011121314151617181920212223242526272829303132public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Employee extends Person &#123; private String company; public void setCompany(String company) &#123; this.company = company; &#125; public String getCompany() &#123; return company; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Employee e = new Employee(); e.setCompany("google"); e.setName("elon"); String name = e.getName(); // 依旧可以调用 String company = e.getCompany(); System.out.println(name); System.out.println(company); &#125;&#125; Override vs. Overload Override is when you redefine a method that has been defined in a parent class (using the same signature). Resolved at runtime. Overload is when you define two methods with the same name, in the same class, distinguished by their signatures (different), Resolved at compile time. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class A &#123; public String show(D obj) &#123; return ("A and D"); &#125; public String show(A obj) &#123; return ("A and A"); &#125;&#125;class B extends A &#123; public String show(B obj) &#123; return ("B and B"); &#125; public String show(A obj) &#123; return ("B and A"); &#125;&#125;class C extends B &#123;&#125;class D extends B &#123;&#125;public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125;/*1--A and A2--A and A3--A and D4--B and A5--B and A6--A and D7--B and B8--B and B9--A and D */]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F01%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[作者：小熊一乐 链接：https://zhuanlan.zhihu.com/p/33238451 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.正则表达式基础语法 &quot; ^ &quot; 指出一个字符串的开始 &quot; $ &quot; 指出一个字符串的结束 &quot; &quot; 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符 &quot;^abc&quot; ：匹配所有以 &quot;abc&quot; 开始的字符串 （例如：&quot;abc&quot;，&quot;abccba&quot;） &quot;abc$&quot;：匹配所有以&quot;abc&quot; 结尾的字符串 （例如：&quot;gggabc&quot;，&quot;reddcba&quot;） &quot;^abc$&quot;：匹配开始和结尾都为&quot;abc&quot;的字符串 （例如：&quot;abc&quot;） &quot;abc&quot;：没有任何字符，匹配任何包含&quot;abc&quot;的字符串 （例如：&quot;aaaabccc&quot;，&quot;abc123&quot;） &quot;n&quot;：匹配n &quot;&quot;：匹配换行符 &quot;/&quot;这里是 he / 连在一起写，匹配 &quot; / &quot; 字符 &quot; * &quot; 匹配前面的子表达式零次或多次 &quot; + &quot; 匹配前面的子表达式一次或多次 &quot; ？ &quot; 匹配前面的子表达式零次或一次 &quot;ac*&quot;：匹配字符串其中一个a后面跟着零个或若干个c （例如：&quot;accc&quot;，&quot;abbb&quot;） &quot;ac+&quot;：匹配字符串其中一个a后面跟着至少一个c或者多个 （例如：&quot;ac&quot;，&quot;acccccccc&quot;） &quot;ac?&quot;：匹配字符串其中一个a后面跟着零个或者一个c （例如：&quot;a&quot;，&quot;ac&quot;） &quot;a?c+$&quot;：匹配字符串的末尾有零个或一个a跟着一个或多个c （例如：&quot;ac&quot;，&quot;acccccc&quot;，''c''，&quot;ccccccc&quot;） &quot; {n} &quot; n为非负整数，匹配n次 &quot; {n，} &quot; n为非负整数，匹配至少n次 &quot; {n，m} &quot; n，m为非负整数，最少匹配n次 最多匹配m次 &quot;ab{3}&quot;：表示一个字符串有一个a后面跟随2个b （例如：&quot;abb&quot;，&quot;abbbbb&quot;） &quot;ab{3,}&quot;：表示一个字符串有一个a后面跟随至少2个b （例如：&quot;abb&quot;，&quot;abbb&quot;） &quot;ab{3,6}&quot;：表示一个字符串有一个a后面跟随3到6个b （例如：&quot;abbb&quot;，&quot;abbbb&quot;，&quot;abbbb&quot;） &quot; | &quot; 表示&quot;或&quot; &quot; .&quot; 表示任何字符 &quot;a|b&quot;：表示一个字符串里有 a 或者 b （例如：&quot;a&quot;，&quot;b&quot;，&quot;ab&quot;，&quot;abc&quot;） &quot;a.&quot;：表示一个字符串有一个 a 后面跟着一个任意字符 （例如：&quot;a1&quot;，&quot;a456&quot;，&quot;avv&quot;） 方括号里用&quot;^&quot;表示不希望出现的字符 &quot; [abc]&quot; ：表示字符集合，表示一个字符串有一个&quot;a&quot;或&quot;b&quot;或&quot;c&quot; 等价于 [z|b|c] &quot; [^abc]&quot;： 表示一个字符串中不应该出现abc，即是匹配未包含改集合的任意字符 &quot; [a-z]&quot;： 表示一个字符串中存在一个a和z之间的所有字母 &quot; [0-9]&quot;： 表示一个字符串中存在一个0和9之间的所有数字 &quot; [^a-z]&quot; ：表示一个字符串中不应该出现a到z之间的任意一个字母 &quot;1&quot; ：表示一个字符串中以字母开头 &quot;[0-9]%&quot;：表示一个百分号前有一个的数字； &quot; &quot; 匹配一个数字字符，等价[0-9] &quot; &quot; 匹配一个非数字字符，等价[^0-9] &quot; &quot; 匹配一个换页符，等价0c和 &quot; &quot; 匹配一个换行符。等价于0a和 &quot; &quot; 匹配一个回车符。等价于0d和 &quot; &quot; 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ &quot; &quot; 匹配任何非空白字符。等价于[^ &quot; &quot; 匹配一个制表符。等价于09和 &quot; 匹配一个垂直制表符。等价于0b和 &quot; &quot; 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]” &quot; &quot; 匹配任何非单词字符。等价于“[^A-Za-z0-9_]” 2.正则表达式实战 /2{1,20}$/ 表示字符串全部由数字组成，即是匹配当前字符串是否是由全数字组成 [0-9] 表示字符的范围是0到9 {1,20}表示字符串长度至少为1，最多为20，字符串出现次数的范围 /3{1}([a-zA-Z0-9._]){5,15}$/ 可以用来验证登录名，首字母为字母，长度为至少6最多16 4{1} 表示最开始的第一个首字母为字母 ([a-zA-Z0-9._]){5,15} 这是首字母后面的即是从第二个字母开始要求至少再有5个最多15个由字母数字以及指定特殊字符组成的字符串 /5[3|4|5|8][0-9]$/ 可以用来验证手机号码，首字母为1，长度11，首尾都是数字 6 第一个数字为1 [3|4|5|8] 第二个数字为 3或者4或者5或者8 [0-9] 匹配一个数字范围是0-9，匹配8次，所以至少要有8个数字。加起来就是11个 /^(){6,20}$/ 验证密码 匹配任何非单词字符 等价于“[^A-Za-z0-9_]” (){6,20} 匹配任何非单词字符，最少6个最多20个 3.RegExp 对象的属性和方法 下面我们来研究如何使用 //构造一个正则对象，并填写表达式 var re = new RegExp(&quot;[0-9]&quot;); var re = /[0-9]/; //注意：当使用构造函数（new RegExp）创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 ） test() 方法：正则表达式方法。 test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。 var re = /[0-9]*/; re.test(&quot;abc&quot;) //返回false re.test(&quot;1234&quot;) //返回true 1exec() 方法：一个正则表达式方法。 exec() 方法用于检索字符串中的正则表达式的匹配。 该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 var re = /[0-9]*/; re.exec(&quot;abc&quot;) //返回 null re.exec(&quot;1234&quot;) //返回1234 当然实际中可能比较复杂，这就需要清晰的嵌套了 a-zA-Z↩ 0-9↩ a-zA-Z↩ a-zA-Z↩ 1↩ 1↩]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫基础]]></title>
    <url>%2F2020%2F01%2F12%2F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2020%2F01%2F09%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[实现用户交互 用户交互就是程序等待用户输入数据之后，在执行下一步的程序，我们使用 input 来完成这个操作。 12name = input('请输入姓名:') # 我把输入的内容赋值给name这个变量print(‘你好’ + name) # 当用户输入完成自己的姓名之后就会打印出来 你好XXX Python2 与Python3 的区别 在python3中 input：用户输入任何值，都存成字符串类型 在python2中 input：用户输入什么类型，就存成什么类型 Python2 中的raw_input：等于python3的input 需要注意的是：当需要输入一个数字的时候，考虑到我们会用这个数字做计算，而Python3的input会默认转成str，所有我们需要把用户输入的数据转化成int 12age = input('请输入年龄')age = int(age) # 把字符串age转化成int类型age用于计算]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2020%2F01%2F08%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim Cheat Sheet vim 多行缩进 按v(或V)进入visual状态，选择多行，用&gt;或&lt;缩进或缩出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[基础算法]]></title>
    <url>%2F2020%2F01%2F06%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Binary search Search for a Range Search Insert Position Search a 2D Matrix Search a 2D Matrix II First Bad Version Find Peak Element]]></content>
  </entry>
  <entry>
    <title><![CDATA[【CS224n】01 Word Vectors]]></title>
    <url>%2F2020%2F01%2F01%2F%E3%80%90CS224n%E3%80%9101-Word-Vectors%2F</url>
    <content type="text"><![CDATA[dentational semantics]]></content>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】05 笔记总结]]></title>
    <url>%2F2019%2F12%2F31%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9105-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Noisy Channel Model nlpcamp_l5-01 nlpcamp_l5-02 nlpcamp_l5-03 语言模型 nlpcamp_l5-04 nlpcamp_l5-05 nlpcamp_l5-06 nlpcamp_l5-07 nlpcamp_l5-08 nlpcamp_l5-09 nlpcamp_l5-10 nlpcamp_l5-11 nlpcamp_l5-12 nlpcamp_l5-13 nlpcamp_l5-14 nlpcamp_l5-15 nlpcamp_l5-16 nlpcamp_l5-17 nlpcamp_l5-18 评估语言模型：Perplexity nlpcamp_l5-19 nlpcamp_l5-20 nlpcamp_l5-21 nlpcamp_l5-22 nlpcamp_l5-23 平滑方法 nlpcamp_l5-24 nlpcamp_l5-25 nlpcamp_l5-26 nlpcamp_l5-27 nlpcamp_l5-28 nlpcamp_l5-29 nlpcamp_l5-30 nlpcamp_l5-31 nlpcamp_l5-32]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Python】统计视频总时长]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90Python%E3%80%91%E7%BB%9F%E8%AE%A1%E8%A7%86%E9%A2%91%E6%80%BB%E6%97%B6%E9%95%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import osfrom moviepy.editor import VideoFileClipimport traceback class MovieDirUtil(): def __init__(self,file_dir): self.file_dir = file_dir def get_filesize(self, filename): u""" 获取文件大小（M: 兆） """ file_byte = os.path.getsize(filename) return self.sizeConvert(file_byte) def get_file_times(self, filename): u""" 获取视频时长（s:秒） """ file_time = 0 clip = None try: clip = VideoFileClip(filename) file_time = clip.duration except Exception as e: traceback.print_exc() finally: if clip: clip.close() return file_time def sizeConvert(self, size): # 文件大小单位换算 K, M, G = 1024, 1024 ** 2, 1024 ** 3 if size &gt;= G: return str(size / G) + 'G Bytes' elif size &gt;= M: return str(size / M) + 'M Bytes' elif size &gt;= K: return str(size / K) + 'K Bytes' else: return str(size) + 'Bytes' def timeConvert(self, size): # 时间单位换算 M, H = 60, 60 ** 2 if size &lt; M: return str(size) + u'秒' if size &lt; H: return u'%s分钟%s秒' % (int(size / M), int(size % M)) else: hour = int(size / H) mine = int(size % H / M) second = int(size % H % M) tim_srt = u'%s小时%s分钟%s秒' % (hour, mine, second) return tim_srt def get_all_file(self): u""" 获取目录下下所有的文件 """ file_list = [] for root, dirs, files in os.walk(file_dir): for file in files: # begin #print(os.path.join(root, file)) file_list.append(os.path.join(root, file)) # end return file_list def get_all_file_duration(self): u""" 获取目录下下所有的文件的播放总时长，单位s """ fileList = self.get_all_file() file_duration = 0 for f in fileList: # print(f) print(f, mdu.timeConvert(self.get_file_times(f))) file_duration += self.get_file_times(f) return file_duration if __name__=="__main__": file_dir = u"/Volumes/sed" # 定义目录地址 mdu = MovieDirUtil(file_dir) print("目录里面包含的视频总共时长为：&#123;duration&#125;".format(duration=mdu.timeConvert(mdu.get_all_file_duration())))]]></content>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】04 笔记总结]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9104-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文本的表示 nlpcamp_l4-02 nlpcamp_l4-03 nlpcamp_l4-04 文本的相似度 nlpcamp_l4-05 nlpcamp_l4-06 nlpcamp_l4-07 nlpcamp_l4-08 nlpcamp_l4-09 Tf-idf 文本表示 nlpcamp_l4-10 nlpcamp_l4-11 词向量介绍 nlpcamp_l4-12 nlpcamp_l4-13 nlpcamp_l4-14 nlpcamp_l4-15 nlpcamp_l4-16 nlpcamp_l4-17 nlpcamp_l4-18 nlpcamp_l4-19 生成词向量 nlpcamp_l4-20 nlpcamp_l4-21 nlpcamp_l4-22 nlpcamp_l4-23 nlpcamp_l4-24 nlpcamp_l4-25 问答系统回顾 nlpcamp_l4-26 nlpcamp_l4-27 nlpcamp_l4-28 倒排表 nlpcamp_l4-29]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2019%2F12%2F29%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文是学习Java入门与基础算法（任课教师：林平之）的总结学习笔记。 如果有不会的算法题，请参考题解:smiley: 第二讲 变量，数组和循环(Java基础 I) 变量 ASCII &amp; Unicode编码 字符 对应整数 0 48 A 65 a 97 123456// 小写转大写，避免hard codechar a = 'a';System.out.println((char)(a - 'a' + 'A'));// 或者直接调用写好的函数Character.toUpperCase(a); 数组 Array 数组 用一个变量来表示一组连续的相同类型的变量。 1234567891011// 定义方式1int[] array = new int[] &#123;90, 95, 92, 89, 100, 98&#125;;// 定义方式2int[] array2 = new int[6];array2[0] = 90;array2[1] = 95;array2[2] = 92;array2[3] = 89;array2[4] = 100;array2[5] = 98; 二维数组和多维数组 123456789// 定义方式1int[][] matrix = new int[][] &#123; &#123;1, 4, 7, 10&#125;, &#123;2, 6, 12, 15&#125;, &#123;6, 8, 13, 20&#125;&#125;;// 定义方式2int[][] matrix2 = new int[3][4]; 程序的三大结构 顺序结构 控制结构 循环结构 控制结构 12345678910111213// max number of 3 numbersint a = 10, b = 20, c = 15;int max = a;if (b &gt; max) &#123; max = b;&#125;if (c &gt; max) &#123; max = c;&#125;System.out.println(max); 循环结构 12345678910111213141516// 找第二大的数int[] arr = new int[] &#123;90, 95, 92, 89, 100, 98&#125;;int len = array.length;int max = 0;int sMax = 0;// 1[ ], 2[ ]for (int i = 0; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; sMax = max; max = arr[i]; &#125; else if (sMax &lt; arr[i]) &#123; sMax = arr[i] &#125;&#125;System.out.println(max);System.out.println(sMax); 1234567891011// 遍历二维数组int[][] matrix = new int[][] &#123; &#123;1, 4, 7&#125;, &#123;2, 6&#125;, &#123;6, 8, 13, 20&#125;&#125;;for (int i = 0; i&lt; matrix.length; ++i) &#123; for (int j = 0; j&lt; matrix[i].length; ++j) &#123; System.out.println(matrix[i][j]); &#125;&#125; 12345// loopint[] array = new int[] &#123;1, 2, 4&#125;;for (int num: array) &#123; System.out.println(num);&#125; 第三讲 字符串，函数，类和对象(Java基础 II) String及其常用操作 1234567891011121314151617181920212223242526272829303132333435// 字符串的长度String a = "hello";String b = new String("hello");System.out.println(a.length());// 字符串的遍历// 1for (int i = 0; i &lt; a.length(); ++i) &#123; System.out.println(a.charAt(i));&#125;// 2char[] chars = new char[] &#123;'h', 'e', 'l', 'l', 'o'&#125;;for (char c: a.toCharArray()) &#123; System.out.println(c);&#125;// 字符串的运算:连接String str = "My name is";str += " Guojing"; // str: "My name is Guojing"int age = 18;str = "I am " + age + " years old"; // str: "I am 18 years old"// 字符串 子串的查找indexOf (返回子串作为位置的下标。)String source = "jiuzhang";int index = source.indexOf("zhang"); System.out.println(index);// 字符串的比较(大部分情况都是用方法比较内容的)String a = "hello";String b = new String("hello");String c = "hello";String d = new String("hello");System.out.println(a == b); // false,不是指向同一个对象System.out.println(a.equals(b); // true,同一个内容System.out.println(a == c); // true,指向同一个对象,常量表 System.out.println(b == d); // false,new创建了两个对象 LintCode: Valid Palindrome 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /** * @param s: A string * @return: Whether the string is a valid palindrome */ public boolean isPalindrome(String s) &#123; // write your code here if (s == null || s.length() == 0) &#123; return true; &#125; int left = 0; int right = s.length() - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; !isValid(s.charAt(left))) &#123; left++; &#125; while (left &lt; right &amp;&amp; !isValid(s.charAt(right))) &#123; right--; &#125; if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123; return false; &#125; else &#123; left++; right--; &#125; &#125; return true; &#125; public boolean isValid(char c) &#123; return Character.isLetter(c) || Character.isDigit(c); &#125;&#125; 函数 image-20191228111006457 类和对象 Lecture_3_Java_Basic_II_20170709-23 Lecture_3_Java_Basic_II_20170709-24 Lecture_3_Java_Basic_II_20170709-25 Lecture_3_Java_Basic_II_20170709-26 Lecture_3_Java_Basic_II_20170709-27 Lecture_3_Java_Basic_II_20170709-28 Lecture_3_Java_Basic_II_20170709-29 Lecture_3_Java_Basic_II_20170709-30 Lecture_3_Java_Basic_II_20170709-31 Lecture_3_Java_Basic_II_20170709-32 Lecture_3_Java_Basic_II_20170709-33 Lecture_3_Java_Basic_II_20170709-35 image-20191228135641121 image-20191228135917559 image-20191228135954662 LintCode: Student ID(Design a Student class) Description Implement a class Class with the following attributes and methods: A public attribute students which is an array of Student instances. A constructor with a parameter n, which is the total number of students in this class. The constructor should create n Student instances and initialized with student id from 0 ~ n-1 Example 1234567891011Java: Class cls = new Class(3) cls.students[0]; // should be a student instance with id = 0 cls.students[1]; // should be a student instance with id = 1 cls.students[2]; // should be a student instance with id = 2Python: cls = new Class(3) cls.students[0] # should be a student instance with id = 0 cls.students[1] # should be a student instance with id = 1 cls.students[2] # should be a student instance with id = 2 Solution Java: 123456789101112131415161718class Student &#123; public int id; public Student(int id) &#123; this.id = id; &#125;&#125;public class Class &#123; public Student[] students; // 声明Student类型数组，即创建一个引用 public Class(int n) &#123; this.students = new Student[n]; // 创建Student类型数组，将引用（students）指向此数组 for (int i = 0; i &lt; n; ++i) &#123; students[i] = new Student(i); &#125; &#125;&#125; Python: 12345678910111213141516class Student: def __init__(self, id): self.id = id;class Class: ''' * Declare a constructor with a parameter n which is the total number of * students in the *class*. The constructor should create n Student * instances and initialized with student id from 0 ~ n-1 ''' # write your code here def __init__(self, n): self.students = [] for i in range(n): self.students.append(Student(i)) LintCode: Student Level Description Implement a class Student, including the following attributes and methods: Two public attributes name(string) and score(int). A constructor expect a name as a parameter. A method getLevel to get the level(char) of the student. score – level table: A: score &gt;= 90 B: score &gt;= 80 and &lt; 90 C: score &gt;= 60 and &lt; 80 D: score &lt; 60 Example 12345678910111213Java: Student student = new Student(&quot;Zuck&quot;); student.score = 10; student.getLevel(); // should be &apos;D&apos; student.score = 60; student.getLevel(); // should be &apos;C&apos;Python: student = Student(&quot;Zuck&quot;) student.score = 10 student.getLevel() # should be &apos;D&apos; student.score = 60 student.getLevel() # should be &apos;C&apos; Solution: 123456789101112131415161718192021## Basic Ideas:## Complexity: Time O(1), Space O(1)class Student: ''' * Declare a constructor expect a name as a parameter. ''' # write your code here def __init__(self, name): self.name = name self.score = 0 ''' * Declare a public method `getLevel` to get the level(char) of this student. ''' # write your code here def getLevel(self): if self.score &gt;= 90: return 'A' if self.score&gt;=80 and self.score&lt;90: return 'B' if self.score&gt;=60 and self.score&lt;80: return 'C' return 'D' 推荐阅读 Object-Oriented Design Problems LEETCODE COMMON TEMPLATES 第四讲 Reference LinkedList 引用 &amp; 链表 引用 Reference 对象去哪儿了? 1ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); intList不是对象本身，是对象的引用 new出来的对象，存储在堆空间(heap space)上 堆空间 heap space 栈空间 stack space 注意区别于数据结构的heap &amp; stack 引用的赋值 12Student student1 = new Student(&quot;Jack&quot;);Student student2 = new Student(&quot;Rose&quot;); new出来两个对象 student1和student2是这两个对象的引用 演示对比 int 和 IntegerWrapper Ps: int, double等都是基础类型 IntegerWrapper对象作为函数参数 对比Increment(int) 和 Increment(IntegerWrapper) 12345678910111213141516171819202122232425262728class IntegerWrapper &#123; public int value; public IntegerWrapper(int val) &#123; value = val; &#125; &#125;public class Main &#123; public static void increment(int a) &#123; a++; &#125; public static void increment(IntergerWrapper intW) &#123; intW.value++; // 指向同一个对象，可以修改 &#125; public static void main(String[] args) &#123; int a = 10; IntegerWrapper intW = new IntegerWrapper(10); increment(a); increment(intW); System.out.println("a: " + a); System.out.println("intW.value: " + inW.value); &#125;&#125; image-20191229125632239 12345678910111213141516171819202122232425262728class IntegerWrapper &#123; public int value; public IntegerWrapper(int val) &#123; value = val; &#125;&#125;public class Main &#123; public static void increment(int a) &#123; a++; &#125; public static void increment(IntegerWrapper intW) &#123; intW = new IntegerWrapper(20); // 指向新创建的对象 &#125; public static void main(String[] args) &#123; int a = 10; IntegerWrapper intW = new IntegerWrapper(10); increment(a); increment(intW); System.out.println("a: " + a); System.out.println("intW.value: " + intW.value); &#125;&#125; image-20191229144920273 原因分析： image-20191229145002330 总结 传递引用 修改引用所指向对象的数据，修改引用没有任何效果(举例) 引用的好处与用处 引用也存的是数据，存的是指向这个对象的地址 使得数据更加的整齐 需要传递引用去修改数据 什么是null 空的引用，没有引用任何对象。 1234ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list = null; // list变成了空引用list.add(1); // NullPointerException 引用中的NULL值问题 Student ID问题: http://www.lintcode.com/en/problem/student-id/ Note:构造一个Student的数组，对象数组(非基础类型的数组)new出来后， 每个对象都是NULL 链表 Linked List 什么是数据结构(data structure) ● 数据 ○ 存储数据的功能 ● 结构 ○ 如何组织排列存储的数据 ● 操作 ○ 如何查询，添加，删除维护存在的数据 什么是链表(linked list) 由节点构成的列表 线性的数据结构 1234class ListNode &#123; public int val; public ListNode next;&#125; image-20191229153329531 哨兵节点 不得不提的dummy Node:伟大的哨兵节点: dummyNode -&gt; null 作用(前驱节点的重要性): 使得每一个元素都有前驱节点 (好处：操作一致，程序逻辑更简单，容易找到头结点) Coding:基于ListNode实现一个Linked List LinkedList Class的接口: 读取操作 get(location) // 获取location位置上的node的value 查找操作 contains(val) // 判断链表中是否含有val值的node 插入操作 add(location, val) // 在location的位置上插入一个值为val的node 删除操作 remove(location) // 删除location位置上的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ListNode &#123; public int val; public ListNode next; public ListNode(int value) &#123; this.val = value; &#125;&#125;// Location 0 是dummy的下一个节点public class LinkedList &#123; ListNode dummy; public LinkedList() &#123; dummy = new ListNode(-1); // dummy.next = null; &#125; public int get(int location) &#123; ListNode cur = dummy.next; for (int i = 0; i &lt; location; ++i) &#123; cur = cur.next; &#125; return cur.val; &#125; public boolean contains(int val) &#123; ListNode head = dummy.next; while (head != null) &#123; if (head.val == val) &#123; return true; &#125; head = head.next; &#125; return false; &#125; public void add(int location, int val) &#123; ListNode pre = dummy; for (int i = 0; i &lt; location; ++i) &#123; pre = pre.next; &#125; ListNode node = new ListNode(val); node.next = pre.next; pre.next = node; &#125; public void remove(int location) &#123; ListNode pre = dummy; for (int i = 0; i &lt; location; ++i) &#123; pre = pre.next; &#125; pre.next = pre.next.next; &#125; public void print() &#123; ListNode head = dummy.next; while (head != null) &#123; System.out.println(head.val + "-&gt;"); head = head.next; &#125; System.out.println("null"); &#125;&#125; 时间复杂度对比 操作 ArrayList LinkedList Add/Remove at end O(1) O(1) Add/Remove at begin O(n) O(1) Add/Remove at any where O(n) O(n) Add/Remove at specified place O(n) O(1) Read/Find By position O(1) O(n) Read/Find By target (value) O(n) O(n) 小练习 在排序的链表中插入一个Node 翻转一个链表 删除链表中倒数第N个元素 第五讲 栈和队列 Stack &amp; Queue 栈 Stack 学习目标 implement a stack ○ http://www.lintcode.com/en/problem/implement-stack/ valid parentheses ○ http://www.lintcode.com/en/problem/valid-parentheses/ 什么是栈(stack) 栈是一种后进先出(last in first out，LIFO)的线性数据结构 栈的操作 push pop peek (getTop) isEmpty image-20191230205927164 栈的实现 ArrayList push —&gt; add pop —&gt; remove LinkedList(推荐) ArrayList不适合用来实现栈，动态数组的copy数据操作复杂度较大，remove元素时不会马上削减size，而是要等到一定程度时，而栈是伸缩的一种数据结构，会增长也会减小，在一些特殊情况会频繁的resize，所以不适合用来实现栈。 12345678910111213141516171819202122232425262728293031// ArrayList实现的栈class StackImpArrayList &#123; private List&lt;Integer&gt; array; public StackImpArrayList() &#123; array = new ArrayList&lt;Integer&gt;(); &#125; // Push a new item into the stack public void push(int val) &#123; array.add(val); &#125; // Pop the top of the stack public int pop() &#123; int size = array.size(); return array.remove(size - 1); &#125; // Return the top of the stack public int peek() &#123; int size = array.size(); return array.get(size - 1); &#125; // Check the stack is empty or not. public boolean isEmpty() &#123; return array.isEmpty(); &#125;&#125; pop操作如何实现？ 一般情况下是 dummy -&gt; 20 -&gt;10 -&gt; null dummy.next为栈底，这样pop时复杂度为O(N)， 在这里实现为 dummy -&gt; 10 -&gt;20 -&gt; null dummy.next设为栈顶，这样pop时复杂度为O(1)。 123456789101112131415161718192021222324252627282930313233343536373839// LinkedList实现的栈class Node &#123; public int val; public Node next; public Node(int value) &#123; this.val = value; &#125;&#125;class StackImpListNode &#123; private Node dummy; public StackImpListNode() &#123; dummy = new Node(-1); &#125; public void push(int val) &#123; Node node = new Node(val); node.next = dummy.next; dummy.next = node; &#125; public int pop() &#123; int ele = dummy.next.val; dummy.next = dummy.next.next; return ele; &#125; public int peek() &#123; int ele = dummy.next.val; return ele; &#125; public boolean isEmpty() &#123; return dummy.next == null; &#125;&#125; LintCode: valid parentheses 12345678910111213141516171819202122232425262728293031public class Solution &#123; /** * @param s A string * @return whether the string is a valid parentheses */ public boolean isValidParentheses(String s) &#123; // Write your code here Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(' || c == '[' || c == '&#123;') &#123; stack.push(c); &#125; if (c == ')') &#123; if (stack.isEmpty() || stack.pop() != '(') &#123; return false; &#125; &#125; if (c == ']') &#123; if (stack.isEmpty() || stack.pop() != '[') &#123; return false; &#125; &#125; if (c == '&#125;') &#123; if (stack.isEmpty() || stack.pop() != '&#123;') &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 一般对栈操作前都要先判栈非空 队列(queue) 学习目标 Implement a queue 实现队列 * 通过ArrayList实现queue (不可以) * 通过LinkedList实现queue * 通过自定义的ListNode实现queue 什么是队列(queue) 队列是一种先进先出(first in first out，FIFO)的线性数据结构 队列的操作 enqueue dequeue peek (getHead) isEmpty image-20191231004257760 队列操作的实现细节 基于ListNode的queue image-20191231143239148 Enqueue 插入一个Value-10 1. 创建一个value为10的node 2. 把新创建的Node放入List的尾部 Dequeue 取出队列头部元素的值 image-20191231143517466 得到Head指向的ListNode的Value1 Head往后移动来到下一个ListNode 返回1这个值 isEmpty 判断对列为空 image-20191231143727279 法一：判断Head是否指向NULL 法二：判断Head是否等于Tail 重点：当对列在只有一个元素进行dequeue操作时，因为两个引用进行操作的时候会有不一致的情况，这时一定要手动改变Tail指针的指向，使得两个引用指向一致。 队列的实现 123456789101112131415161718192021222324252627282930313233343536373839class QueueNode &#123; public int val; public QueueNode next; public QueueNode(int value) &#123; val = value; &#125;&#125;public class Queue &#123; private QueueNode dummy, tail; public Queue() &#123; dummy = new QueueNode(-1); tail = dummy; &#125; public void enqueue(int val) &#123; QueueNode node = new QueueNode(val); tail.next = node; tail = node; &#125; // 两个引用进行操作的时候会有不一致的情况 public int dequeue() &#123; int ele = dummy.next.val; dummy.next = dummy.next.next; if (dummy.next == null) &#123; tail = dummy; // reset &#125; return ele; &#125; public int peek() &#123; int ele = dummy.next.val; return ele; &#125;&#125; 队列的应用 Message queue 消息队列 BFS 广度优先搜索 LintCode:Implement Queue by Interface 待做 优先级队列 40. Implement Queue by Two Stacks 955. Implement Queue by Circular Array Implement Queue by Linked List Java集合之List(ArrayList、LinkedList、Vector、Stack) 第六讲 树和递归 Tree &amp; Recursion 树 Tree 由节点(node)组成 每个节点有零个或多个子 节点(child node) 没有父节点的是根节点(root node) 每个非根节点只有一个父节点(parent node) 一棵树中，只有一个root node image-20191231194545850 二叉树 Binary Tree 每个节点最多有两个子节点 两个子节点分别被称为左孩子(left child)和右孩子(right child) 叶子节点：没有孩子节点的节点 子树(sub-tree) 树中的每个节点代表以它为根的一棵树 左孩子所代表的树成为左子树(left sub-tree) 右孩子所代表的树成为右子树(right sub-tree) 树结构举例 文件系统 B+树 数据库的索引-第七节课 字典树，平衡树等 - 高级数据结构 剖析LintCode TreeNode 12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; TreeNode类 left和right分别对应左右子节点 val表示node的值 递归 Recursion 什么是递归 (Recursion)? 数据结构的递归 树就是一种递归的数据结构 算法(程序)的递归 函数自己调用自己 递归三要素 递归的定义 首先这个问题或者数据结构得是递归定义的 递归的出口 什么时候递归终止 递归的拆解 递归不终止的时候，如何分解问题 Coding 打印出一个树的中序遍历 12345678public static void print(TreeNode root) &#123; if (root == null) &#123; return; &#125; print(root.left); System.out.println(root.val + " "); print(root.right);&#125; 学习目标 获取所有叶子节点的和 Get leaf sum 获取树的高度 Get tree height 获取所有root到叶子节点的路径 Get root-to-leaf paths LintCode:Binary Tree Leaf Sum Recursion 获取叶子节点的和 访问一个Node: 如果这个Node是叶子节点，则sum就是他本身 如果这个Node不是叶子节点，则sum等于左子树的叶子节点和 + 右子树之和 image-20191231204721224 123456789101112131415161718public class Solution &#123; /* * @param root: the root of the binary tree * @return: An integer */ public int leafSum(TreeNode root) &#123; // write your code here if(root == null)&#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null)&#123; return root.val; &#125; return leafSum(root.left) + leafSum(root.right); &#125;&#125; LintCode:Maximum Depth of Binary Tree 为什么函数调用了2n + 1次？ 因为每一个节点有左右两个指针，n个节点共有2n个链域，而n个节点只需用n-1个指针就可互连（因为连接n个点只需n-1条直线），所以还剩下2n-(n-1)=n+1个空指针域，n个节点和n+1个空指针域一共为2n+1个，所以函数调用了2n + 1次。 LeetCode:Binary Tree Paths Recursion 获取树中root到leaf的所有路径 &lt;img src=&quot;Java基础/5EF034508409D2F51C9B60FA385B2C63.jpg&quot; &gt; 比如，对于上面这个二叉树，它所有的路径为： 8 -&gt; 3 -&gt; 1 8 -&gt; 2 -&gt; 6 -&gt; 4 8 -&gt; 3 -&gt; 6 -&gt; 7 8 -&gt; 10 -&gt; 14 -&gt; 13 1234567891011121314151617181920class Solution &#123; public void construct_paths(TreeNode root, String path, LinkedList&lt;String&gt; paths) &#123; if (root != null) &#123; path += Integer.toString(root.val); if ((root.left == null) &amp;&amp; (root.right == null)) // 当前节点是叶子节点 paths.add(path); // 把路径加入到答案中 else &#123; path += "-&gt;"; // 当前节点不是叶子节点，继续递归遍历 construct_paths(root.left, path, paths); construct_paths(root.right, path, paths); &#125; &#125; &#125; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; LinkedList&lt;String&gt; paths = new LinkedList(); construct_paths(root, "", paths); return paths; &#125;&#125; LintCode: Identical Binary Tree 12345678910111213141516public class Solution &#123; /** * @param a, b, the root of binary trees. * @return true if they are identical, or false. */ public boolean isIdentical(TreeNode a, TreeNode b) &#123; // Write your code here if (a == null &amp;&amp; b == null) return true; if (a != null &amp;&amp; b != null) &#123; return a.val == b.val &amp;&amp; isIdentical(a.left, b.left) &amp;&amp; isIdentical(a.right, b.right); &#125; return false; &#125;&#125; LintCode 树的遍历问题 Binary Tree Preorder Traversal http://www.lintcode.com/en/problem/binary-tree-preorder-traversal/ Binary Tree Inorder Traversal http://www.lintcode.com/en/problem/binary-tree-inorder-traversal/ Binary Tree Postorder Traversal http://www.lintcode.com/en/problem/binary-tree-postorder-traversal/ 第七讲 二叉搜索树与哈希表 BST Hash table 本节重点 BST (Binary Search Tree)及其常用操作 二分和分治 BST的应用:实现集合 BST的应用:实现索引 Hash Table 及其常见操作 二叉搜索树 Binary Search Tree 学习目标 在BST中插入一个节点 Insert node into BST 在BST中搜索一个值为Value的节点 Search BST 什么是BST (Binary Search Tree) 满足以下性质的binary tree: 对于每个节点，他的左子树的所有节点都比它小 对于每个节点，他的右子树的所有节点都比它大 以上是严格的说法，不允许BST有重复的节点，实际算法中可以允许重复 BST的常用操作 Insert: Time/space complexity O(h) image-20200104160118595 递归实现 12345678910111213141516171819public class Solution &#123; /* * @param root: The root of the binary search tree. * @param node: insert this node into the binary search tree * @return: The root of the new binary search tree. */ public TreeNode insertNode(TreeNode root, TreeNode node) &#123; // write your code here if (root == null) &#123; return node; &#125; if (root.val &lt; node.val) &#123; root.right = insertNode(root.right, node); &#125; else &#123; root.left = insertNode(root.left, node); &#125; return root; &#125;&#125; 非递归实现 1234567891011121314151617181920212223242526272829303132public class Solution &#123; /* * @param root: The root of the binary search tree. * @param node: insert this node into the binary search tree * @return: The root of the new binary search tree. */ public TreeNode insertNode(TreeNode root, TreeNode node) &#123; // write your code here TreeNode father = null; TreeNode cur = root; while (cur != null) &#123; father = cur; if (cur.val &lt; node.val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; if (root == null) &#123; return node; &#125; if (node.val &lt; father.val) &#123; father.left = node; &#125; else &#123; father.right = node; &#125; return root; &#125;&#125; Search/Find: Time/space complexity O(h) h是树的高度 Best case log2n (or logn), worst case n. 递归实现 非递归实现 (while loop) 实战例题 Validate Binary Search Tree http://www.lintcode.com/en/problem/validate-binary-search-tree/ http://www.jiuzhang.com/solutions/validate-binary-search-tree/ 题目：验证一棵二叉树是二叉搜索树 Example: 123456789Input: &#123;2,1,4,#,#,3,5&#125;Output: trueFor the following binary tree: 2 / \ 1 4 / \ 3 5This is a binary search tree. 分析: 什么样的二叉树是二叉搜索树呢? 左子树是二叉搜索树 右子树是二叉搜索树 左子树最大值 &lt; 该节点的值 &lt; 右子树最小值 Tips: 函数需要返回多个值的时候，用一个类封装起来 image-20200105113929654 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */class ResultType &#123; public boolean isBst; public long minValue, maxValue; public ResultType(long minValue, long maxValue, boolean isBst) &#123; this.minValue = minValue; this.maxValue = maxValue; this.isBst = isBst; &#125;&#125;public class Solution &#123; /** * @param root: The root of binary tree. * @return: True if the binary tree is BST, or false */ public boolean isValidBST(TreeNode root) &#123; // write your code here ResultType result = validHelper(root); return result.isBst; &#125; public ResultType validHelper(TreeNode node) &#123; if (node == null) &#123; return new ResultType(Long.MAX_VALUE, Long.MIN_VALUE, true); // 解释如上图所示 &#125; ResultType left = validHelper(node.left); ResultType right = validHelper(node.right); if (!left.isBst || !right.isBst) &#123; return new ResultType(-1, -1, false); &#125; boolean isBst = left.maxValue &lt; node.val &amp;&amp; node.val &lt; right.minValue; return new ResultType( left.minValue, // 返回最小值 right.maxValue, // 返回最大值 isBst); &#125;&#125; 递归与分治法 Recursion &amp; Divide and Conquer 分治法(divide and conquer)步骤 将大问题分成多个独立的小问题 分别解决每个小问题 (小问题和大问题是同一类问题，所以可以用递归算法) 将小问题的解合并，从而得到大问题的解 树类题目算法总结 遍历 Traversal 递归 Recursion 二叉搜索树 Binary Search Tree 哈希表 Hash table 学习目标 用BST实现集合 Implement set using BST 用BST实现检索 Implement index using BST 用Hash table实现检索 Implement index using hash table 什么是集合 Set 集合Set: 存储一些没有重复元素的数据 Java内部有一个Interface Set 基于这个实现的Class有 TreeSet =&gt; 基于Tree实现的Set HashSet =&gt; 基于Hash Table实现的Set 集合 Set Set有的两个方法: add(element) 增加一个元素 contains(element) 集合内是否包含这个元素 基于BST实现的Set add(element) =&gt; 对应BST的Insert操作 contains(element) =&gt; 对应BST的Search操作 检索 Index 简单来说index就是: 映射map 字典 dictionary key-value对 key-value pairs map: key -&gt; value set: value -&gt; value Index在数据库Database中的应用 以下是数据库中的一个表:我们需要查询Jack的年龄 id name / string age / int score / int 1 “Jack” 12 90 2 “Tom” 13 89 3 “Alex” 12 95 4 “Lucy” 11 78 正常情况下，我们需要扫描数据库中这个table内的所有记录，找到其中一条记录name为Jack，然后我们读取出这条记录中的age(全表扫描) 简单的认为时间复杂度 O(n) 建立索引加速查询: 建立 name -&gt; id 的映射: Returns student id given student name. Returns very fast, faster than O(n) 12index.get(“Alex”); // returns 3index.get(“Lucy”); // returns 4 拆分这个Query如下: 找到对应的student id在我们建立的Index中根据student name ‘Alex’ 根据Student id，我们将很容易的读取到这条记录 整个Query的时间将取决于第一步操作。 如何实现索引Index 有两种实现方式: Using BST =&gt; TreeMap Using Hash table =&gt; HashMap 实现Index(map)的3个方法 put(key, value) =&gt; 设置key对应的value get(key) =&gt; 读取key对应的value containsKey(key) =&gt; 判断对应的key是否在map中存在 使用BST实现Index 123456789public class TreeNode &#123; public TreeNode left, right; public int key, value; public TreeNode(int key, int value) &#123; left = right = null; this.key = key; this.value = value; &#125; &#125; Note: 对TreeNode进行扩展，原来我们只存储val一个值 ，现在我们存储key，value一对值，根据key形成BST树 ，这样就可以通过key找到对应的TreeNode从而读取出 value 使用Hash Table实现Index Hash Table的两种实现方式: 开散列: open hashing，也称为拉链法，separate chaining 闭散列: closed hashing，也称为开地址方法，open addressing 开散列: 开辟一个数组 数组的每一个元素是一个链表的头结点的引用 初始状态数组每个元素对应的链表为空链表 image-20200105155803209 开散列: put(key, value) 创建一个ListNode(包含key&amp;Value) 根据hash函数，计算key对应的index下标 把这个ListNode插入到index下标对应的LinkedList中 开散列 put(key, value) =&gt; put(10, 20) 距离hash函数为 h(key) = key % 5 = 0 插入到0对应的LinkedList中 image-20200105160010013 开散列 get(key) =&gt; get(10) 距离hash函数为 h(key) = key % 5 = 0 遍历0对应的LinkedList，找到对应key为10的ListNode，读出Value值 image-20200105160143279 开散列 contains(key) =&gt; containsKey(10) 距离hash函数为 h(key) = key % 5 = 0 遍历0对应的LinkedList，检测这个LinkedList中是否有key为10的Node 闭散列: 开辟一个数组，一个位置只放一个Node(Node包含key&amp;Value) 根据Hash函数h(key)，计算出index下标将这个Node放入这个数组 如果这个位置已经有了元素，则顺序往后查找直到找到一个空位置可以放下 如何使用Java中的HashMap 12345678Map&lt;Integer, Character&gt; mp = new TreeMap&lt;Integer, Character&gt;();Map&lt;Integer, Character&gt; mp2 = new HashMap&lt;Integer, Character&gt;();mp2. put(10, 'c');mp2.put(20, 'd');System.out.println(mp2.get(10));System.out.println(mp2.containsKey(30)); image-20200105160737399 HashMap的使用 实战例题 Count Characters http://www.lintcode.com/en/problem/count-characters/ http://www.jiuzhang.com/solution/count-characters/ 1234567891011121314public class Solution &#123; /* * @param : a string * @return: a hash map */ public Map&lt;Character, Integer&gt; countCharacters(String str) &#123; // Write your code here Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (char c : str.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; return map; &#125;&#125;; Mirror Numbers http://www.lintcode.com/en/problem/mirror-numbers/ http://www.jiuzhang.com/solution/mirror-numbers/ 1234567891011121314151617181920212223242526// 将倒过来能看成数字的数字哈希一下，就能进行转换判断了。public class Solution &#123; /** * @param num: a string * @return: true if a number is strobogrammatic or false */ public boolean isStrobogrammatic(String num) &#123; // write your code here Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); map.put('6', '9'); map.put('9', '6'); map.put('0', '0'); map.put('1', '1'); map.put('8', '8'); int i = 0; int j = num.length() - 1; while(i &lt;= j) &#123; if(!map.containsKey(num.charAt(i)) || map.get(num.charAt(i)) != num.charAt(j)) &#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; BST v.s. Hash table Hash table的时间复杂度 如果是Integer等类型插入，查找和删除操作都是O(1)时间 如果是String类型插入，查找和删除操作都是O(len)时间 Hash Table空间消耗大 Binary Seach Tree 支持有序的数据，排序和范围查找性能优秀(对于balanced BST是O(logn))，空间消耗相对较小 线程不安全 hashmap 线程安全 hashtable]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】03 笔记总结]]></title>
    <url>%2F2019%2F12%2F27%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9103-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview nlpcamp_l3-02 nlpcamp_l3-03 分词 nlpcamp_l3-04 nlpcamp_l3-05 最大匹配算法 正向最大匹配法 分词目标： 在词典中进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 算法流程： 假设词典中最长的单词为 5 个（MAX_LENGTH），那么最大匹配的起始子串字数也为 5 个 扫描字典，测试读入的子串是否在字典中 如果存在，则从输入中删除掉该子串，重新按照规则取子串，重复 1 如果不存在于字典中，则从右向左减少子串长度，重复1 nlpcamp_l3-06 贪心算法：选择当前最优解 DP：选择全局最优解 max-len通常为5~10 可以根据单词长度的不同做一个分析已选择最合适的max-len。 逆向最大匹配法 分词目标： 在词典中进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 在实践中，逆向最大匹配算法性能优于正向最大匹配算法。 算法流程： 假设词典中最长的单词为 5 个（MAX_LENGTH），那么最大匹配的起始子串字数也为 5 个 扫描字典，测试读入的子串是否在字典中 如果存在，则从输入中删除掉该子串，重新按照规则取子串，重复 1 如果不存在于字典中，则从左向右减少子串长度，重复 1 nlpcamp_l3-07 90%情况前向和后向分词结果相同，10%不同。如南京市长江大桥 最大匹配缺点 细分可能更优 局部最优 没有考虑语义(单词-&gt;syntactic-&gt;semantic) nlpcamp_l3-08 考虑语义模型(LM) nlpcamp_l3-09 nlpcamp_l3-10 Unigram Language Model语言模型选择所有分割情况中最好的 通过统计的方式写出每个单词出现的概率 给定一个句子分词后可以用联合概率算出的概率用作评判是否符合语义的标准 nlpcamp_l3-22 计算时取对数防溢出 nlpcamp_l3-21 生成组合太多，算法复杂度过高，解决方法使用维特比算法 维特比算法 nlpcamp_l3-11 nlpcamp_l3-12 伪代码 nlpcamp_l3-20 数学公式 nlpcamp_l3-19 9E038A12ECCE3D003FAA2C06F6B311F9 分词算法总结 nlpcamp_l3-13 拼写错误纠正 nlpcamp_l3-14 两种错误情况： 错别字 不是错别字，不适合 nlpcamp_l3-15 计算编辑距离（DP算法）三种操作： insert delete replace 然后再在编辑距离最小的之中根据上下文，词频选择一个 nlpcamp_l3-16 nlpcamp_l3-17 QQ20191230-164446 QQ20191230-164600 QQ20191230-164649 一个独立的问题 QQ20191230-164912 停用词过滤 QQ20191230-164950 QQ20191230-165228 Stemming操作 QQ20191230-165347 QQ20191230-165503 推荐阅读 分词中的最大匹配算法 DP经典练习题]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】02 笔记总结]]></title>
    <url>%2F2019%2F12%2F26%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9102-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview nlpcamp_l2-01 nlpcamp_l2-02 算法复杂度 这是任何AI工程师必须要深入理解的概念。对于每一个设计出来的算法都需要从这两个方面来分析。 例子1 123456789int a = 0, b = 0; for (i = 0; i &lt; N; i++) &#123; # O(N)+O(N)=2*O(N)=O(N) a = a + rand(); # N*1个操作 = O(N) b = b + rand(); # N*1个操作 = O(N)&#125; for (j = 0; j &lt; N/2; j++) &#123; b = b + rand(); # N/2*1个操作 = 1/2*O(N)=O(N)&#125; 时间复杂度：O(N) 空间复杂度：2个单位的内存空间 = O(1) # constant space complexity 例子2 1234567891011121314int a = 0, i, j;for (i = 0; i &lt; N; i++) &#123; for (j = N; j &gt; i; j--) &#123; a = a + i + j; &#125; &#125; i=0: j=N...1 Ni=1: j=N...2 N-1i=2: j=N...3 N-2i=N-1: j=N 1total = 1+2+3,...+N = N*(N+1)/2 = N*N/2 + N/2 = 1/2*O(N^2) + 1/2*O(N) = O(N^2) + O(N) = O(N^2) 时间复杂度：O(N^2); 空间复杂度:O(1) 例子3 12345678910111213141516int a = 0, i = N; while (i &gt; 0) &#123; a += i; # 1个操作 i /= 2; # 1个操作&#125; N = 40; i=40i=20 2i=10 2i=5 2i=2 2i=1 2i=0 2terminate2*log(N) = 2* O(log N) = O(log N) 例子4 12345678int i, j, k = 0; for (i = n / 2; i &lt;= n; i++) &#123; for (j = 2; j &lt;= n; j = j * 2) &#123; k = k + n / 2; &#125; &#125; O(n*log n) 复杂度总结 我们每当说算法X的效率要高于Y时指的是？ 时间复杂度 X: o(log n) &gt; Y: o(n) o(n log n) &gt; Y: o(n^2) 定理： 如果x的时间复杂度要优于y的时间复杂度，那么，假设存在一个足够大的数M，当 n&gt;M时，我们可以保证X的实际效率要优于Y的实际效率 归并排序 7744FD0FEC67CC6C8B21406ADB3A359F 主定理 nlpcamp_l2-03 nlpcamp_l2-04 nlpcamp_l2-05 nlpcamp_l2-06 斐波那契数 问题 序列为 1, 1, 2, 3, 5, 8, 13, 21, …… 请求出序列的第n个数。 原始解法 12345678# 递推式: T(n) = T(n-2) + T(n-1)def fib(n): if n == 1 or n == 2: result = 1 else: result = fib(n-2) + fib(n-1) return result image-20191227010720857 fibonacci sequence 的递推式不符合主定理的要求 可以通过画出一棵递归树分析出时间复杂度为O(2^n) nlpcamp_l2-13 空间复杂度为O(n) nlpcamp_l2-14 动态规划解法 时间复杂度为O(n) 空间复杂度为O(n) 123456789# Use Dynamic Programmingimport numpy as npdef fib4(n): tmp = np.zeros(n) tmp[0] = 1 tmp[1] = 1 for i in range(2, n): tmp[i] = tmp[i - 1] + tmp[i - 2] return tmp[n - 1] 一点优化，提升空间复杂度至O(1) 123456789# 相当于使用了两个指针def fib2(n): ptr1 = 1 ptr2 = 1 for i in range(2, n): res = ptr1 + ptr2 ptr1 = ptr2 ptr2 = res return res nlpcamp_l2-15 Closed-form 解法 123# 时间复杂度O(1)def fib_cf(n: int) -&gt; int: return 0.4472135954999579 * (1.618033988749895**n - (-0.6180339887498949)**n) P vs NP vs NP Hard vs NP Complete nlpcamp_l2-07 案例：搭建一个智能客服系统 nlpcamp_l2-08 nlpcamp_l2-09 nlpcamp_l2-10 nlpcamp_l2-11 分词(segmentation) 预处理: spell correction stemming / lemmatization stop-word words filtering 同义词 …… 文本 -&gt; 向量 boolean vector(0, 1, 1, ……) count vector(1, 2, ……) tf-idf(0.7, 0.3, 0, ……) word2vec seq2seq 添加Inverted Index(倒排表)降低复杂度 计算相似度(给定2个向量) euclidean distance cosine distance jaccard distance 排序 过滤 返回结果 nlpcamp_l2-16 推荐阅读 时间复杂度 Master's Theorem MIT Ling Ren讲解主定理 edit distance(动态规划) CS Dojo讲解斐波那契数(动态规划) Closed-Form Expression to Calculate n-th Fibonacci Number Calculating Fibonacci Numbers with Matrices and Linear Algebra(回顾mit线代)]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
      <tags>
        <tag>自动问答</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】01 笔记总结]]></title>
    <url>%2F2019%2F12%2F25%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9101-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[banner-top-logo 本文是学习贪心学院NLP自然语言处理集训营2（任课教师：李文哲）的总结学习笔记，对于一部分内容根据个人理解做了升级和优化。 视频总共时长为：119小时8分钟48秒 Logistics nlpcamp_l1-01 nlpcamp_l1-02 nlpcamp_l1-03 nlpcamp_l1-04 nlpcamp_l1-05 nlpcamp_l1-06 nlpcamp_l1-07 nlpcamp_l1-08 NLP定义以及歧义性 nlpcamp_l1-09 nlpcamp_l1-10 nlpcamp_l1-11 nlpcamp_l1-12 nlpcamp_l1-13 nlpcamp_l1-14 nlpcamp_l1-15 nlpcamp_l1-16 实现一个机器翻译系统 nlpcamp_l1-17 nlpcamp_l1-18 传统做法：给定语料库，在其中做统计，语料少的可以用排除法，根据大概的匹配结果返回给用户。 答案：jjat arrat vat mat hilat oloat at-yurp nlpcamp_l1-19 传统翻译系统缺陷： 训练速度慢(使用AI模型) 语法不正确(重点，语法要让人可以理解) 规则统计 语义 上下文 nlpcamp_l1-20 如何保证生成的语句合理通顺？ 步骤：中文分词 -&gt; 逐词翻译 -&gt; 罗列所有可能组合 -&gt; 选择最合适的句子(Language Model) 问题：两步的模型计算量过大，时间复杂度太高(指数级) 解决方案：两个模型同时考虑，维特比算法直接计算出 argmax P(e) * P(c|e) Translation Model + Language Model —&gt; Decoding Algorithm, Viterbi Algorithm(DP) nlpcamp_l1-21 nlpcamp_l1-22 nlpcamp_l1-23 语言模型分类：(计算每一个概率) Unigram Model：独立 Bigram Model：考虑前一个单词 Trigram Model：考虑前两个单词 …… N-gram Model 马尔科夫假设 一点公式推导：使精度可以接受且又容易计算 BF5F2B8FC48F801D851CAE00C695C6E0 nlpcamp_l1-24 中国的机器翻译难度较大，美国的较容易 NLP的经典应用场景 nlpcamp_l1-25 nlpcamp_l1-26 nlpcamp_l1-27 nlpcamp_l1-28 nlpcamp_l1-29 nlpcamp_l1-30 nlpcamp_l1-31 nlpcamp_l1-32 nlpcamp_l1-33 nlpcamp_l1-34 Named-entity recognition (NER) Relation Extraction NLP的关键技术 nlpcamp_l1-35 nlpcamp_l1-36 词性标注（Part-of-Speech tagging 或POS tagging) nlpcamp_l1-37 nlpcamp_l1-38 nlpcamp_l1-39 nlpcamp_l1-40 nlpcamp_l1-41 nlpcamp_l1-42 多去阅读state-of-art paper，了解nlp领域内的最新进展。 看项目中涉及到哪些技术，知道这些技术的实现难度，评估项目可行性 。 https://www.quora.com/What-are-the-major-open-problems-in-natural-language-understanding I will classify the problems in Natural Language Processing into 3 categories : 1. Easy or mostly solved Spam detection Part of Speech Tagging - Example INPUT: Profits soared at Boeing Co., easily topping forecasts on Wall Street, as their CEO Alan Mulally announced first quarter results. OUTPUT: Profits/N soared/V at/P Boeing/N Co./N ,/, easily/ADV topping/V forecasts/ N on/P Wall/N Street/N ,/, as/P their/POSS CEO/N Alan/N Mulally/ N announced/V first/ADJ quarter/N results/N ./. KEY: N = Noun, V = Verb, P = Preposition, Adv = Adverb Named Entity Recognition - Example ​ INPUT: ​ Profits soared at Boeing Co., easily topping forecasts on Wall Street, as ​ their CEO Alan Mulally announced first quarter results. ​ OUTPUT: ​ Profits/NA soared/NA at/NA Boeing/SC Co./CC ,/NA easily/NA topping/ ​ NA forecasts/NA on/NA Wall/SL Street/CL ,/NA as/NA their/NA CEO/NA ​ Alan/SP Mulally/CP announced/NA first/NA quarter/NA results/NA ./NA ​ KEY: NA = No entity, SC = Start Company, CC = Continue Company, SL = Start Location, CL = Continue Location 2. Intermediate or making good progress Sentiment analysis- Example: ​ Best roast chicken in San Francisco! -- Positive ​ The waiter ignored us for 20 minutes. -- Negative Coreference resolution - Example: &quot;Carter told Mubarak he shouldn't run again.&quot; To solve whether &quot;he&quot; is related to &quot;Carter&quot; or &quot;Mubarak&quot;. Word sense disambiguation - Example : ​ I need new batteries for my mouse. - &quot;mouse&quot; is ambiguous here. Parsing - the basic problem of parsing sentences. Machine Translation - translating sentences from one language to another, best example would be Google translate. Information Translation - to take a text as input and represent it in a structured form like a database entries. 3. Hard or still need lot of work Text Summarization - to take input as text document(s) and try to condense them into a summary. Machine dialog system - Example: ​ User - I need a flight from New York to London, arriving at 10 pm ? ​ System - What day are you leaving? ​ User - Tomorrow. ​ System detects the missing information in your sentences.]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
        <tag>NLP技术</tag>
        <tag>NLP场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[presentation]]></title>
    <url>%2F2019%2F06%2F10%2Fassets%2F</url>
    <content type="text"><![CDATA[Student Registration System 五大模块 配置虚拟环境和框架 创建一个项目 使用模板 连接数据库 使用 web forms 和 flask-security 配置Flask框架 创建学生选课系统文件夹，并在其中创建虚拟环境 123mkdir SRScd SRSpython3 -m venv venv 启动虚拟环境 1. venv/bin/activate 在虚拟环境中安装Flask 1pip install Flask 在虚拟环境中安装flask-wtf (用于快速创建表单) 1pip install flask-wtf 在项目文件夹中创建 .flaskenv 12FLASK_ENV=developmentFLASK_APP=main.py 在虚拟环境中安装python-dotenv 用途：可以把所有用到的环境变量写到.env文件里，然后以k，v的方式读取作为环境变量。这样我们的项目迁移到不同的环境时只需要更改一下.env的内容就可以了，代码执行时会自动从.env文件里读取所需要的配置信息 1pip install python-dotenv 退出虚拟环境 1deactivate image-20190524131400912 创建并运行一个简单的Flask应用程序 首先启动虚拟环境，并进入项目文件夹下 创建requirements文件，方便迁移项目 1pip freeze &gt; requirements.txt 如需重新安装库文件 1pip install -r requirements.txt 创建main.py文件 123456from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" 运行 1flask run image-20190524132647750 image-20190524133420073 创建SRS应用程序 核心步骤 在项目文件中创建application文件夹，main程序运行时调用其中的内容，进入application文件夹 创建templates static __init__.py 重构代码，将main程序中的代码转移到init程序中 在项目文件夹下创建config.py 在app文件夹下创建routes.py 创建系统主页 index.html 增加navigation links和routing patterns 核心技术 路由 现代 Web 应用的 URL 十分优雅，易于人们辨识记忆，这一点对于那些面向使用低速网络连接移动设备访问的应用特别有用。如果可以不访问索引页，而是直接访问想要的那个页面，他们多半会笑逐颜开而再度光顾。 如上所见， route() 装饰器把一个函数绑定到对应的 URL 上。 这里是一些基本的例子: 1234567@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos; 12345678910111213141516171819@app.route("/login", methods=['GET','POST'])def login(): if session.get('username'): return redirect(url_for('index')) form = LoginForm() if form.validate_on_submit(): email = form.email.data password = form.password.data user = User.objects(email=email).first() if user and user.get_password(password): flash(f"&#123;user.first_name&#125;, you are successfully logged in!", "success") session['user_id'] = user.user_id session['username'] = user.first_name return redirect("/index") else: flash("Sorry, something went wrong.","danger") return render_template("login.html", title="Login", form=form, login=True ) 构造url 如果 Flask 能匹配 URL，那么 Flask 可以生成它们吗？当然可以。你可以用 url_for()来给指定的函数构造 URL。它接受函数名作为第一个参数，也接受对应 URL 规则的变量部分的命名参数。未知变量部分会添加到 URL 末尾作为查询参数。这里有一些例子: 123456789101112131415161718192021&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route(&apos;/&apos;)... def index(): pass...&gt;&gt;&gt; @app.route(&apos;/login&apos;)... def login(): pass...&gt;&gt;&gt; @app.route(&apos;/user/&lt;username&gt;&apos;)... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():... print url_for(&apos;index&apos;)... print url_for(&apos;login&apos;)... print url_for(&apos;login&apos;, next=&apos;/&apos;)... print url_for(&apos;profile&apos;, username=&apos;John Doe&apos;)...//login/login?next=//user/John%20Doe 1234567891011&lt;header&gt; &lt;nav&gt; &lt;ul class="nav nav-pills"&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('index') &#125;&#125;" class="nav-link &#123;% if index %&#125;active&#123;% endif %&#125;"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('courses') &#125;&#125;" class="nav-link &#123;% if courses %&#125;active&#123;% endif %&#125;"&gt;Classes&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('register') &#125;&#125;" class="nav-link &#123;% if register %&#125;active&#123;% endif %&#125;"&gt;Register&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('login') &#125;&#125;" class="nav-link &#123;% if login %&#125;active&#123;% endif %&#125;"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr style="clear:both"&gt;&lt;/header&gt; jinja2模板 Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML，你确信能在Python的字符串中正确地写出来么？反正我是做不到。 Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户。 这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。 Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等； 包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。 MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。 上面的例子中，Model就是一个dict：{ 'name': 'Michael' } 有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。 image-20190609160447890 使用模板 核心步骤 在templates中创建父模板 layout.html 和一些子模板, child template 都继承自 base template image-20190609162319851 1234567891011121314151617181920&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-12 text-center"&gt; &#123;% for user in users %&#125; &lt;dl&gt; &lt;dt&gt;User ID: &#123;&#123; user.user_id&#125;&#125;&lt;/dt&gt; &lt;dd&gt;Email: &#123;&#123;user.email&#125;&#125;&lt;/dd&gt; &lt;dd&gt;Password: &#123;&#123;user.password&#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &#123;% else %&#125; &lt;h3&gt;No users yet!&lt;/h3&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 将数据传送到视图层 通过request和response对象获取数据 核心技术 get和post请求： get请求： 使用场景： 如果只是对服务器获取数据， 并没有对服务器产生任何影响，那么这时候使用get请求 传参： get请求传参是放在url中，并且是通过?的形式来指定key和value的。 post请求： 使用场景：如果要对服务器产生影响，那么使用post请求。 传参： post请求传参不是放在url中，是通过form data的形式发送给服务器的。 get和post请求获取参数： get请求是通过flask.request.args来获取。 post请求是通过flask.request.form来获取。 post请求在模板中要注意几点： input标签中， 要写那么来表示这个value的key， 方便后台获取。 在写form表单的时候， 要指定method=post, 并且要指定action='/login/' image-20190609201459316 image-20190609201541807 连接数据库 核心步骤 安装MongoDB数据库系统 安装适应Flask框架的Mongo引擎扩展 配置数据库 连接数据库 创建一些数据 创建数据模型 配置 启动 mongodb，默认数据库目录即为 /data/db： 1sudo mongod 安装flask-mongoengine 1sudo pip install flask-mongoengine 配置一个数据库 1MONGODB_SETTINGS = &#123; &apos;db&apos; : &apos;GDUT_Enrollment&apos; &#125; 导包并初始化 1234from flask_mongoengine import MongoEnginedb = MongoEngine()db.init_app(app) image-20190609204941420 12345678910111213class User(db.Document): user_id = db.IntField( unique=True ) first_name = db.StringField( max_length=50 ) last_name = db.StringField( max_length=50 ) email = db.StringField( max_length=30 ) password = db.StringField( max_length=30 )@app.route("/user")def user(): User(user_id=1, first_name="Christian", last_name="Hur", email="christian@uta.com", password="abc1234").save() User(user_id=2, first_name="Mary", last_name="Jane", email="mary.jane@uta.com", password="password123").save() users = User.objects.all() return render_template("user.html", users=users) image-20190609210018628 image-20190609210116679 添加json数据 1mongoimport --jsonArray --db GDUT_Enrollment --collection course /Users/Mac/Downloads/flask记录/courses.json image-20190609211532213 image-20190609211702437 使用 web forms 和 flask-security 1sudo pip install flask-wtf flask-security 核心步骤 安装和配置 flask-wtf flask-security 创建注册和登录页面 处理表单数据和更新数据库 创建课程和选课页面 创建 sessions 和 authentication 核心技术 使用 WTForms 进行表单验证 WTForms 当编写验证客户端提交的多个Form表单时，视图函数中的代码很快将变得冗长和难以阅读，调试和维护也变得难以忍受。通过使用WTForms库，将表单定义为继承于Form的类，使用该类可以验证所有表单，并且可以在模板中自动生成表单对应的HTML元素，定制HTML生成过程，从而实现业务逻辑代码和展示的分离，并使得代码简洁干净、易于维护。 image-20190610000509784 12345678910111213141516171819202122232425262728293031323334 &#123;% extends "layout.html" %&#125; &#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-6 offset-md-3"&gt; &lt;form name="login" action="" method="post" novalidate&gt; &lt;fieldset class="form-group"&gt; &lt;legend&gt;&#123;&#123;title&#125;&#125;&lt;/legend&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;p&gt; &#123;&#123; form.email.label &#125;&#125;&lt;br&gt; &#123;&#123; form.email(size=35) &#125;&#125; &#123;% for error in form.email.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.password.label &#125;&#125;&lt;br&gt; &#123;&#123; form.password(size=15) &#125;&#125; &#123;% for error in form.password.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.submit() &#125;&#125; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 使用 Flask-Security 扩展 支持一般的安全和认证特性 支持数据持久化 使用 Werkzeug库进行密码加密 image-20190610001245573 使用 session 当客户端进行第一次请求时，客户端的HTTP request（cookie为空）到服务端，服务端创建session，视图函数根据form表单填写session，请求结束时，session内容填写入response的cookie中并返回给客户端，客户端的cookie中便保存了用户的数据。 当同一客户端再次请求时， 客户端的HTTP request中cookie已经携带数据，视图函数根据cookie中值做相应操作（如已经携带用户名和密码就可以直接登陆）。 在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。 image-20190610005826683 image-20190610005840485 image-20190610005847712 image-20190610005859756]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Binary Search Defination Given an sorted integer array( - nums), and an integer( - target). Find the any/first/last position of target in nums Return -1 if target does not exist. Template 1234start + 1 &lt; end start + (end - start) / 2 A[mid] ==, &lt;, &gt; A[start] A[end] ? target 好处：防止死循环，防止漏解，题目适用范围广 Example: First position of target 1234567891011121314151617def binarySearch(arr, target): start = 0 end = len(arr) - 1 while (start + 1 &lt; end): mid = start + (end - start) // 2 if arr[mid] == target: end = mid elif arr[mid] &lt; target: start = mid elif arr[mid] &gt; target: end = mid if arr[start] == target: return start if arr[end] == target: return end return -1 ###Exercise classical binary search search for a range 思路：两次二分查找，第一次找第一次出现的位置，第二次找最后一次出现的位置 #### Search Insert Position 思路1: find the first position &gt;= target 思路2: find the last position &lt; target, return +1]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F04%2F09%2FCompiler%2F</url>
    <content type="text"><![CDATA[Compiler notes First Sets Defination \(\text { First }(X)=\left\{t | X \rightarrow^{*} t \alpha\right\} \cup\left\{\varepsilon | X \rightarrow^{*} \varepsilon\right\}\) Algorithm sketch: \(\text { First }(t)=(t)\) \(\varepsilon \in \mathrm{First}(X)\) \(\begin{array}{l}{\text { if } X \rightarrow \varepsilon} \\ {\text { if } X \rightarrow A_{1} \dots A_{n} \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n}\end{array}\) \(\text { First }(\alpha) \subseteq \text { First }(X)\) \(\text { if } X \rightarrow A_{1} \ldots A_{n} \alpha \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n\) Follow Sets Defination: \(\text { Follow }(X)=\left\{t | S \rightarrow^{*} \beta Xt\delta\right\}​\) Intuition \(\begin{array}{c}{\text { If } X \rightarrow A B \text { then First }(B) \subseteq \text { Follow }(A) \text { and }} \ {\text { Follow }(X) \subseteq \text { Follow }(B)}\end{array}\) \(\text { if } B \rightarrow^{*} \varepsilon \text { then Follow }(X) \subseteq \text { Follow }(A)\) \(\text { If } S \text { is the start symbol then } \$ \in \text { Follow }(S)​\) Algorithm sketch: \(\$ \in \text { Follow }(S)\) \(\begin{array}{l}{\text { First }(\beta)-\{\varepsilon\} \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta}\end{array}​\) \(\begin{array}{l}{\text { Follow }(A) \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta \text { where }\varepsilon \in \text { First }(\beta)}\end{array}\) Select Sets Defination: \(\text { Select }(A \rightarrow \alpha)=\left\{t\right\}\) Algorithm sketch: \(\text { For each production } A \rightarrow \alpha \text { in G do: }\) \(\begin{array}{l}{-\text { For each terminal } t \in \text { First }(\alpha) \text { do }} \\ {\quad \cdot \mathrm{T}[A, t]=\alpha}\end{array}\) \(\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha), \text { for each } t \in \text { Follow }(A) \mathrm{do}} \\ {\quad \cdot \mathrm{T}[A,t]=\alpha}\end{array}\) \(\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha) \text { and } \$ \in \text { Follow }(A) \text { do }} \\ {\quad \cdot \mathrm{T}[A, \$]=\alpha}\end{array}\)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lecture 4 (Error and Noise)]]></title>
    <url>%2F2019%2F04%2F03%2FLecture-4-Error-and-Noise%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lecture 3 (The Linear Model I)]]></title>
    <url>%2F2019%2F04%2F01%2FLecture-3-The-Linear-Model-I%2F</url>
    <content type="text"><![CDATA[为了可以尽快上手，将线性模型调整到前面]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈(Monotonic Stack)]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack%2F</url>
    <content type="text"><![CDATA[算法解析 第一种情况 栈底到栈顶是由大到小排列，则使栈顶数弹出的是右边离它最近的比它大的数，新的栈顶数是左边离原栈顶数最近的比它大的数。反之亦然。 第二种情况 栈底到栈顶是由小到大排列，则使栈顶数弹出的是右边离它最近的比它小的数，新的栈顶数是左边离原栈顶数最近的比它小的数。 相关习题 654. Maximum Binary Tree 算法细节：每个数都找到左和右比它大的数，选择其中小的作为父节点，左和右都为空的数则是根节点。 算法正确性（易证）： 构造的是一棵树，而非森林 每个节点最多有两个孩子 84. Largest Rectangle in Histogram 延伸阅读：Jackson Gabbard讲解 12345678910111213141516171819202122class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ stack = [] max_area = 0 index = 0 while index &lt; len(heights): if not stack or heights[stack[-1]] &lt; heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area 85. Maximal Rectangle 总结 单调栈关心的是一维数组上某个数与其周围数的关系。例如寻找距离最近的比它大（或小）的数；在histogram中，前后的bar的高低影响了最终矩形的计算；在最大子矩阵中，把每一行矩阵看做一个直方图。在这些例子中我们可以试图用单调栈来解决。在使用单调栈的时候，想清楚每个元素出栈的意义，什么时候更新index，遇到重复的元素如何处理，栈为空时是什么情况等等。因为每个元素都出栈入栈各一次，所以时间复杂度是O(n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 2 (Is Learning Feasible?)]]></title>
    <url>%2F2019%2F03%2F30%2FLecture-2-Is-Learning-Feasible%2F</url>
    <content type="text"><![CDATA[\( E_{in}\)]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
      <tags>
        <tag>feasible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2019%2F03%2F29%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class AvlTree(object): """ An avl tree. """ def __init__(self): # Root node of the tree. self.node = None self.height = -1 self.balance = 0 def insert(self, key): """ Insert new key into node """ # Create new node n = TreeNode(key) if not self.node: self.node = n self.node.left = AvlTree() self.node.right = AvlTree() elif key &lt; self.node.val: self.node.left.insert(key) elif key &gt; self.node.val: self.node.right.insert(key) self.re_balance() def re_balance(self): """ Re balance tree. After inserting or deleting a node, """ self.update_heights(recursive=False) self.update_balances(False) while self.balance &lt; -1 or self.balance &gt; 1: if self.balance &gt; 1: if self.node.left.balance &lt; 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance &lt; -1: if self.node.right.balance &gt; 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): """ Update tree height """ if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): """ Calculate tree balance factor """ if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): """ Right rotation """ new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): """ Left rotation """ new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root def in_order_traverse(self): """ In-order traversal of the tree """ result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的奇技淫巧]]></title>
    <url>%2F2019%2F03%2F27%2FHexo%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Hexo添加文章时自动打开编辑器 mac下修改文件夹权限： sudo -i进入root模式 chown -R 用户名 /文件夹名 操作步骤： 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 Mac平台的Hexo用户将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new "auto open editor test" 是不是就顺利的自动打开了自动生成的md文件啦~ Hexo添加评论区 参考: Valine leancloud Hexo内嵌pdf文档 安装插件https://github.com/superalsrk/hexo-pdf 修改主题配置文件 123456789# PDF Support# Dependencies: https://github.com/theme-next/theme-next-pdfpdf: enable: true # Default (true) will load PDFObject / PDF.js script on demand. # That is it only render those page which has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject / PDF.js srcipt EVERY PAGE. per_page: true height: 500px 其他选择 &lt;center&gt;&lt;embed src=&quot;/pdf/mou.pdf&quot; width=&quot;850&quot; height=&quot;600&quot;&gt;&lt;/center&gt; &lt;iframe src=&quot;/pdf/mou.pdf&quot; style=&quot;width:850px; height:600px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; Hexo显示数学公式 Hexo博客数学公式显示 MarkDown 插入数学公式实验大集合 Hexo Next主题解决无法显示数学公式 解决block数学公式下有scroll bar的问题 layout/_third-party/math/mathjax.swig下的 123456&lt;style&gt;.MathJax_Display &#123; overflow-x: scroll; overflow-y: hidden;&#125;&lt;/style&gt; 修改为 1234567&lt;style&gt;.MathJax_Display &#123; overflow: auto hidden; overflow-x: hidden; overflow-y: hidden;&#125;&lt;/style&gt; 参考：https://github.com/theme-next/hexo-theme-next/issues/658 Hexo插入图片 Hexo方式post_asset_folder&quot;#&quot; * 根目录下的配置文件_config.yml里的post_asset_folder选项设置为true。新建文章的时候会同时创建一个同名文件夹用于放图片。 * 执行命令npm install hexo-asset-image --save ，下载安装一个可以上传本地图片的插件： * 使用的时候，只需要图片名就可以 * 也可以使用Hexo推荐的标签方式 Hexo优化速度 禁用背景动画 NexT已经自带了多种背景动画效果，你只需要根据需求在主题配置文件修改其中一个为true即可。 Canvas-nest canvas_nest: false three_waves three_waves: false 禁用mathjax 总配置文件 删掉 123456789101112# 数学公式math: engine: 'mathjax' # or 'katex' mathjax: src: custom_mathjax_source config: # MathJax config katex: css: custom_css_source js: custom_js_source # not used config: # KaTeX config 要让Github Pages被索引到 参考文档： Blog养成记(5) 要让Github Pages被索引到 让Google搜索到搭建在Github Pages上的博客 遇到的问题：node-pre-gyp build fail error while installing with npm install or npm install -d 解决方案： the error got resolved by running 1npm install --build-from-resource 如何使文章多级目录自动展开，而不是默认折叠 如果你想实现默认展开全部目录的功能，可以在themes/next/source/css/_custom/custom.styl文件中添加以下自定义样式规则： 123.post-toc .nav .nav-child &#123; display: block; &#125; 但是通常文章内会出现多级标题，对应的目录里就会有多级导航出现，这时候一些原本你不希望出现的次要标题也会在目录中出现并且无法折叠。可以通过以下样式实现默认只展开两级目录，这样以来就完美解决了该问题。 123.post-toc .nav .nav-level-1&gt;.nav-child &#123; display: block; &#125; 参考博客 Yearito's Blog]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Morris遍历]]></title>
    <url>%2F2019%2F03%2F27%2FMorris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Morris遍历 问题描述：利用Morris遍历实现二叉树的先序，中序，后续遍历，时间复杂度O(N)，额外空间复杂度O(1)。 算法描述 来到的当前节点记为cur（cur是一个引用），如果cur无左孩子，cur向右移动。 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright。 如果mostright的右指针指向空，则让其指向cur，cur向左移动。 如果mostright的右指针指向cur，则让其指向空，cur向右移动。 图解 算法解析 如果一个节点有左子树，则回到这个节点两次，若没有，则回到这个节点一次。递归版遍历无论如何可以三次来到一个节点，根据处理时机的不同分为三种顺序的遍历。而Morris遍历是根据一个节点左子树最右指针的指向来判断是第一次来到这个节点还是第二次。第一次来到这个节点处理时记为先序，第二次来到这个节点处理时记为中序。 在第二次来到这个节点时逆序打印它左子树的右边界，最后单独打印整棵树的右边界，记为后序遍历。 算法复杂度 整棵树可以分解成由右边界组成，算法有限次的遍历了右边界，所以时间复杂度是O(N)。 Code 123456789101112131415# 递归版遍历，方便理解def process_recursive(root, res=None): if root is None: return [] if res is None: res = [] # 1 # res.append(root.val) process_recursive(root.left, res) # 2 # res.append(root.val) process_recursive(root.right, res) # 3 # res.append(root.val) return res 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Morris版遍历def preorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: res.append(cur.val) node.right = cur cur = cur.left else: node.right = None cur = cur.right return resdef inorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res.append(cur.val) node.right = None cur = cur.right return res def postorder_morris(root: Node) -&gt; list: dummy = Node(0) dummy.left = root res = [] cur = dummy while cur: if cur.left is None: cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res += traceBack(cur.left, node) node.right = None cur = cur.right return resdef traceBack(frm, to): res = [] cur = frm while cur is not to: res.append(cur.val) cur = cur.right res.append(to.val) res.reverse() return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a]]></title>
    <url>%2F2018%2F01%2F26%2Fa%2F</url>
    <content type="text"><![CDATA[some content]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
