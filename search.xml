<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[presentation]]></title>
    <url>%2F2019%2F06%2F10%2Fassets%2F</url>
    <content type="text"><![CDATA[Student Registration System 五大模块 配置虚拟环境和框架 创建一个项目 使用模板 连接数据库 使用 web forms 和 flask-security 配置Flask框架 创建学生选课系统文件夹，并在其中创建虚拟环境 123mkdir SRScd SRSpython3 -m venv venv 启动虚拟环境 1. venv/bin/activate 在虚拟环境中安装Flask 1pip install Flask 在虚拟环境中安装flask-wtf (用于快速创建表单) 1pip install flask-wtf 在项目文件夹中创建 .flaskenv 12FLASK_ENV=developmentFLASK_APP=main.py 在虚拟环境中安装python-dotenv 用途：可以把所有用到的环境变量写到.env文件里，然后以k，v的方式读取作为环境变量。这样我们的项目迁移到不同的环境时只需要更改一下.env的内容就可以了，代码执行时会自动从.env文件里读取所需要的配置信息 1pip install python-dotenv 退出虚拟环境 1deactivate image-20190524131400912 创建并运行一个简单的Flask应用程序 首先启动虚拟环境，并进入项目文件夹下 创建requirements文件，方便迁移项目 1pip freeze &gt; requirements.txt 如需重新安装库文件 1pip install -r requirements.txt 创建main.py文件 123456from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" 运行 1flask run image-20190524132647750 image-20190524133420073 创建SRS应用程序 核心步骤 在项目文件中创建application文件夹，main程序运行时调用其中的内容，进入application文件夹 创建templates static __init__.py 重构代码，将main程序中的代码转移到init程序中 在项目文件夹下创建config.py 在app文件夹下创建routes.py 创建系统主页 index.html 增加navigation links和routing patterns 核心技术 路由 现代 Web 应用的 URL 十分优雅，易于人们辨识记忆，这一点对于那些面向使用低速网络连接移动设备访问的应用特别有用。如果可以不访问索引页，而是直接访问想要的那个页面，他们多半会笑逐颜开而再度光顾。 如上所见， route() 装饰器把一个函数绑定到对应的 URL 上。 这里是一些基本的例子: 1234567@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos; 12345678910111213141516171819@app.route("/login", methods=['GET','POST'])def login(): if session.get('username'): return redirect(url_for('index')) form = LoginForm() if form.validate_on_submit(): email = form.email.data password = form.password.data user = User.objects(email=email).first() if user and user.get_password(password): flash(f"&#123;user.first_name&#125;, you are successfully logged in!", "success") session['user_id'] = user.user_id session['username'] = user.first_name return redirect("/index") else: flash("Sorry, something went wrong.","danger") return render_template("login.html", title="Login", form=form, login=True ) 构造url 如果 Flask 能匹配 URL，那么 Flask 可以生成它们吗？当然可以。你可以用 url_for()来给指定的函数构造 URL。它接受函数名作为第一个参数，也接受对应 URL 规则的变量部分的命名参数。未知变量部分会添加到 URL 末尾作为查询参数。这里有一些例子: 123456789101112131415161718192021&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route(&apos;/&apos;)... def index(): pass...&gt;&gt;&gt; @app.route(&apos;/login&apos;)... def login(): pass...&gt;&gt;&gt; @app.route(&apos;/user/&lt;username&gt;&apos;)... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():... print url_for(&apos;index&apos;)... print url_for(&apos;login&apos;)... print url_for(&apos;login&apos;, next=&apos;/&apos;)... print url_for(&apos;profile&apos;, username=&apos;John Doe&apos;)...//login/login?next=//user/John%20Doe 1234567891011&lt;header&gt; &lt;nav&gt; &lt;ul class="nav nav-pills"&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('index') &#125;&#125;" class="nav-link &#123;% if index %&#125;active&#123;% endif %&#125;"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('courses') &#125;&#125;" class="nav-link &#123;% if courses %&#125;active&#123;% endif %&#125;"&gt;Classes&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('register') &#125;&#125;" class="nav-link &#123;% if register %&#125;active&#123;% endif %&#125;"&gt;Register&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('login') &#125;&#125;" class="nav-link &#123;% if login %&#125;active&#123;% endif %&#125;"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr style="clear:both"&gt;&lt;/header&gt; jinja2模板 Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML，你确信能在Python的字符串中正确地写出来么？反正我是做不到。 Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户。 这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。 Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等； 包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。 MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。 上面的例子中，Model就是一个dict：{ 'name': 'Michael' } 有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。 image-20190609160447890 使用模板 核心步骤 在templates中创建父模板 layout.html 和一些子模板, child template 都继承自 base template image-20190609162319851 1234567891011121314151617181920&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-12 text-center"&gt; &#123;% for user in users %&#125; &lt;dl&gt; &lt;dt&gt;User ID: &#123;&#123; user.user_id&#125;&#125;&lt;/dt&gt; &lt;dd&gt;Email: &#123;&#123;user.email&#125;&#125;&lt;/dd&gt; &lt;dd&gt;Password: &#123;&#123;user.password&#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &#123;% else %&#125; &lt;h3&gt;No users yet!&lt;/h3&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 将数据传送到视图层 通过request和response对象获取数据 核心技术 get和post请求： get请求： 使用场景： 如果只是对服务器获取数据， 并没有对服务器产生任何影响，那么这时候使用get请求 传参： get请求传参是放在url中，并且是通过?的形式来指定key和value的。 post请求： 使用场景：如果要对服务器产生影响，那么使用post请求。 传参： post请求传参不是放在url中，是通过form data的形式发送给服务器的。 get和post请求获取参数： get请求是通过flask.request.args来获取。 post请求是通过flask.request.form来获取。 post请求在模板中要注意几点： input标签中， 要写那么来表示这个value的key， 方便后台获取。 在写form表单的时候， 要指定method=post, 并且要指定action='/login/' image-20190609201459316 image-20190609201541807 连接数据库 核心步骤 安装MongoDB数据库系统 安装适应Flask框架的Mongo引擎扩展 配置数据库 连接数据库 创建一些数据 创建数据模型 配置 启动 mongodb，默认数据库目录即为 /data/db： 1sudo mongod 安装flask-mongoengine 1sudo pip install flask-mongoengine 配置一个数据库 1MONGODB_SETTINGS = &#123; &apos;db&apos; : &apos;GDUT_Enrollment&apos; &#125; 导包并初始化 1234from flask_mongoengine import MongoEnginedb = MongoEngine()db.init_app(app) image-20190609204941420 12345678910111213class User(db.Document): user_id = db.IntField( unique=True ) first_name = db.StringField( max_length=50 ) last_name = db.StringField( max_length=50 ) email = db.StringField( max_length=30 ) password = db.StringField( max_length=30 )@app.route("/user")def user(): User(user_id=1, first_name="Christian", last_name="Hur", email="christian@uta.com", password="abc1234").save() User(user_id=2, first_name="Mary", last_name="Jane", email="mary.jane@uta.com", password="password123").save() users = User.objects.all() return render_template("user.html", users=users) image-20190609210018628 image-20190609210116679 添加json数据 1mongoimport --jsonArray --db GDUT_Enrollment --collection course /Users/Mac/Downloads/flask记录/courses.json image-20190609211532213 image-20190609211702437 使用 web forms 和 flask-security 1sudo pip install flask-wtf flask-security 核心步骤 安装和配置 flask-wtf flask-security 创建注册和登录页面 处理表单数据和更新数据库 创建课程和选课页面 创建 sessions 和 authentication 核心技术 使用 WTForms 进行表单验证 WTForms 当编写验证客户端提交的多个Form表单时，视图函数中的代码很快将变得冗长和难以阅读，调试和维护也变得难以忍受。通过使用WTForms库，将表单定义为继承于Form的类，使用该类可以验证所有表单，并且可以在模板中自动生成表单对应的HTML元素，定制HTML生成过程，从而实现业务逻辑代码和展示的分离，并使得代码简洁干净、易于维护。 image-20190610000509784 12345678910111213141516171819202122232425262728293031323334 &#123;% extends "layout.html" %&#125; &#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-6 offset-md-3"&gt; &lt;form name="login" action="" method="post" novalidate&gt; &lt;fieldset class="form-group"&gt; &lt;legend&gt;&#123;&#123;title&#125;&#125;&lt;/legend&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;p&gt; &#123;&#123; form.email.label &#125;&#125;&lt;br&gt; &#123;&#123; form.email(size=35) &#125;&#125; &#123;% for error in form.email.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.password.label &#125;&#125;&lt;br&gt; &#123;&#123; form.password(size=15) &#125;&#125; &#123;% for error in form.password.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.submit() &#125;&#125; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 使用 Flask-Security 扩展 支持一般的安全和认证特性 支持数据持久化 使用 Werkzeug库进行密码加密 image-20190610001245573 使用 session 当客户端进行第一次请求时，客户端的HTTP request（cookie为空）到服务端，服务端创建session，视图函数根据form表单填写session，请求结束时，session内容填写入response的cookie中并返回给客户端，客户端的cookie中便保存了用户的数据。 当同一客户端再次请求时， 客户端的HTTP request中cookie已经携带数据，视图函数根据cookie中值做相应操作（如已经携带用户名和密码就可以直接登陆）。 在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。 image-20190610005826683 image-20190610005840485 image-20190610005847712 image-20190610005859756]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Binary Search Defination Given an sorted integer array( - nums), and an integer( - target). Find the any/first/last position of target in nums Return -1 if target does not exist. Template 1234start + 1 &lt; end start + (end - start) / 2 A[mid] ==, &lt;, &gt; A[start] A[end] ? target 好处：防止死循环，防止漏解，题目适用范围广 Example: First position of target 1234567891011121314151617def binarySearch(arr, target): start = 0 end = len(arr) - 1 while (start + 1 &lt; end): mid = start + (end - start) // 2 if arr[mid] == target: end = mid elif arr[mid] &lt; target: start = mid elif arr[mid] &gt; target: end = mid if arr[start] == target: return start if arr[end] == target: return end return -1 ###Exercise classical binary search search for a range 思路：两次二分查找，第一次找第一次出现的位置，第二次找最后一次出现的位置 #### Search Insert Position 思路1: find the first position &gt;= target 思路2: find the last position &lt; target, return +1]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F04%2F09%2FCompiler%2F</url>
    <content type="text"><![CDATA[Compiler notes First Sets Defination \(\text { First }(X)=\left\{t | X \rightarrow^{*} t \alpha\right\} \cup\left\{\varepsilon | X \rightarrow^{*} \varepsilon\right\}\) Algorithm sketch: \(\text { First }(t)=(t)\) \(\varepsilon \in \mathrm{First}(X)\) \(\begin{array}{l}{\text { if } X \rightarrow \varepsilon} \\ {\text { if } X \rightarrow A_{1} \dots A_{n} \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n}\end{array}\) \(\text { First }(\alpha) \subseteq \text { First }(X)\) \(\text { if } X \rightarrow A_{1} \ldots A_{n} \alpha \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n\) Follow Sets Defination: \(\text { Follow }(X)=\left\{t | S \rightarrow^{*} \beta Xt\delta\right\}​\) Intuition \(\begin{array}{c}{\text { If } X \rightarrow A B \text { then First }(B) \subseteq \text { Follow }(A) \text { and }} \ {\text { Follow }(X) \subseteq \text { Follow }(B)}\end{array}\) \(\text { if } B \rightarrow^{*} \varepsilon \text { then Follow }(X) \subseteq \text { Follow }(A)\) \(\text { If } S \text { is the start symbol then } \$ \in \text { Follow }(S)​\) Algorithm sketch: \(\$ \in \text { Follow }(S)\) \(\begin{array}{l}{\text { First }(\beta)-\{\varepsilon\} \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta}\end{array}​\) \(\begin{array}{l}{\text { Follow }(A) \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta \text { where }\varepsilon \in \text { First }(\beta)}\end{array}\) Select Sets Defination: \(\text { Select }(A \rightarrow \alpha)=\left\{t\right\}\) Algorithm sketch: \(\text { For each production } A \rightarrow \alpha \text { in G do: }\) \(\begin{array}{l}{-\text { For each terminal } t \in \text { First }(\alpha) \text { do }} \\ {\quad \cdot \mathrm{T}[A, t]=\alpha}\end{array}\) \(\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha), \text { for each } t \in \text { Follow }(A) \mathrm{do}} \\ {\quad \cdot \mathrm{T}[A,t]=\alpha}\end{array}\) \(\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha) \text { and } \$ \in \text { Follow }(A) \text { do }} \\ {\quad \cdot \mathrm{T}[A, \$]=\alpha}\end{array}\)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lecture 4 (Error and Noise)]]></title>
    <url>%2F2019%2F04%2F03%2FLecture-4-Error-and-Noise%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lecture 3 (The Linear Model I)]]></title>
    <url>%2F2019%2F04%2F01%2FLecture-3-The-Linear-Model-I%2F</url>
    <content type="text"><![CDATA[为了可以尽快上手，将线性模型调整到前面]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈(Monotonic Stack)]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack%2F</url>
    <content type="text"><![CDATA[算法解析 第一种情况 栈底到栈顶是由大到小排列，则使栈顶数弹出的是右边离它最近的比它大的数，新的栈顶数是左边离原栈顶数最近的比它大的数。反之亦然。 第二种情况 栈底到栈顶是由小到大排列，则使栈顶数弹出的是右边离它最近的比它小的数，新的栈顶数是左边离原栈顶数最近的比它小的数。 相关习题 654. Maximum Binary Tree 算法细节：每个数都找到左和右比它大的数，选择其中小的作为父节点，左和右都为空的数则是根节点。 算法正确性（易证）： 构造的是一棵树，而非森林 每个节点最多有两个孩子 84. Largest Rectangle in Histogram 延伸阅读：Jackson Gabbard讲解 12345678910111213141516171819202122class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ stack = [] max_area = 0 index = 0 while index &lt; len(heights): if not stack or heights[stack[-1]] &lt; heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area 85. Maximal Rectangle 总结 单调栈关心的是一维数组上某个数与其周围数的关系。例如寻找距离最近的比它大（或小）的数；在histogram中，前后的bar的高低影响了最终矩形的计算；在最大子矩阵中，把每一行矩阵看做一个直方图。在这些例子中我们可以试图用单调栈来解决。在使用单调栈的时候，想清楚每个元素出栈的意义，什么时候更新index，遇到重复的元素如何处理，栈为空时是什么情况等等。因为每个元素都出栈入栈各一次，所以时间复杂度是O(n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 2 (Is Learning Feasible?)]]></title>
    <url>%2F2019%2F03%2F30%2FLecture-2-Is-Learning-Feasible%2F</url>
    <content type="text"><![CDATA[\( E_{in}\)]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
      <tags>
        <tag>feasible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2019%2F03%2F29%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class AvlTree(object): """ An avl tree. """ def __init__(self): # Root node of the tree. self.node = None self.height = -1 self.balance = 0 def insert(self, key): """ Insert new key into node """ # Create new node n = TreeNode(key) if not self.node: self.node = n self.node.left = AvlTree() self.node.right = AvlTree() elif key &lt; self.node.val: self.node.left.insert(key) elif key &gt; self.node.val: self.node.right.insert(key) self.re_balance() def re_balance(self): """ Re balance tree. After inserting or deleting a node, """ self.update_heights(recursive=False) self.update_balances(False) while self.balance &lt; -1 or self.balance &gt; 1: if self.balance &gt; 1: if self.node.left.balance &lt; 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance &lt; -1: if self.node.right.balance &gt; 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): """ Update tree height """ if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): """ Calculate tree balance factor """ if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): """ Right rotation """ new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): """ Left rotation """ new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root def in_order_traverse(self): """ In-order traversal of the tree """ result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的奇技淫巧]]></title>
    <url>%2F2019%2F03%2F27%2FHexo%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Hexo添加文章时自动打开编辑器 mac下修改文件夹权限： sudo -i进入root模式 chown -R 用户名 /文件夹名 操作步骤： 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 Mac平台的Hexo用户将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new "auto open editor test" 是不是就顺利的自动打开了自动生成的md文件啦~ Hexo添加评论区 参考: Valine leancloud Hexo内嵌pdf文档 安装插件https://github.com/superalsrk/hexo-pdf 修改主题配置文件 123456789# PDF Support# Dependencies: https://github.com/theme-next/theme-next-pdfpdf: enable: true # Default (true) will load PDFObject / PDF.js script on demand. # That is it only render those page which has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject / PDF.js srcipt EVERY PAGE. per_page: true height: 500px 其他选择 &lt;center&gt;&lt;embed src=&quot;/pdf/mou.pdf&quot; width=&quot;850&quot; height=&quot;600&quot;&gt;&lt;/center&gt; &lt;iframe src=&quot;/pdf/mou.pdf&quot; style=&quot;width:850px; height:600px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; Hexo显示数学公式 Hexo博客数学公式显示 MarkDown 插入数学公式实验大集合 Hexo Next主题解决无法显示数学公式 解决block数学公式下有scroll bar的问题 layout/_third-party/math/mathjax.swig下的 123456&lt;style&gt;.MathJax_Display &#123; overflow-x: scroll; overflow-y: hidden;&#125;&lt;/style&gt; 修改为 1234567&lt;style&gt;.MathJax_Display &#123; overflow: auto hidden; overflow-x: hidden; overflow-y: hidden;&#125;&lt;/style&gt; 参考：https://github.com/theme-next/hexo-theme-next/issues/658 Hexo插入图片 Hexo方式post_asset_folder&quot;#&quot; * 根目录下的配置文件_config.yml里的post_asset_folder选项设置为true。新建文章的时候会同时创建一个同名文件夹用于放图片。 * 执行命令npm install hexo-asset-image --save ，下载安装一个可以上传本地图片的插件： * 使用的时候，只需要图片名就可以 * 也可以使用Hexo推荐的标签方式]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Morris遍历]]></title>
    <url>%2F2019%2F03%2F27%2FMorris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Morris遍历 问题描述：利用Morris遍历实现二叉树的先序，中序，后续遍历，时间复杂度O(N)，额外空间复杂度O(1)。 算法描述 来到的当前节点记为cur（cur是一个引用），如果cur无左孩子，cur向右移动。 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright。 如果mostright的右指针指向空，则让其指向cur，cur向左移动。 如果mostright的右指针指向cur，则让其指向空，cur向右移动。 图解 算法解析 如果一个节点有左子树，则回到这个节点两次，若没有，则回到这个节点一次。递归版遍历无论如何可以三次来到一个节点，根据处理时机的不同分为三种顺序的遍历。而Morris遍历是根据一个节点左子树最右指针的指向来判断是第一次来到这个节点还是第二次。第一次来到这个节点处理时记为先序，第二次来到这个节点处理时记为中序。 在第二次来到这个节点时逆序打印它左子树的右边界，最后单独打印整棵树的右边界，记为后序遍历。 算法复杂度 整棵树可以分解成由右边界组成，算法有限次的遍历了右边界，所以时间复杂度是O(N)。 Code 123456789101112131415# 递归版遍历，方便理解def process_recursive(root, res=None): if root is None: return [] if res is None: res = [] # 1 # res.append(root.val) process_recursive(root.left, res) # 2 # res.append(root.val) process_recursive(root.right, res) # 3 # res.append(root.val) return res 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Morris版遍历def preorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: res.append(cur.val) node.right = cur cur = cur.left else: node.right = None cur = cur.right return resdef inorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res.append(cur.val) node.right = None cur = cur.right return res def postorder_morris(root: Node) -&gt; list: dummy = Node(0) dummy.left = root res = [] cur = dummy while cur: if cur.left is None: cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res += traceBack(cur.left, node) node.right = None cur = cur.right return resdef traceBack(frm, to): res = [] cur = frm while cur is not to: res.append(cur.val) cur = cur.right res.append(to.val) res.reverse() return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a]]></title>
    <url>%2F2018%2F01%2F26%2Fa%2F</url>
    <content type="text"><![CDATA[some content]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
