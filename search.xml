<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[爬虫基础]]></title>
    <url>%2F2020%2F01%2F12%2F%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[SDE基础]]></title>
    <url>%2F2020%2F01%2F09%2FSDE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[image-20200109155032491 image-20200109155248666 credit: rick sun Overview Data structure is a particular way of organizing data in a computer so that it can be used efficiently. Common data structure Array Stack Queue Linked List Tree Heap Graph Hash table Platform https://www.laioffer.com/ https://www.laicode.io/ Array and Sorting Algorithms E.g. int a[10]; Assume a problem's size is n (n elements) , For example: print all the elments of this array. Big O notation: algorithm complexity (time complexity, space complexity) e.g., time complexity O(n). e.g., space complexity: how much memory does it need to run this algorithm. O(n) e.g., auxiliary space complexity: is the extra space or temporary space used by an algorithm. Selection Sort Example: int[i]=(-1, -3, 4, 7) =&gt; (-3, -1, 4, 7) ascending order iteration 1: find global min -3 (-3, -1, 4, 7) insert 3 to the right place iteration 2; find global min in the rest -3 (-1, 4, 7) =&gt; -3 -1 (4, 7) iteration 3; find global min in the rest -3 -1 (4, 7) =&gt; -3 -1 4 (7) iteration 4; find global min and done . 讲解code要点: 做题要求: A complete answer will include the following: Document your assumptions Explain your approach and how you intend to solve the problem Provide code comments where applicable Explain the big-O run time complexity of your solution. Justify your answer. Identify any additional data structures you used and justify why you used them. Only provide your best answer to each part of the question. 1234567891011121314151617// selection sort an array a[] with size n.void SelectionSort(int a[], int n) &#123; int global, temp; for (int i = 0; i &lt; n-1; i++) &#123;// outer loop: how many iterations global = i; for (int j = i + 1; j &lt; n; j++) &#123;// inner loop: find the global min from the rest elements. if (a[j] &lt; a[global]) &#123; // record the index of the smallest element. global = j; &#125; &#125; // swap the global (a[index]) min with a[i]; temp = a[i]; a[i] = a[global]; a[global] = temp; &#125;&#125; 时间复杂度分析: O(n^2) Discussion: 1) 什么是面试中一个类型的题? (1.1) Given an array in Stack1, how to sort the numbers by using additional two stacks? Stack1 || 1 3 2 4 . global_ min = Stack2 || Stack3 || 通过Stack1和2选择出最小值放在Stack3中，再将Stack1恢复，循环。 (1.2) Follow up, what if only 1 additional stack can be used? Merge sort a[n] = 1,3,5,7,9,8,6,4,2,0 Space = O(n) // look at the pink path Time = O(nlogn) C1493EE98849B4FD9AAD3A6F8B7979BF 12345678910111213vector&lt;int&gt; mergeSort (vector&lt;int&gt;&amp; a, int left, int right) &#123; vector&lt;int&gt; solution; if (left == right) &#123; solution.push_back(array[left]); return solution; &#125; int mid = left + (right - left) / 2; vector&lt;int&gt; solu_left = mergeSort(a, left, mid); vector&lt;int&gt; solu_right = mergeSort(a, mid + 1, right); solution = combine(solu_left, solu_right); return solution;&#125; Discussion: 1) Could we use Merge Sort to sort a linked list?What is the time complexity if so? 可以，在使用快慢指针找到linked list的中点的时间复杂度为O(N)，所以在横线上的每一层都是O(N)的复杂度，但还是logn层，所以总的复杂度不变，仍为O(n logn)。 什么是面试中一个类型的题? (2.1) e.g A1B2C3D4 -&gt; ABCD1234 性质:只是combine function的实现稍微不一样而已。 设置成字母比数字小 (2.2) (Advanced topic 1) ABCD1234 -&gt; A1B2C3D4 Way of thinking? How to relate 2.1 and 2.2? Do not only focus on solving 1 problem and 1 problem only. (2.3) (Advanced topic 2) K-way merge and its application in Mapreduce e.g. how to merge TB/PB level data? Algorithm + System Design (2.4) (Advanced topic 3) count- array problem Given an array A[N] with all positive integers from [1...N]. How to get an array B[N] such that B[i] represents how many elements A[j] (j &gt; i) in array A[] that are smaller than A[i]. For example, given A[N]={4, 1, 3, 2}, we should get B[N]={3, 0, 1, 0}. Requirement: Time = O(nlogn). 性质: 在log(n)层中，combine function能够让每个element都会和其他所有的元素compare至少一次。总的时间复杂度依然是O(nlogn) Quick sort 两个挡板 i j, 三个区域 a) b) c) 的思想: a) [o...i) : i 的左侧(不包含i) 全部为比pivot小的数 b) [i...j] : i 和 j 之间为未知探索区域 c) (j...n-1] : j 的右侧(不包含j)全部为比pivot大或等于的数字 image-20200109214833850 image-20200109214924894 image-20200109215110945 image-20200109215206503 image-20200109215413079 Recursive rule: Quicksort all numbers to the left of 5, Quicksort all numbers to the right of 5, Discussion: 1) What is the worst case scenario for quicksort? Can you provide an example? O(n^2) 每次的规模减小1个，即每次的pivot选择的都是最小或最大值。所以若对time complexity的bound比 较严格的话选择merge sort会好一些。 什么是面试中一个类型的题? (2.1) Array Shuffling 1: Given an array with integers, move all &quot;0s&quot; to the right-end of the array. (2个挡板，3个区域，相向而行) (2.2) Character removal from a string: (Will be discussed later in String) (2个挡板，3个区域，同向而行) Remove one or more types of characters from a string. (2.3) Quick Partition Problems (2个挡板，3个区域，相向而行) (2.4) Rainbow sort (abcccabbcbbacaa -&gt; aaaaa bbbbb ccccc) (3个挡板，4个区域，同向 + 相向而行) Answer: initialization: ¡= 0; all letters to the left-hand side of are all &quot;a&quot;s j= 0; (j is actually the current index) all letters in [i, j) are all &quot;b&quot;s , k= n-1 (all letters to the right-hand side of k are all &quot;c&quot;s). unknown area is [j...k] 若j位置是a，则 i, j互换 i++, j++ 若j位置是b，则 j++ 若j位置是c，则 j, k互换 k-- Discussion: Class1: What did we learn today? Time/Space complexity Sorting Algorithms Time/Space, and why? When to prefer to use one to another? Understand sorting algorithms with design problems? More to do :-) Recursion I Recursion 需要掌握的知识点: 1) 表象上: function calls itself 2) 实质上: Boil down a big problem to smaller ones (size n depends on size n-1, or n-2 or...n/2) 3) Implementation上: a) 1. Base case: smallest problem to solve b) 2. Recursive rule. how to make the problem smaller (if we can resolve the same problem but with a smaller size, then what is left to do for the current problem size n) 4) to be continued ... Recursion Question 1: Fibonacci sequence Base case: F(0)= 0; F(1)= 1; Recursive rule: F(n) = F(n-1) + F(n-2); 12345678910// Calculating Fibonacci valueint fibo (int n) &#123; // Base case. (进入function之后首先check是否要停下来) if (n == 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; return fibo(n-1) + fibo(n-2); // Recursive rule&#125; Call Stack (Term): was designed to record all local variables that are allocated in the stack. content: Level1: n = 4 Level2: n = 3 Level3: n = 2 Level4: n = 1 There are n levels in the recursion tree, and this recursion tree is a binary tree. Thus, there are totally at most O(2^n) nodes in the tree. Time = O(2^n) Trick: 所有前面的node的个数的总和，都没有最后一层node的个数多，因此我们分析tree的time complexity,往往只看最后一层node的个数。 Space = O(n) because there are n levels of recursion function call, and thus there are n levels of call_ stack. In call_ stack, each level only stores 1 local variable, that is, int n. Recursion Question 2: How to calculate a^b (where a is an integer and b is also an integer, we do not care about the corner case where a = 0 or b &lt; 0 for now) 求 2^1000 a=2 b=1000 123456789101112int a_power_b(int a, int b) &#123; if (b == 0) &#123; return 1; &#125; int half_result = a_power_b(a, b/2); if (b % 2 == 0) &#123; return half_result * half_result; &#125; else &#123; return half_result * half_result * a; &#125;&#125; Binary Search what is binary search in the context of an array? 1) Array has to be sorted. ascending or descending 1 2 3 5 7 9 ... ?????? Not necessarily the case. 2) Problem to solve? Array 1 3 7 23 57 ... 100 99 86 44 32 21 find the maximum Essentially, the principle of binary search is to reduce the search space by 1/2 of its original size. In the meantime, you must guarantee that the target must not be ruled out. --- to find an element/number in an array, -&gt; sorted array. Example: a[7] = 1 2 4 5 7 8 9 whether 4 is in this array or not. index 0 1 2 3 4 5 6 A[7] 1 2 4 5 7 8 9 Iteration 1: L = 0, R = 6, M = 3 A[M] == A[3] == 5 &gt; target == 4, so R = M-1 = 2; Iteration 2: L = 0, R = 2, M = 1 A[M] == A[1] == 2 &lt; target == 4, so L = M+1=2; Iteration 3: L = 2, R = 2, M = 2 A[M] == A[2] == 4 == target , so Done!!! n element -&gt; time complexity O(log(n)); 1234567891011121314151617// Classical Version 1.0// return any target element's indexint binary_search(int a[], int size, int target) &#123; int left = 0; int right = size - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (a[mid] == target) &#123; return mid; &#125; else if (a[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1;&#125; Apply binary search in 2D space Variant 1.0 application: 2D matrix, sorted on each row, first element of next row is larger (or equal) to the last element of previous row, now giving a target number, returning the position that the target locates within the matrix 1 2 3 4 5 6 7 8 target == 7 9 10 11 12 Solution1: Step1: Run binary search in the 0-th column to find the possible row that contains target Step2: Run 2nd binary search, in the particular row to find target (if any) Time = O(logm + logn) = O(log(m*n)) Solution2: Run only 1 time of binary search Left= [0] [0], Right =[m-1]x[n-1], 1D =mxn-1 Mid[row] [col]= (left + right) / 2 = mid_size row= mid_ size / col; col = mid_ size % col; Time = O(log (m*n) ) Variant 1.1 how to find an element in the array that is closest to the target number? // e.g int a[5] = {1, 2, 3, 8, 9}; target = 4 should return 3 only need to contain the wanted target in the range, not rule out the target number. 123456789101112131415161718192021int binary_search(int a[], int size, int target) &#123; int left = 0; int right = size - 1; while (left + 1 &lt; right) &#123; // avoid infinite loop int mid = left + (right - left) / 2; if (a[mid] == target) &#123; return mid; &#125; else if (a[mid] &gt; target) &#123; right = mid; &#125; else &#123; left = mid; &#125; &#125; // post-processing if (Math.abs(a[left] - target) &lt; Math.abs(a[right] - target)) &#123; return left; &#125; else &#123; return right; &#125;&#125; 其中 line10 right = mid 不能改为 right = mid - 1 其中 line11 left = mid 不能改为 left = mid + 1 反例 [1, 2, 8, 10] target = 3 如果更改了right或left 有可能删掉了想要的index 其中 line5 while 循环条件 start + 1 &lt; end 可以保证循环内 start 和 end 不相邻，从而避免死循环 Variant 1.2 return the index of the first occurrence of an element, say 5 index 0 1 2 3 4 5 6 A[7] 4 5 5 5 5 5 5 Iteration 1: L = 0, R = 6, M = 3 A[M] == A[3] == 5 == target, so R = M = 3; Iteration 2: L = 0, R = 3, M = 1 A[M] == A[1] == 5 == target, so R = M = 1; 因为左右边界相邻，我们 terminate binary search，再做 post processing. Variant 1.3 return the index of the last occurrence of an element e.g. inta[6] = [4, 5, 5, 5, 5, 5]; if target == 5; then index 5 is returned; if target == 10; then -1 is returned; Variant 1.4 how to find closest k elements in the array that is closest to the target number? e.g int a[5] = {1, 2, 3, 8, 9}; Target == 4; k = 3, solu = {3, 2, 1} Solution: Step1: we first move L and R by using binary search to make it close to the target number, until there are two or less elements in between L and R. Step2: 谁小移谁 Time = O(logn+ k) Variant 1.5 how to find the smallest element that is larger than a target number? Binary Search Variant 2.0: Important Question: Given a sorted dictionary with unknown size, how to determine whether a word is in this dictionary or not. Example: dictionary[x] = { 1 3 5 7 9 ..... 100 .... 1000000000 ..... } Target == 9999 assumption if dictionary[index] == NULL then we know the size of dictionary is &lt; index; Step1 jump out step = 2 Step2 jump out step = 2^2 = 4 Step3 jump out step = 2^3 = 8 Step4 jump out step = 2^4 = 16 Stepk until dictionary[2^k] &gt;= target OR dictionary[2^k] == null // target can exist and its 2^(k-1) &lt; index &lt; 2^k Further discussion about binary search: Why not jump_ step = jump_ step * 10, instead of jump_ step = jump_ step * 2 10Times: log_10 (n) + log_2 (10n) 2 Times: log_2 (n) + log_2 (2n) 比较10 times - 2 times即可 Discussion When to use binary search 1) very very classical problem: when the input is completely/partially sorted a. sorted array b. sorted array but shifted C. two sorted order array but Array 1 3 7 23 57 .... 100 99 86 44 32 21 2) has some logic rule under the hood. but you can figure out proof that you can disregard 1/2 searching range each time ARRAY 1 XXXXXXXXXXXXXXXXXXX m ARRAY 2 YYYYYYYYYYYYYYYY n (m+n)/2 no no no!!!! FIND THE K-th smallest element in the array Yes: reduce the search range from k to k/2 Queue &amp; Stack Queue 1.1. Example: wait in a line, FIFO == First in first out 1.2. Usages: Breadth-First Search related problems 1.3. C++ reference http://www.cplusplus.com/reference/queue/queue/ 1.4. 典型问题 1.4.1. Tree print out by level 1.4.2. Sliding window problems (Deque: double ends manipulation) poll() -- take the element from head peek() -- look at the element at the head offer() -- insert the element at the tail Stack LIFO Last in first out: like a box e.g. insertion order 1.2.3.4, then in the stack, it looks like 5 &lt;- top of the stack. All operations can only be done to this element 4 3 2 1 &lt;- bottom of the stack All operations available: push(), pop(), top() Implementation: popular data structure: array or vector Four popular interview questions: Question 1: How could we implement a queue by using two stacks? head tail 1 2 3 4 lI II 5 6 7 8 9 stack1 stack2 stack 1 -&gt; responsible for poll() -&gt; stack1.pop() stack 2 -&gt; responsible for offer() -&gt; stack2.push() case1. if stack1 is not empty, stack1.pop() case2. if stack2 is empty -&gt; pop elements from stack2 and push them into stack1 Time Complexity: offer() - O(1) poll() - worst case - case2 O(n) Amortized Analysis: for the n elements: for the first element - worst case (2n + 1) pop all from stack2 and push all into the stack 1 and pop 1 element from stack1 for the following n-1 elements - 1 * (n-1) total 2n + 1 + n - 1 = 3n O(3n)/n = O(3) = O(1) -- Amortized Time Complexity. Question 2: How to implement the min() function when using stack with time complexity O(1); stack1 II 5 4 3 4 5 stack2 II 5 4 3 3 3 stack2: maintain the corresponding min value according to stack1. Follow up Question: how to optimize the space when there are a lot of duplicate elements in stack1?stack1 II 5 4 3 3 3 3 3 3 3 3 3 stack2 II 5 4 3 3 3 3 3 3 3 3 3 stack1 II 5 4 3 3 3 3 3 3 3 3 3 stack2 II &lt;5, 0&gt; &lt;4, 1&gt; &lt;3, 2&gt; 1234class Wrapper &#123; int min; int pos;&#125; pop only when -&gt; stack1.size() == stack2.peek().pos + 1 Question 3: How to sort numbers with two stacks stack1 II 1 2 2 2 4 3 stack2 II 1 stack2 to maintain the numbers in sorted order. two variable: globalMin and counter while (stack2.top() &gt;= globalMin) { } Question 4: How to use multiple stacks to implement a de-queue(double ended queue) head tail 1 2 3 4 lI II 5 6 7 8 9 stack1 stack2 pushL stack1.push() pushR stack2.push() popL case1: stack1 is not empty, O(1) case2: if stack1 is empty, we need to pop all the elements from stack2 and push them to stack1 popR case1: stack2 is not empty, O(1) case2: if stack2 is empty, we need to pop all the elements from stack1 and push them to stack2 Worst case: amortized Time Complexity O(n) e.g. stack1: empty stack2: empty pushR(5, 6, 7, 8, 9) - n elements popL - n popR - n-1 popL - n-2 popR - n-3 ...... Total: O(n + n-1 + n-2 + ... + 1) = O(n^2), O(n^2) / n = O(n) How to optimize to O(1)? 分析复杂度高的原因是每次都将所有元素移动，如果借助一个辅助栈只移动一半元素，时间平摊到其他操作则会大幅度降低复杂度。 intuition: move half of the elements in stack2 to stack1. 第一次操作： stack2移动一半元素到stack3 O(n) stack2移动剩余一半元素到stack1 O(n) stack3移动回元素到stack2 O(n) 0.5n个元素其余次操作: O(1) amortized Time Complexity: ( O(n) + O(n) + O(n) + O(0.5n) ) / 0.5n = O(7) = O(1) Discussion: 什么问题要往Stack上考虑? 从左到右linear scan一个array/string时, 如果要不断回头看左边最新的元素时往往要用到stack 1) Histogram中找最大的长方形 2) reverse polish notation逆波兰表达式的计算a* (b+c) → abc+* 3) String的repeatedly deduplication. cabba → caa → c LinkedList Key points: 1) When you want to de-reference a ListNode, make sure it is not a NULL pointer 2) Never ever lost the control of the head pointer of the LinkedList Question: How to reverse a linked list? Node1(head) --&gt; Node2 --&gt; Node3 --&gt; Node4 .... --&gt; NodeN --&gt; NULL reversed: NULL &lt;-- Node1&lt;-- Node2 &lt;-- Node3 &lt;-- .... &lt;-- NodeN( head) Iterative Solution: 123456789101112// Solution1: create a new linked listpublic ListNode reverse(ListNode head) &#123; ListNode newHead = null; ListNode cur = head; while (cur != null) &#123; ListNode next = cur.next; cur.next = newHead; newHead = cur; cur = next; &#125; return newHead;&#125; 123456789101112131415// Solution2: 原地反转指针指向public ListNode reverse(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode next = head.next; head.next = null; while (next != null) &#123; ListNode cur = next; next = next.next; cur.next = head; head = cur; &#125; return head;&#125; Recursive Solution: 123456789// Recursive way:public ListNode reverseLinkedList(ListNode head) &#123; if (head == NULL || head.next == NULL) return head; // base case ListNode newHead = reverseList(head.next); // breaking point.. head.next.next = head; head.next = null; return newHead;&#125; image-20200111181752308 image-20200111181820225 常见考题: Q1. How to find the middle node of a linked list? 快慢指针 偶数个节点选左边的那个，因为左边的next node就是右边的。 Q2. 用快慢指针判定一个linkedlist是否有环。 Q3. Insert a node in a sorted linked list (simple) N1 &lt; node &lt; N2 找到N1和N2 Q4. How to merge two sorted linked list into one long sorted linked list 有可能插头或插尾，处理corner case使用dummy node step 1: find mid node step 2: reverse the second half list step 3: merge two sub lists. Q6. Partition List: Given a linked list and a value x, partition it such that all nodes less than x come first, then all nodes with value equal to x or greater than or equal to x. The original relative order of the nodes in each of the two partitions should be preserved. For example, Input: 1 -&gt; 6 -&gt; 3 -&gt; 2a -&gt; 5 -&gt; 2b and target x = 4, result: 1 -&gt; 3 -&gt; 2a -&gt; 2b -&gt; 6 -&gt; 5. Solution: Step1: allocate two new linked list heads; Step2: Iterate over every single element in the list, and compare with the current node's value with the target's value. Case1 if current.value &lt; target.value: Add the current node to the tail of the first linked list . Case2: otherwise, add the current node to the tail of the second linked list. 1st half (small values ) 2nd half (large values ) Step3: Concatenate the tail of the first half to the head of the 2nd linked list. Step4: The tail of the large list.next == NULL 1234567891011121314151617181920212223public class PartitionLinkedList &#123; public ListNode partition (ListNode head, int x) &#123; if (head == null) return null; ListNode fakeHeadSmall = new ListNode(0); ListNode fakeHeadLarge = new ListNode(0); ListNode smallTail = fakeHeadSmall; ListNode largeTail = fakeHeadLarge; ListNode current = head; while (current != null) &#123; if (current.val &lt; x) &#123; smallTail.next = current; smallTail = current; &#125; else &#123; largeTail.next = current; largeTail = current; &#125; current = current.next; &#125; largeTail.next = null; // terminate the list with null smallTail.next = fakeHeadLarge.next; return fakeHeadSmall.next; &#125;&#125; Binary Tree &amp; Binary Search Tree Definition: at most two children node. Example: Trick: base case usually refers to the null ChildNode below the leaf node. 基本概念 Balanced binary tree: is commonly defined as a binary tree in which the depth of the left and right subtrees of every node differ by 1 or less. Complete binary tree: is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Binary Search tree: for every node in the tree, the values in its left subtree are all smaller than its value, and the values in its right subtree are all larger than its value. Discussion (High Level) Binary tree往往是最常见的，和recursion 结合最紧密的面试题目类型。 Reasons: 每层的node具备的性质，传递的值和下一层的性质往往一致。比较容易定义recursive rule. Base case (generally): null pointer under the leaf node Example1: int getHeight (Node root) Example2: 统计tree里边有多少个node? Fundamental Knowledge: Traversal of a binary tree Definition Balanced binary tree Complete binary tree Binary search tree (BST) Binary Tree Q1. Get height of a binary tree 123456public int getHeight(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return 1 + Math.max(getHeight(root.left), getHeight(root.right));&#125; Time = O(n) where n is the total number of the nodes Space = O(n) == O(height) Q2. How to determine whether a binary tree is a balanced binary tree? 1234567891011public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123; return false; &#125; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125; image-20200114205944605 Q3. How to judge whether a binary tree is symmetric? 12345678910public boolean isSymmetric (TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; else if (left == null || right == null) &#123; return false; &#125; else if (left.value != right.value) &#123; return false; &#125; return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);&#125; Time = O(n) Space = O(n) Q3. Let's assume if we tweak the Ichild with rchild of an arbitrary node in a binary tree, then the &quot;structure&quot; of the tree are not changed. Then how can we determine whether two binary trees' structures are identical. 1234567891011public boolean isIdentical (TreeNode left, TreeNode right) &#123; if (left == null &amp;&amp; right == null) &#123; return true; &#125; else if (left == null || right == null) &#123; return false; &#125; else if (left.value != right.value) &#123; return false; &#125; return isIdentical(left.left, right.left) &amp;&amp; isIdentical(left.right, right.right) || isIdentical(left.left, right.right) &amp;&amp; isIdentical(left.right, right.left);&#125; image-20200114213236663 Total number of nodes in this quad tree = 4^(log2(n)) = 2^(2log2(n)) = O(n^2) Binary Search Tree Q1. How to determine a binary tree is a BST? 12345678910public boolean isBSTHelper(TreeNode root, int min, int max) &#123; if (root == null) &#123; return true; &#125; if(root.val &lt;= min || root.val &gt;= max) &#123; return false; &#125; return isBSTHelper(root.left, min, root.val) &amp;&amp; isBSTHelper(root.right, root.val, max);&#125; Time = O(n) Space = O(height) = O(n) Discussion Recursion在tree题目的基本应用大致分为2类用法（存疑） 把value从上往下传递(then从下往上)的题目 BST判定方法 把value从下往上传递(更为常见，必须熟练掌握) getHeight(TreeNode root) 是经典的把integer value从下往上传递的题 isBalanced(TreeNode root)是把boolean value从下往上传递的题目 isSymmetric(TreeNode root1, TreeNode root2)是把boolean value从下往上传递的题目 Assign the value of each node to be the total number of nodes that belong to its left subtree. (是把integer value从下往上传递的题目) Q2. Print BST keys in the given range Given two values k1 and k2 (where k1 &lt; k2) and a root pointer to a Binary Search Tree. Print all the keys of tree in range k1 to k2. i.e. print all x such that k1 &lt;= x &lt;=k2 and x is a key of given BST. Print all the keys in an increasing order. 1234567891011121314public void rangeInOrder(TreeNode root, int k1, int k2) &#123; if (root == null) &#123; return; &#125; if (root.value &gt; k1) &#123; rangeInOrder(root.left, k1, k2); &#125; if (root.value &gt;= k1 &amp;&amp; root.value &lt;= k2) &#123; System.out.println(root.value); &#125; if (root.value &lt; k2) &#123; rangeInOrder(root.right, k1, k2); &#125;&#125; Heap 堆 (英语: heap) 亦被称为: 优先队列 (英语: priority queue) Example index 0 1 2 3 4 5 value 1 3 2 5 4 7 Heap: is an unsorted array but have special rules to follow 性质: 堆的实现通过构造二叉堆(binary heap), 这种数据结构具有以下性质 1. 任意节点小于它的所有后裔，最小元素在堆的根上(堆序性)。 2. 堆总是一棵完全树。complete tree 3. 将根节点最大的堆叫做MAX HEAP，根节点最小的堆叫做最小堆MIN HEAP 4. index of lChild = index of parent X 2 + 1 5. index of rChild = index of parent X 2 + 2 6. unsorted but follow rules above 支持的基本操作 1. insert: 向堆中插入一个新元素；时间复杂度O(log(n)) 2. update: 将新元素提升使其符合堆的性质；时间复杂度O(log(n)) 3. get/top: 获取当前堆顶元素的值；时间复杂度O(1) 4. pop: 删除堆顶元素；时间复杂度O(log(n)) 5. heapify: 使得一个unsorted array变成一个堆。时间复杂度O(n) 经典考题 Q1 Find smallest k elements from an unsorted array of size n. Solution1: sort it and return the first k element! Time = O(nlogn) Solution2: e.g. k= 3, Use selection sort principle 1st iteration to find 1st smallest element to return 2nd iteration to find 2nd smallest element to return ... k-th iteration to find the k-th smallest Time = O(k * n) Solution3: MIN-HEAP of size n Step1: heapify the whole array to make it a MIN-heap. O(n) Step2: keep popping k times k*log(n) Total time = O(n) + O(klog(n)) Solution4: MAX-HEAP of size k xxxxxx Yxxxxxxxxxxxxxxxxxxxx size= k k+1 Step1: insert all first k elements into a max-heap (optimization heapify first k element) O(k) Step2: from the k+1-th element to the n-th element, if the current element Y case2.1 Y &lt; max-heap.top(), we call max-heap.pop(), and then max-heap.insert(Y) case2.2 Y &gt;= max-heap.top(), do nothing. Time = O(k) + O((n-k) * log(k) COMPARISON:3, 4 MIN-HEAP MAX-HEAP Time Complexity O(n) + O(klog(n)) O(k) + O((n-k) * log(k) Case1 k &lt;&lt;&lt; n O(n) O(n) * log(k) hard to say Case2 k~n O(nlogn) O(nlogn) hard to say Solution5: average time = O(n)on average= on average = O(n + n/2 + n/4 + n/8+ 1...) = O(n) worst case = O(n^2) Graph I image-20200113190008687 Node / State Edge / action Directed vs undirected graph Representation of the graph Adjacency Matrix Pros: Representation is easy to implement. Edge removal takes O(1) time. Queries like whether there is an edge from vertex 'u' to vertex 'V' are efficient and can be done O(1). Adjacency List Vertices/nodes: IVI Edges: IEI Pros: Space complexity= O(lVI+lEl) . Adding a vertex/node to the graph is easier. Cons: Time complexity is O(V) to check whether there is an edge from a node to the other. (compared to O(1) in adjacent matrix) Use a hash_table &lt;key = node, value = set of successors&lt; Node &gt;&gt; 图里常用的search算法 Breadth-First Search (BFS-1): print/visit = 1 32 547 9 11 How to describe a relatively complex algorithm: what kind of data structure that this algorithm uses queue what are the actions of this algorithm step by step initial state: insert the start node into the queue queue = {1} process: while the queue is not empty, pop the left-most element out of the queue and expand it, generate all its successors and insert all of them into the tail of the queue termination condition: when the queue is empty 经典例题1：分层打印一个binary tree 12345678910111213141516171819202122// param: root - the root of the treepublic void BFS(Node root) &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;(); q.offer(root); while(!q.empty()) &#123; int size = q.size(); // size = # of generated nodes in the next layer. for (int i = 0; i &lt; size; i++) &#123; Node n = q.remove(); if (n.left != null) &#123; q.offer(n.left); &#125; if (n.right != null) &#123; q.offer(n.right); &#125; System.out.print(n.val + " "); &#125; System.out.println(); &#125;&#125; 经典例题2: Bipartite : whether a graph's node can be divided into two group, such that the nodes in each group do not have direct edges between the nodes that belong to the same group. 12345class GraphNode &#123; int value; char set; // u or v? ArrayList&lt;GraphNode&gt; succesors;&#125; 经典例题3: Determine whether a binary tree is a complete binary tree Solution: after detecting the first node that misses one child, then check if all following nodes expanded have any node generated (if any, then false) Discussion: When to consider to use BFS? When we want to deal with the node relationship in the same level (Common mistake): BFS1 is NOT the right algorithm to find the shortest path from point A to point B in an arbitrary graph (cost might not be the same). if the edge costs in the graph are all the same (= uniform) then BFS1 can find the shortest path. Best First Search (BFS-2) 经典算法: Dijkstra's Algorithm (runtime efficiency improvement: A * algorithm) Usages: Find the shortest path from a single node (source node) to any other nodes in that graph (点到面(==所有点)的最短距离算法)/ Example problem: 从北京到中国其他所有主要城市的最短距离是多少 Data structure: priority_queue (MIN_HEAP) 解题思路 4.1 Initial state (start node) 4.2 Node expansion/Generation rule: 4.3 Termination condition: 所有点都计算完毕才停止，也就是p_ queue变空 Example image-20200113195544938 initial state: no nodes have been expanded, p_queue = {node(4,0)} process: p_queue.pop(), pop node(4,0) out of the p_queue, expand node(4,0) generate three successors: node(5,10), node(3,1), node(6,1), p_queue = {node(5,10), node(3,1), node(6,1)} tie breaking strategy: random pop node(6,1) generate nothing, p_queue = {node(5,10), node(3,1)} pop node(3,1) generate node(2, cost == parent cost + 1) = (2,2), p_queue = {node(5,10), node(2,2)} pop node(2,2) generate node(5, 2+1) and node(1,2+1), p_queue = {node(5,3), node(1,3)} pop node(5,3), p_queue = {node(1,3)} pop node(1,3), p_queue = {} terminate properties one node can be expanded once and only once one node can be generated more than once. (cost can be reduced over time) all the cost of the nodes that are expanded are monotonically non-decreasing (所 有从priority queue里面pop出来的元素的值是单调非递减 -&gt; 单调递增) time complexity, for a graph with n node is O(nlogn) when a node is popped out for expansion, its value is fixed which is equal to the shortest distance from the start node. 经典考题: (运用Dijkstra's Algorithm的性质) Given a matrix of size NxN, and for each row the elements are sorted in an ascending order, and for each column the elements are also sorted in an ascending order. How to find the k-th smallest element in it? image-20200113211643029 Solution: Initial state: start node = [0] [0] Node expansion/ generation rule: expand [i] [j] generate [i] [j+1] and [i+1] [j] Termination condition: when the k-th element is popped out of the p-queue Analysis: there are totally k nodes to be popped out of the p-queue (= k iterations) for each iteration pop 1 element out of the p-queue (p-queue size &lt; 2k) time = log(2k) generate 2 elements and insert them into the p-queue time = 2log(2k) Total time for each iteration = 3log(2k) Since there are k iterations, the total time = k * 3log(2k) = 3k(log2k) = k log(k) image-20200113213713121 1 2a 2b 3a 3b 3b 3c 4 k= 7 your solution return 3c, correct answer should be 4. The reason is due to the fact that 3b was generated twice! Our question is how to de-duplicate 3b 3b? method1: we can use a hash_ set &lt;pair&lt;x, y&gt;&gt; method2: use another 2D matrix to save if a node is visited or not ##Hash table String Dynamic Programming I End]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2020%2F01%2F09%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[实现用户交互 用户交互就是程序等待用户输入数据之后，在执行下一步的程序，我们使用 input 来完成这个操作。 12name = input('请输入姓名:') # 我把输入的内容赋值给name这个变量print(‘你好’ + name) # 当用户输入完成自己的姓名之后就会打印出来 你好XXX Python2 与Python3 的区别 在python3中 input：用户输入任何值，都存成字符串类型 在python2中 input：用户输入什么类型，就存成什么类型 Python2 中的raw_input：等于python3的input 需要注意的是：当需要输入一个数字的时候，考虑到我们会用这个数字做计算，而Python3的input会默认转成str，所有我们需要把用户输入的数据转化成int 12age = input('请输入年龄')age = int(age) # 把字符串age转化成int类型age用于计算]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2020%2F01%2F08%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim Cheat Sheet vim 多行缩进 按v(或V)进入visual状态，选择多行，用&gt;或&lt;缩进或缩出。]]></content>
  </entry>
  <entry>
    <title><![CDATA[视频单声道转双声道]]></title>
    <url>%2F2020%2F01%2F07%2F%E8%A7%86%E9%A2%91%E5%8D%95%E5%A3%B0%E9%81%93%E8%BD%AC%E5%8F%8C%E5%A3%B0%E9%81%93%2F</url>
    <content type="text"><![CDATA[如果一个视频只有一个声道有声音，如何通过串流让左右声道都能听见声音呢？ 安装ffmpeg 从视频中提取声音 ffmpeg -i video.mp4 -vn a.mp3 单声道混合成双声道 ffmpeg -i a.mp3 -filter_complex channelsplit=channel_layout=stereo out.mka 视频加载外挂声音文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[基础算法]]></title>
    <url>%2F2020%2F01%2F06%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Binary search Search for a Range Search Insert Position Search a 2D Matrix Search a 2D Matrix II First Bad Version Find Peak Element]]></content>
  </entry>
  <entry>
    <title><![CDATA[【CS224n】01 Word Vectors]]></title>
    <url>%2F2020%2F01%2F01%2F%E3%80%90CS224n%E3%80%9101-Word-Vectors%2F</url>
    <content type="text"><![CDATA[dentational semantics]]></content>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】05 笔记总结]]></title>
    <url>%2F2019%2F12%2F31%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9105-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Noisy Channel Model nlpcamp_l5-01 nlpcamp_l5-02 nlpcamp_l5-03 语言模型 nlpcamp_l5-04 nlpcamp_l5-05 nlpcamp_l5-06 nlpcamp_l5-07 nlpcamp_l5-08 nlpcamp_l5-09 nlpcamp_l5-10 nlpcamp_l5-11 nlpcamp_l5-12 nlpcamp_l5-13 nlpcamp_l5-14 nlpcamp_l5-15 nlpcamp_l5-16 nlpcamp_l5-17 nlpcamp_l5-18 评估语言模型：Perplexity nlpcamp_l5-19 nlpcamp_l5-20 nlpcamp_l5-21 nlpcamp_l5-22 nlpcamp_l5-23 平滑方法 nlpcamp_l5-24 nlpcamp_l5-25 nlpcamp_l5-26 nlpcamp_l5-27 nlpcamp_l5-28 nlpcamp_l5-29 nlpcamp_l5-30 nlpcamp_l5-31 nlpcamp_l5-32]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【Python】统计视频总时长]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90Python%E3%80%91%E7%BB%9F%E8%AE%A1%E8%A7%86%E9%A2%91%E6%80%BB%E6%97%B6%E9%95%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import osfrom moviepy.editor import VideoFileClipimport traceback class MovieDirUtil(): def __init__(self,file_dir): self.file_dir = file_dir def get_filesize(self, filename): u""" 获取文件大小（M: 兆） """ file_byte = os.path.getsize(filename) return self.sizeConvert(file_byte) def get_file_times(self, filename): u""" 获取视频时长（s:秒） """ file_time = 0 clip = None try: clip = VideoFileClip(filename) file_time = clip.duration except Exception as e: traceback.print_exc() finally: if clip: clip.close() return file_time def sizeConvert(self, size): # 文件大小单位换算 K, M, G = 1024, 1024 ** 2, 1024 ** 3 if size &gt;= G: return str(size / G) + 'G Bytes' elif size &gt;= M: return str(size / M) + 'M Bytes' elif size &gt;= K: return str(size / K) + 'K Bytes' else: return str(size) + 'Bytes' def timeConvert(self, size): # 时间单位换算 M, H = 60, 60 ** 2 if size &lt; M: return str(size) + u'秒' if size &lt; H: return u'%s分钟%s秒' % (int(size / M), int(size % M)) else: hour = int(size / H) mine = int(size % H / M) second = int(size % H % M) tim_srt = u'%s小时%s分钟%s秒' % (hour, mine, second) return tim_srt def get_all_file(self): u""" 获取目录下下所有的文件 """ file_list = [] for root, dirs, files in os.walk(file_dir): for file in files: # begin #print(os.path.join(root, file)) file_list.append(os.path.join(root, file)) # end return file_list def get_all_file_duration(self): u""" 获取目录下下所有的文件的播放总时长，单位s """ fileList = self.get_all_file() file_duration = 0 for f in fileList: # print(f) print(f, mdu.timeConvert(self.get_file_times(f))) file_duration += self.get_file_times(f) return file_duration if __name__=="__main__": file_dir = u"/Volumes/sed" # 定义目录地址 mdu = MovieDirUtil(file_dir) print("目录里面包含的视频总共时长为：&#123;duration&#125;".format(duration=mdu.timeConvert(mdu.get_all_file_duration())))]]></content>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】04 笔记总结]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9104-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文本的表示 nlpcamp_l4-02 nlpcamp_l4-03 nlpcamp_l4-04 文本的相似度 nlpcamp_l4-05 nlpcamp_l4-06 nlpcamp_l4-07 nlpcamp_l4-08 nlpcamp_l4-09 Tf-idf 文本表示 nlpcamp_l4-10 nlpcamp_l4-11 词向量介绍 nlpcamp_l4-12 nlpcamp_l4-13 nlpcamp_l4-14 nlpcamp_l4-15 nlpcamp_l4-16 nlpcamp_l4-17 nlpcamp_l4-18 nlpcamp_l4-19 生成词向量 nlpcamp_l4-20 nlpcamp_l4-21 nlpcamp_l4-22 nlpcamp_l4-23 nlpcamp_l4-24 nlpcamp_l4-25 问答系统回顾 nlpcamp_l4-26 nlpcamp_l4-27 nlpcamp_l4-28 倒排表 nlpcamp_l4-29]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2019%2F12%2F29%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[本文是学习Java入门与基础算法（任课教师：林平之）的总结学习笔记。 如果有不会的算法题，请参考题解:smiley: 第二讲 变量，数组和循环(Java基础 I) 变量 ASCII &amp; Unicode编码 字符 对应整数 0 48 A 65 a 97 123456// 小写转大写，避免hard codechar a = 'a';System.out.println((char)(a - 'a' + 'A'));// 或者直接调用写好的函数Character.toUpperCase(a); 数组 Array 数组 用一个变量来表示一组连续的相同类型的变量。 1234567891011// 定义方式1int[] array = new int[] &#123;90, 95, 92, 89, 100, 98&#125;;// 定义方式2int[] array2 = new int[6];array2[0] = 90;array2[1] = 95;array2[2] = 92;array2[3] = 89;array2[4] = 100;array2[5] = 98; 二维数组和多维数组 123456789// 定义方式1int[][] matrix = new int[][] &#123; &#123;1, 4, 7, 10&#125;, &#123;2, 6, 12, 15&#125;, &#123;6, 8, 13, 20&#125;&#125;;// 定义方式2int[][] matrix2 = new int[3][4]; 程序的三大结构 顺序结构 控制结构 循环结构 控制结构 12345678910111213// max number of 3 numbersint a = 10, b = 20, c = 15;int max = a;if (b &gt; max) &#123; max = b;&#125;if (c &gt; max) &#123; max = c;&#125;System.out.println(max); 循环结构 12345678910111213141516// 找第二大的数int[] arr = new int[] &#123;90, 95, 92, 89, 100, 98&#125;;int len = array.length;int max = 0;int sMax = 0;// 1[ ], 2[ ]for (int i = 0; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; sMax = max; max = arr[i]; &#125; else if (sMax &lt; arr[i]) &#123; sMax = arr[i] &#125;&#125;System.out.println(max);System.out.println(sMax); 1234567891011// 遍历二维数组int[][] matrix = new int[][] &#123; &#123;1, 4, 7&#125;, &#123;2, 6&#125;, &#123;6, 8, 13, 20&#125;&#125;;for (int i = 0; i&lt; matrix.length; ++i) &#123; for (int j = 0; j&lt; matrix[i].length; ++j) &#123; System.out.println(matrix[i][j]); &#125;&#125; 12345// loopint[] array = new int[] &#123;1, 2, 4&#125;;for (int num: array) &#123; System.out.println(num);&#125; 第三讲 字符串，函数，类和对象(Java基础 II) String及其常用操作 1234567891011121314151617181920212223242526272829303132333435// 字符串的长度String a = "hello";String b = new String("hello");System.out.println(a.length());// 字符串的遍历// 1for (int i = 0; i &lt; a.length(); ++i) &#123; System.out.println(a.charAt(i));&#125;// 2char[] chars = new char[] &#123;'h', 'e', 'l', 'l', 'o'&#125;;for (char c: a.toCharArray()) &#123; System.out.println(c);&#125;// 字符串的运算:连接String str = "My name is";str += " Guojing"; // str: "My name is Guojing"int age = 18;str = "I am " + age + " years old"; // str: "I am 18 years old"// 字符串 子串的查找indexOf (返回子串作为位置的下标。)String source = "jiuzhang";int index = source.indexOf("zhang"); System.out.println(index);// 字符串的比较(大部分情况都是用方法比较内容的)String a = "hello";String b = new String("hello");String c = "hello";String d = new String("hello");System.out.println(a == b); // false,不是指向同一个对象System.out.println(a.equals(b); // true,同一个内容System.out.println(a == c); // true,指向同一个对象,常量表 System.out.println(b == d); // false,new创建了两个对象 LintCode: Valid Palindrome 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /** * @param s: A string * @return: Whether the string is a valid palindrome */ public boolean isPalindrome(String s) &#123; // write your code here if (s == null || s.length() == 0) &#123; return true; &#125; int left = 0; int right = s.length() - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; !isValid(s.charAt(left))) &#123; left++; &#125; while (left &lt; right &amp;&amp; !isValid(s.charAt(right))) &#123; right--; &#125; if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123; return false; &#125; else &#123; left++; right--; &#125; &#125; return true; &#125; public boolean isValid(char c) &#123; return Character.isLetter(c) || Character.isDigit(c); &#125;&#125; 函数 image-20191228111006457 类和对象 Lecture_3_Java_Basic_II_20170709-23 Lecture_3_Java_Basic_II_20170709-24 Lecture_3_Java_Basic_II_20170709-25 Lecture_3_Java_Basic_II_20170709-26 Lecture_3_Java_Basic_II_20170709-27 Lecture_3_Java_Basic_II_20170709-28 Lecture_3_Java_Basic_II_20170709-29 Lecture_3_Java_Basic_II_20170709-30 Lecture_3_Java_Basic_II_20170709-31 Lecture_3_Java_Basic_II_20170709-32 Lecture_3_Java_Basic_II_20170709-33 Lecture_3_Java_Basic_II_20170709-35 image-20191228135641121 image-20191228135917559 image-20191228135954662 LintCode: Student ID(Design a Student class) Description Implement a class Class with the following attributes and methods: A public attribute students which is an array of Student instances. A constructor with a parameter n, which is the total number of students in this class. The constructor should create n Student instances and initialized with student id from 0 ~ n-1 Example 1234567891011Java: Class cls = new Class(3) cls.students[0]; // should be a student instance with id = 0 cls.students[1]; // should be a student instance with id = 1 cls.students[2]; // should be a student instance with id = 2Python: cls = new Class(3) cls.students[0] # should be a student instance with id = 0 cls.students[1] # should be a student instance with id = 1 cls.students[2] # should be a student instance with id = 2 Solution Java: 123456789101112131415161718class Student &#123; public int id; public Student(int id) &#123; this.id = id; &#125;&#125;public class Class &#123; public Student[] students; // 声明Student类型数组，即创建一个引用 public Class(int n) &#123; this.students = new Student[n]; // 创建Student类型数组，将引用（students）指向此数组 for (int i = 0; i &lt; n; ++i) &#123; students[i] = new Student(i); &#125; &#125;&#125; Python: 12345678910111213141516class Student: def __init__(self, id): self.id = id;class Class: ''' * Declare a constructor with a parameter n which is the total number of * students in the *class*. The constructor should create n Student * instances and initialized with student id from 0 ~ n-1 ''' # write your code here def __init__(self, n): self.students = [] for i in range(n): self.students.append(Student(i)) LintCode: Student Level Description Implement a class Student, including the following attributes and methods: Two public attributes name(string) and score(int). A constructor expect a name as a parameter. A method getLevel to get the level(char) of the student. score – level table: A: score &gt;= 90 B: score &gt;= 80 and &lt; 90 C: score &gt;= 60 and &lt; 80 D: score &lt; 60 Example 12345678910111213Java: Student student = new Student(&quot;Zuck&quot;); student.score = 10; student.getLevel(); // should be &apos;D&apos; student.score = 60; student.getLevel(); // should be &apos;C&apos;Python: student = Student(&quot;Zuck&quot;) student.score = 10 student.getLevel() # should be &apos;D&apos; student.score = 60 student.getLevel() # should be &apos;C&apos; Solution: 123456789101112131415161718192021## Basic Ideas:## Complexity: Time O(1), Space O(1)class Student: ''' * Declare a constructor expect a name as a parameter. ''' # write your code here def __init__(self, name): self.name = name self.score = 0 ''' * Declare a public method `getLevel` to get the level(char) of this student. ''' # write your code here def getLevel(self): if self.score &gt;= 90: return 'A' if self.score&gt;=80 and self.score&lt;90: return 'B' if self.score&gt;=60 and self.score&lt;80: return 'C' return 'D' 推荐阅读 Object-Oriented Design Problems LEETCODE COMMON TEMPLATES 第四讲 Reference LinkedList 引用 &amp; 链表 引用 Reference 对象去哪儿了? 1ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); intList不是对象本身，是对象的引用 new出来的对象，存储在堆空间(heap space)上 堆空间 heap space 栈空间 stack space 注意区别于数据结构的heap &amp; stack 引用的赋值 12Student student1 = new Student(&quot;Jack&quot;);Student student2 = new Student(&quot;Rose&quot;); new出来两个对象 student1和student2是这两个对象的引用 演示对比 int 和 IntegerWrapper Ps: int, double等都是基础类型 IntegerWrapper对象作为函数参数 对比Increment(int) 和 Increment(IntegerWrapper) 12345678910111213141516171819202122232425262728class IntegerWrapper &#123; public int value; public IntegerWrapper(int val) &#123; value = val; &#125; &#125;public class Main &#123; public static void increment(int a) &#123; a++; &#125; public static void increment(IntergerWrapper intW) &#123; intW.value++; // 指向同一个对象，可以修改 &#125; public static void main(String[] args) &#123; int a = 10; IntegerWrapper intW = new IntegerWrapper(10); increment(a); increment(intW); System.out.println("a: " + a); System.out.println("intW.value: " + inW.value); &#125;&#125; image-20191229125632239 12345678910111213141516171819202122232425262728class IntegerWrapper &#123; public int value; public IntegerWrapper(int val) &#123; value = val; &#125;&#125;public class Main &#123; public static void increment(int a) &#123; a++; &#125; public static void increment(IntegerWrapper intW) &#123; intW = new IntegerWrapper(20); // 指向新创建的对象 &#125; public static void main(String[] args) &#123; int a = 10; IntegerWrapper intW = new IntegerWrapper(10); increment(a); increment(intW); System.out.println("a: " + a); System.out.println("intW.value: " + intW.value); &#125;&#125; image-20191229144920273 原因分析： image-20191229145002330 总结 传递引用 修改引用所指向对象的数据，修改引用没有任何效果(举例) 引用的好处与用处 引用也存的是数据，存的是指向这个对象的地址 使得数据更加的整齐 需要传递引用去修改数据 什么是null 空的引用，没有引用任何对象。 1234ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list = null; // list变成了空引用list.add(1); // NullPointerException 引用中的NULL值问题 Student ID问题: http://www.lintcode.com/en/problem/student-id/ Note:构造一个Student的数组，对象数组(非基础类型的数组)new出来后， 每个对象都是NULL 链表 Linked List 什么是数据结构(data structure) ● 数据 ○ 存储数据的功能 ● 结构 ○ 如何组织排列存储的数据 ● 操作 ○ 如何查询，添加，删除维护存在的数据 什么是链表(linked list) 由节点构成的列表 线性的数据结构 1234class ListNode &#123; public int val; public ListNode next;&#125; image-20191229153329531 哨兵节点 不得不提的dummy Node:伟大的哨兵节点: dummyNode -&gt; null 作用(前驱节点的重要性): 使得每一个元素都有前驱节点 (好处：操作一致，程序逻辑更简单，容易找到头结点) Coding:基于ListNode实现一个Linked List LinkedList Class的接口: 读取操作 get(location) // 获取location位置上的node的value 查找操作 contains(val) // 判断链表中是否含有val值的node 插入操作 add(location, val) // 在location的位置上插入一个值为val的node 删除操作 remove(location) // 删除location位置上的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ListNode &#123; public int val; public ListNode next; public ListNode(int value) &#123; this.val = value; &#125;&#125;// Location 0 是dummy的下一个节点public class LinkedList &#123; ListNode dummy; public LinkedList() &#123; dummy = new ListNode(-1); // dummy.next = null; &#125; public int get(int location) &#123; ListNode cur = dummy.next; for (int i = 0; i &lt; location; ++i) &#123; cur = cur.next; &#125; return cur.val; &#125; public boolean contains(int val) &#123; ListNode head = dummy.next; while (head != null) &#123; if (head.val == val) &#123; return true; &#125; head = head.next; &#125; return false; &#125; public void add(int location, int val) &#123; ListNode pre = dummy; for (int i = 0; i &lt; location; ++i) &#123; pre = pre.next; &#125; ListNode node = new ListNode(val); node.next = pre.next; pre.next = node; &#125; public void remove(int location) &#123; ListNode pre = dummy; for (int i = 0; i &lt; location; ++i) &#123; pre = pre.next; &#125; pre.next = pre.next.next; &#125; public void print() &#123; ListNode head = dummy.next; while (head != null) &#123; System.out.println(head.val + "-&gt;"); head = head.next; &#125; System.out.println("null"); &#125;&#125; 时间复杂度对比 操作 ArrayList LinkedList Add/Remove at end O(1) O(1) Add/Remove at begin O(n) O(1) Add/Remove at any where O(n) O(n) Add/Remove at specified place O(n) O(1) Read/Find By position O(1) O(n) Read/Find By target (value) O(n) O(n) 小练习 在排序的链表中插入一个Node 翻转一个链表 删除链表中倒数第N个元素 第五讲 栈和队列 Stack &amp; Queue 栈 Stack 学习目标 implement a stack ○ http://www.lintcode.com/en/problem/implement-stack/ valid parentheses ○ http://www.lintcode.com/en/problem/valid-parentheses/ 什么是栈(stack) 栈是一种后进先出(last in first out，LIFO)的线性数据结构 栈的操作 push pop peek (getTop) isEmpty image-20191230205927164 栈的实现 ArrayList push —&gt; add pop —&gt; remove LinkedList(推荐) ArrayList不适合用来实现栈，动态数组的copy数据操作复杂度较大，remove元素时不会马上削减size，而是要等到一定程度时，而栈是伸缩的一种数据结构，会增长也会减小，在一些特殊情况会频繁的resize，所以不适合用来实现栈。 12345678910111213141516171819202122232425262728293031// ArrayList实现的栈class StackImpArrayList &#123; private List&lt;Integer&gt; array; public StackImpArrayList() &#123; array = new ArrayList&lt;Integer&gt;(); &#125; // Push a new item into the stack public void push(int val) &#123; array.add(val); &#125; // Pop the top of the stack public int pop() &#123; int size = array.size(); return array.remove(size - 1); &#125; // Return the top of the stack public int peek() &#123; int size = array.size(); return array.get(size - 1); &#125; // Check the stack is empty or not. public boolean isEmpty() &#123; return array.isEmpty(); &#125;&#125; pop操作如何实现？ 一般情况下是 dummy -&gt; 20 -&gt;10 -&gt; null dummy.next为栈底，这样pop时复杂度为O(N)， 在这里实现为 dummy -&gt; 10 -&gt;20 -&gt; null dummy.next设为栈顶，这样pop时复杂度为O(1)。 123456789101112131415161718192021222324252627282930313233343536373839// LinkedList实现的栈class Node &#123; public int val; public Node next; public Node(int value) &#123; this.val = value; &#125;&#125;class StackImpListNode &#123; private Node dummy; public StackImpListNode() &#123; dummy = new Node(-1); &#125; public void push(int val) &#123; Node node = new Node(val); node.next = dummy.next; dummy.next = node; &#125; public int pop() &#123; int ele = dummy.next.val; dummy.next = dummy.next.next; return ele; &#125; public int peek() &#123; int ele = dummy.next.val; return ele; &#125; public boolean isEmpty() &#123; return dummy.next == null; &#125;&#125; LintCode: valid parentheses 12345678910111213141516171819202122232425262728293031public class Solution &#123; /** * @param s A string * @return whether the string is a valid parentheses */ public boolean isValidParentheses(String s) &#123; // Write your code here Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) &#123; if (c == '(' || c == '[' || c == '&#123;') &#123; stack.push(c); &#125; if (c == ')') &#123; if (stack.isEmpty() || stack.pop() != '(') &#123; return false; &#125; &#125; if (c == ']') &#123; if (stack.isEmpty() || stack.pop() != '[') &#123; return false; &#125; &#125; if (c == '&#125;') &#123; if (stack.isEmpty() || stack.pop() != '&#123;') &#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125; 一般对栈操作前都要先判栈非空 队列(queue) 学习目标 Implement a queue 实现队列 * 通过ArrayList实现queue (不可以) * 通过LinkedList实现queue * 通过自定义的ListNode实现queue 什么是队列(queue) 队列是一种先进先出(first in first out，FIFO)的线性数据结构 队列的操作 enqueue dequeue peek (getHead) isEmpty image-20191231004257760 队列操作的实现细节 基于ListNode的queue image-20191231143239148 Enqueue 插入一个Value-10 1. 创建一个value为10的node 2. 把新创建的Node放入List的尾部 Dequeue 取出队列头部元素的值 image-20191231143517466 得到Head指向的ListNode的Value1 Head往后移动来到下一个ListNode 返回1这个值 isEmpty 判断对列为空 image-20191231143727279 法一：判断Head是否指向NULL 法二：判断Head是否等于Tail 重点：当对列在只有一个元素进行dequeue操作时，因为两个引用进行操作的时候会有不一致的情况，这时一定要手动改变Tail指针的指向，使得两个引用指向一致。 队列的实现 123456789101112131415161718192021222324252627282930313233343536373839class QueueNode &#123; public int val; public QueueNode next; public QueueNode(int value) &#123; val = value; &#125;&#125;public class Queue &#123; private QueueNode dummy, tail; public Queue() &#123; dummy = new QueueNode(-1); tail = dummy; &#125; public void enqueue(int val) &#123; QueueNode node = new QueueNode(val); tail.next = node; tail = node; &#125; // 两个引用进行操作的时候会有不一致的情况 public int dequeue() &#123; int ele = dummy.next.val; dummy.next = dummy.next.next; if (dummy.next == null) &#123; tail = dummy; // reset &#125; return ele; &#125; public int peek() &#123; int ele = dummy.next.val; return ele; &#125;&#125; 队列的应用 Message queue 消息队列 BFS 广度优先搜索 LintCode:Implement Queue by Interface 待做 优先级队列 40. Implement Queue by Two Stacks 955. Implement Queue by Circular Array Implement Queue by Linked List Java集合之List(ArrayList、LinkedList、Vector、Stack) 第六讲 树和递归 Tree &amp; Recursion 树 Tree 由节点(node)组成 每个节点有零个或多个子 节点(child node) 没有父节点的是根节点(root node) 每个非根节点只有一个父节点(parent node) 一棵树中，只有一个root node image-20191231194545850 二叉树 Binary Tree 每个节点最多有两个子节点 两个子节点分别被称为左孩子(left child)和右孩子(right child) 叶子节点：没有孩子节点的节点 子树(sub-tree) 树中的每个节点代表以它为根的一棵树 左孩子所代表的树成为左子树(left sub-tree) 右孩子所代表的树成为右子树(right sub-tree) 树结构举例 文件系统 B+树 数据库的索引-第七节课 字典树，平衡树等 - 高级数据结构 剖析LintCode TreeNode 12345678public class TreeNode &#123; public int val; public TreeNode left, right; public TreeNode(int val) &#123; this.val = val; this.left = this.right = null; &#125;&#125; TreeNode类 left和right分别对应左右子节点 val表示node的值 递归 Recursion 什么是递归 (Recursion)? 数据结构的递归 树就是一种递归的数据结构 算法(程序)的递归 函数自己调用自己 递归三要素 递归的定义 首先这个问题或者数据结构得是递归定义的 递归的出口 什么时候递归终止 递归的拆解 递归不终止的时候，如何分解问题 Coding 打印出一个树的中序遍历 12345678public static void print(TreeNode root) &#123; if (root == null) &#123; return; &#125; print(root.left); System.out.println(root.val + " "); print(root.right);&#125; 学习目标 获取所有叶子节点的和 Get leaf sum 获取树的高度 Get tree height 获取所有root到叶子节点的路径 Get root-to-leaf paths LintCode:Binary Tree Leaf Sum Recursion 获取叶子节点的和 访问一个Node: 如果这个Node是叶子节点，则sum就是他本身 如果这个Node不是叶子节点，则sum等于左子树的叶子节点和 + 右子树之和 image-20191231204721224 123456789101112131415161718public class Solution &#123; /* * @param root: the root of the binary tree * @return: An integer */ public int leafSum(TreeNode root) &#123; // write your code here if(root == null)&#123; return 0; &#125; if(root.left == null &amp;&amp; root.right == null)&#123; return root.val; &#125; return leafSum(root.left) + leafSum(root.right); &#125;&#125; LintCode:Maximum Depth of Binary Tree 为什么函数调用了2n + 1次？ 因为每一个节点有左右两个指针，n个节点共有2n个链域，而n个节点只需用n-1个指针就可互连（因为连接n个点只需n-1条直线），所以还剩下2n-(n-1)=n+1个空指针域，n个节点和n+1个空指针域一共为2n+1个，所以函数调用了2n + 1次。 LeetCode:Binary Tree Paths Recursion 获取树中root到leaf的所有路径 &lt;img src=&quot;Java基础/5EF034508409D2F51C9B60FA385B2C63.jpg&quot; &gt; 比如，对于上面这个二叉树，它所有的路径为： 8 -&gt; 3 -&gt; 1 8 -&gt; 2 -&gt; 6 -&gt; 4 8 -&gt; 3 -&gt; 6 -&gt; 7 8 -&gt; 10 -&gt; 14 -&gt; 13 1234567891011121314151617181920class Solution &#123; public void construct_paths(TreeNode root, String path, LinkedList&lt;String&gt; paths) &#123; if (root != null) &#123; path += Integer.toString(root.val); if ((root.left == null) &amp;&amp; (root.right == null)) // 当前节点是叶子节点 paths.add(path); // 把路径加入到答案中 else &#123; path += "-&gt;"; // 当前节点不是叶子节点，继续递归遍历 construct_paths(root.left, path, paths); construct_paths(root.right, path, paths); &#125; &#125; &#125; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; LinkedList&lt;String&gt; paths = new LinkedList(); construct_paths(root, "", paths); return paths; &#125;&#125; LintCode: Identical Binary Tree 12345678910111213141516public class Solution &#123; /** * @param a, b, the root of binary trees. * @return true if they are identical, or false. */ public boolean isIdentical(TreeNode a, TreeNode b) &#123; // Write your code here if (a == null &amp;&amp; b == null) return true; if (a != null &amp;&amp; b != null) &#123; return a.val == b.val &amp;&amp; isIdentical(a.left, b.left) &amp;&amp; isIdentical(a.right, b.right); &#125; return false; &#125;&#125; LintCode 树的遍历问题 Binary Tree Preorder Traversal http://www.lintcode.com/en/problem/binary-tree-preorder-traversal/ Binary Tree Inorder Traversal http://www.lintcode.com/en/problem/binary-tree-inorder-traversal/ Binary Tree Postorder Traversal http://www.lintcode.com/en/problem/binary-tree-postorder-traversal/ 第七讲 二叉搜索树与哈希表 BST Hash table 本节重点 BST (Binary Search Tree)及其常用操作 二分和分治 BST的应用:实现集合 BST的应用:实现索引 Hash Table 及其常见操作 二叉搜索树 Binary Search Tree 学习目标 在BST中插入一个节点 Insert node into BST 在BST中搜索一个值为Value的节点 Search BST 什么是BST (Binary Search Tree) 满足以下性质的binary tree: 对于每个节点，他的左子树的所有节点都比它小 对于每个节点，他的右子树的所有节点都比它大 以上是严格的说法，不允许BST有重复的节点，实际算法中可以允许重复 BST的常用操作 Insert: Time/space complexity O(h) image-20200104160118595 递归实现 12345678910111213141516171819public class Solution &#123; /* * @param root: The root of the binary search tree. * @param node: insert this node into the binary search tree * @return: The root of the new binary search tree. */ public TreeNode insertNode(TreeNode root, TreeNode node) &#123; // write your code here if (root == null) &#123; return node; &#125; if (root.val &lt; node.val) &#123; root.right = insertNode(root.right, node); &#125; else &#123; root.left = insertNode(root.left, node); &#125; return root; &#125;&#125; 非递归实现 1234567891011121314151617181920212223242526272829303132public class Solution &#123; /* * @param root: The root of the binary search tree. * @param node: insert this node into the binary search tree * @return: The root of the new binary search tree. */ public TreeNode insertNode(TreeNode root, TreeNode node) &#123; // write your code here TreeNode father = null; TreeNode cur = root; while (cur != null) &#123; father = cur; if (cur.val &lt; node.val) &#123; cur = cur.right; &#125; else &#123; cur = cur.left; &#125; &#125; if (root == null) &#123; return node; &#125; if (node.val &lt; father.val) &#123; father.left = node; &#125; else &#123; father.right = node; &#125; return root; &#125;&#125; Search/Find: Time/space complexity O(h) h是树的高度 Best case log2n (or logn), worst case n. 递归实现 非递归实现 (while loop) 实战例题 Validate Binary Search Tree http://www.lintcode.com/en/problem/validate-binary-search-tree/ http://www.jiuzhang.com/solutions/validate-binary-search-tree/ 题目：验证一棵二叉树是二叉搜索树 Example: 123456789Input: &#123;2,1,4,#,#,3,5&#125;Output: trueFor the following binary tree: 2 / \ 1 4 / \ 3 5This is a binary search tree. 分析: 什么样的二叉树是二叉搜索树呢? 左子树是二叉搜索树 右子树是二叉搜索树 左子树最大值 &lt; 该节点的值 &lt; 右子树最小值 Tips: 函数需要返回多个值的时候，用一个类封装起来 image-20200105113929654 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition of TreeNode: * public class TreeNode &#123; * public int val; * public TreeNode left, right; * public TreeNode(int val) &#123; * this.val = val; * this.left = this.right = null; * &#125; * &#125; */class ResultType &#123; public boolean isBst; public long minValue, maxValue; public ResultType(long minValue, long maxValue, boolean isBst) &#123; this.minValue = minValue; this.maxValue = maxValue; this.isBst = isBst; &#125;&#125;public class Solution &#123; /** * @param root: The root of binary tree. * @return: True if the binary tree is BST, or false */ public boolean isValidBST(TreeNode root) &#123; // write your code here ResultType result = validHelper(root); return result.isBst; &#125; public ResultType validHelper(TreeNode node) &#123; if (node == null) &#123; return new ResultType(Long.MAX_VALUE, Long.MIN_VALUE, true); // 解释如上图所示 &#125; ResultType left = validHelper(node.left); ResultType right = validHelper(node.right); if (!left.isBst || !right.isBst) &#123; return new ResultType(-1, -1, false); &#125; boolean isBst = left.maxValue &lt; node.val &amp;&amp; node.val &lt; right.minValue; return new ResultType( left.minValue, // 返回最小值 right.maxValue, // 返回最大值 isBst); &#125;&#125; 递归与分治法 Recursion &amp; Divide and Conquer 分治法(divide and conquer)步骤 将大问题分成多个独立的小问题 分别解决每个小问题 (小问题和大问题是同一类问题，所以可以用递归算法) 将小问题的解合并，从而得到大问题的解 树类题目算法总结 遍历 Traversal 递归 Recursion 二叉搜索树 Binary Search Tree 哈希表 Hash table 学习目标 用BST实现集合 Implement set using BST 用BST实现检索 Implement index using BST 用Hash table实现检索 Implement index using hash table 什么是集合 Set 集合Set: 存储一些没有重复元素的数据 Java内部有一个Interface Set 基于这个实现的Class有 TreeSet =&gt; 基于Tree实现的Set HashSet =&gt; 基于Hash Table实现的Set 集合 Set Set有的两个方法: add(element) 增加一个元素 contains(element) 集合内是否包含这个元素 基于BST实现的Set add(element) =&gt; 对应BST的Insert操作 contains(element) =&gt; 对应BST的Search操作 检索 Index 简单来说index就是: 映射map 字典 dictionary key-value对 key-value pairs map: key -&gt; value set: value -&gt; value Index在数据库Database中的应用 以下是数据库中的一个表:我们需要查询Jack的年龄 id name / string age / int score / int 1 “Jack” 12 90 2 “Tom” 13 89 3 “Alex” 12 95 4 “Lucy” 11 78 正常情况下，我们需要扫描数据库中这个table内的所有记录，找到其中一条记录name为Jack，然后我们读取出这条记录中的age(全表扫描) 简单的认为时间复杂度 O(n) 建立索引加速查询: 建立 name -&gt; id 的映射: Returns student id given student name. Returns very fast, faster than O(n) 12index.get(“Alex”); // returns 3index.get(“Lucy”); // returns 4 拆分这个Query如下: 找到对应的student id在我们建立的Index中根据student name ‘Alex’ 根据Student id，我们将很容易的读取到这条记录 整个Query的时间将取决于第一步操作。 如何实现索引Index 有两种实现方式: Using BST =&gt; TreeMap Using Hash table =&gt; HashMap 实现Index(map)的3个方法 put(key, value) =&gt; 设置key对应的value get(key) =&gt; 读取key对应的value containsKey(key) =&gt; 判断对应的key是否在map中存在 使用BST实现Index 123456789public class TreeNode &#123; public TreeNode left, right; public int key, value; public TreeNode(int key, int value) &#123; left = right = null; this.key = key; this.value = value; &#125; &#125; Note: 对TreeNode进行扩展，原来我们只存储val一个值 ，现在我们存储key，value一对值，根据key形成BST树 ，这样就可以通过key找到对应的TreeNode从而读取出 value 使用Hash Table实现Index Hash Table的两种实现方式: 开散列: open hashing，也称为拉链法，separate chaining 闭散列: closed hashing，也称为开地址方法，open addressing 开散列: 开辟一个数组 数组的每一个元素是一个链表的头结点的引用 初始状态数组每个元素对应的链表为空链表 image-20200105155803209 开散列: put(key, value) 创建一个ListNode(包含key&amp;Value) 根据hash函数，计算key对应的index下标 把这个ListNode插入到index下标对应的LinkedList中 开散列 put(key, value) =&gt; put(10, 20) 距离hash函数为 h(key) = key % 5 = 0 插入到0对应的LinkedList中 image-20200105160010013 开散列 get(key) =&gt; get(10) 距离hash函数为 h(key) = key % 5 = 0 遍历0对应的LinkedList，找到对应key为10的ListNode，读出Value值 image-20200105160143279 开散列 contains(key) =&gt; containsKey(10) 距离hash函数为 h(key) = key % 5 = 0 遍历0对应的LinkedList，检测这个LinkedList中是否有key为10的Node 闭散列: 开辟一个数组，一个位置只放一个Node(Node包含key&amp;Value) 根据Hash函数h(key)，计算出index下标将这个Node放入这个数组 如果这个位置已经有了元素，则顺序往后查找直到找到一个空位置可以放下 如何使用Java中的HashMap 12345678Map&lt;Integer, Character&gt; mp = new TreeMap&lt;Integer, Character&gt;();Map&lt;Integer, Character&gt; mp2 = new HashMap&lt;Integer, Character&gt;();mp2. put(10, 'c');mp2.put(20, 'd');System.out.println(mp2.get(10));System.out.println(mp2.containsKey(30)); image-20200105160737399 HashMap的使用 实战例题 Count Characters http://www.lintcode.com/en/problem/count-characters/ http://www.jiuzhang.com/solution/count-characters/ 1234567891011121314public class Solution &#123; /* * @param : a string * @return: a hash map */ public Map&lt;Character, Integer&gt; countCharacters(String str) &#123; // Write your code here Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); for (char c : str.toCharArray()) &#123; map.put(c, map.getOrDefault(c, 0) + 1); &#125; return map; &#125;&#125;; Mirror Numbers http://www.lintcode.com/en/problem/mirror-numbers/ http://www.jiuzhang.com/solution/mirror-numbers/ 1234567891011121314151617181920212223242526// 将倒过来能看成数字的数字哈希一下，就能进行转换判断了。public class Solution &#123; /** * @param num: a string * @return: true if a number is strobogrammatic or false */ public boolean isStrobogrammatic(String num) &#123; // write your code here Map&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); map.put('6', '9'); map.put('9', '6'); map.put('0', '0'); map.put('1', '1'); map.put('8', '8'); int i = 0; int j = num.length() - 1; while(i &lt;= j) &#123; if(!map.containsKey(num.charAt(i)) || map.get(num.charAt(i)) != num.charAt(j)) &#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; BST v.s. Hash table Hash table的时间复杂度 如果是Integer等类型插入，查找和删除操作都是O(1)时间 如果是String类型插入，查找和删除操作都是O(len)时间 Hash Table空间消耗大 Binary Seach Tree 支持有序的数据，排序和范围查找性能优秀(对于balanced BST是O(logn))，空间消耗相对较小 线程不安全 hashmap 线程安全 hashtable]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】03 笔记总结]]></title>
    <url>%2F2019%2F12%2F27%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9103-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview nlpcamp_l3-02 nlpcamp_l3-03 分词 nlpcamp_l3-04 nlpcamp_l3-05 最大匹配算法 正向最大匹配法 分词目标： 在词典中进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 算法流程： 假设词典中最长的单词为 5 个（MAX_LENGTH），那么最大匹配的起始子串字数也为 5 个 扫描字典，测试读入的子串是否在字典中 如果存在，则从输入中删除掉该子串，重新按照规则取子串，重复 1 如果不存在于字典中，则从右向左减少子串长度，重复1 nlpcamp_l3-06 贪心算法：选择当前最优解 DP：选择全局最优解 max-len通常为5~10 可以根据单词长度的不同做一个分析已选择最合适的max-len。 逆向最大匹配法 分词目标： 在词典中进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 在实践中，逆向最大匹配算法性能优于正向最大匹配算法。 算法流程： 假设词典中最长的单词为 5 个（MAX_LENGTH），那么最大匹配的起始子串字数也为 5 个 扫描字典，测试读入的子串是否在字典中 如果存在，则从输入中删除掉该子串，重新按照规则取子串，重复 1 如果不存在于字典中，则从左向右减少子串长度，重复 1 nlpcamp_l3-07 90%情况前向和后向分词结果相同，10%不同。如南京市长江大桥 最大匹配缺点 细分可能更优 局部最优 没有考虑语义(单词-&gt;syntactic-&gt;semantic) nlpcamp_l3-08 考虑语义模型(LM) nlpcamp_l3-09 nlpcamp_l3-10 Unigram Language Model语言模型选择所有分割情况中最好的 通过统计的方式写出每个单词出现的概率 给定一个句子分词后可以用联合概率算出的概率用作评判是否符合语义的标准 nlpcamp_l3-22 计算时取对数防溢出 nlpcamp_l3-21 生成组合太多，算法复杂度过高，解决方法使用维特比算法 维特比算法 nlpcamp_l3-11 nlpcamp_l3-12 伪代码 nlpcamp_l3-20 数学公式 nlpcamp_l3-19 9E038A12ECCE3D003FAA2C06F6B311F9 分词算法总结 nlpcamp_l3-13 拼写错误纠正 nlpcamp_l3-14 两种错误情况： 错别字 不是错别字，不适合 nlpcamp_l3-15 计算编辑距离（DP算法）三种操作： insert delete replace 然后再在编辑距离最小的之中根据上下文，词频选择一个 nlpcamp_l3-16 nlpcamp_l3-17 QQ20191230-164446 QQ20191230-164600 QQ20191230-164649 一个独立的问题 QQ20191230-164912 停用词过滤 QQ20191230-164950 QQ20191230-165228 Stemming操作 QQ20191230-165347 QQ20191230-165503 推荐阅读 分词中的最大匹配算法 DP经典练习题]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[待看]]></title>
    <url>%2F2019%2F12%2F27%2F%E9%87%8D%E7%82%B9%E5%BE%85%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[hc101-来offer 2017 sde 夏季1班 不全 hc102-来offer 2017 sde ?季班 全 hc201-九章 OOD hc202-九章 动态规划 hc203-九章 bat hc204-九章 算法高频v1.0 hc301-cs221 重点待看 Stanford ai cs109 cs106a/b cs221 cs229 cs124 cs276 cs224 cs230 6.006 6.046 fast.ai 弱待看 来offer 极客时间 Python核心技术与实战 刘宇波 邓俊辉(邓公算法课) 左程云 哈工大算法 cs61a cs61b cs107 加 kaggle 数学 statistics 110 18.01 18.02 18.03 18.065 数学分析 陈纪修 OS 经典书籍 名人刷题记录 小土刀 Byvoid CS-Notes OI 自学nlp Sanny Kim nlpprogress 贪心nlp课程大纲 nine chapter https://lintcode-solutions.gitbook.io/project/jiuzhang-courses/binary-search https://stomachache007.wordpress.com/2017/03/07/414/ https://www.cnblogs.com/Raising-Sun/ https://marian5211.github.io/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/ https://medium.com/@derekfan 博客 http://zecong.hu/ https://www.hankcs.com/about/ Phoebe Bridgers http://www.ai-start.com/dl2017/html/README.html 可以参考 网易微专业-AI工程师 自然语言处理的syllabus https://blog.csdn.net/longxinchen_ml/article/list/1 https://www.shangyexinzhi.com/article/details/id-384942/ https://zhuanlan.zhihu.com/p/100295074 C2BA723F96401EC40981AF13ED386AAF 以斯坦福计算机学院的人工智能专业为例，其课程设置如下: • 数学 • 计算机数据基础（课程代码：CS103） • 计算机概率基础（课程代码：CS109） • 科学 • 机械学 • 电磁学 • 工程学 • 编程导论（课程代码：CS106） • 人工智能核心课 • 计算机组织和系统（课程代码：CS107/107E） • 计算机系统原理（课程代码：CS110） • 算法的设计和分析（课程代码：CS161） • 人工智能选修课 • 人工智能：原理和技术（课程代码：CS221） • AI方法（课程代码：CS 228, 229, 234, 238，157, 205L, 230, 236等） • 自然语言处理（课程代码：CS 124, 224N，224S，224U） • 视觉（课程代码：CS 131, 231A, 231N） • 机器人和控制（课程代码：CS 223A） 作者：AI传道士 链接：https://www.zhihu.com/question/325630634/answer/703914639 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2281596114051@qt077.cc密码INZbuq859Ts]]></content>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】02 笔记总结]]></title>
    <url>%2F2019%2F12%2F26%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9102-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview nlpcamp_l2-01 nlpcamp_l2-02 算法复杂度 这是任何AI工程师必须要深入理解的概念。对于每一个设计出来的算法都需要从这两个方面来分析。 例子1 123456789int a = 0, b = 0; for (i = 0; i &lt; N; i++) &#123; # O(N)+O(N)=2*O(N)=O(N) a = a + rand(); # N*1个操作 = O(N) b = b + rand(); # N*1个操作 = O(N)&#125; for (j = 0; j &lt; N/2; j++) &#123; b = b + rand(); # N/2*1个操作 = 1/2*O(N)=O(N)&#125; 时间复杂度：O(N) 空间复杂度：2个单位的内存空间 = O(1) # constant space complexity 例子2 1234567891011121314int a = 0, i, j;for (i = 0; i &lt; N; i++) &#123; for (j = N; j &gt; i; j--) &#123; a = a + i + j; &#125; &#125; i=0: j=N...1 Ni=1: j=N...2 N-1i=2: j=N...3 N-2i=N-1: j=N 1total = 1+2+3,...+N = N*(N+1)/2 = N*N/2 + N/2 = 1/2*O(N^2) + 1/2*O(N) = O(N^2) + O(N) = O(N^2) 时间复杂度：O(N^2); 空间复杂度:O(1) 例子3 12345678910111213141516int a = 0, i = N; while (i &gt; 0) &#123; a += i; # 1个操作 i /= 2; # 1个操作&#125; N = 40; i=40i=20 2i=10 2i=5 2i=2 2i=1 2i=0 2terminate2*log(N) = 2* O(log N) = O(log N) 例子4 12345678int i, j, k = 0; for (i = n / 2; i &lt;= n; i++) &#123; for (j = 2; j &lt;= n; j = j * 2) &#123; k = k + n / 2; &#125; &#125; O(n*log n) 复杂度总结 我们每当说算法X的效率要高于Y时指的是？ 时间复杂度 X: o(log n) &gt; Y: o(n) o(n log n) &gt; Y: o(n^2) 定理： 如果x的时间复杂度要优于y的时间复杂度，那么，假设存在一个足够大的数M，当 n&gt;M时，我们可以保证X的实际效率要优于Y的实际效率 归并排序 7744FD0FEC67CC6C8B21406ADB3A359F 主定理 nlpcamp_l2-03 nlpcamp_l2-04 nlpcamp_l2-05 nlpcamp_l2-06 斐波那契数 问题 序列为 1, 1, 2, 3, 5, 8, 13, 21, …… 请求出序列的第n个数。 原始解法 12345678# 递推式: T(n) = T(n-2) + T(n-1)def fib(n): if n == 1 or n == 2: result = 1 else: result = fib(n-2) + fib(n-1) return result image-20191227010720857 fibonacci sequence 的递推式不符合主定理的要求 可以通过画出一棵递归树分析出时间复杂度为O(2^n) nlpcamp_l2-13 空间复杂度为O(n) nlpcamp_l2-14 动态规划解法 时间复杂度为O(n) 空间复杂度为O(n) 123456789# Use Dynamic Programmingimport numpy as npdef fib4(n): tmp = np.zeros(n) tmp[0] = 1 tmp[1] = 1 for i in range(2, n): tmp[i] = tmp[i - 1] + tmp[i - 2] return tmp[n - 1] 一点优化，提升空间复杂度至O(1) 123456789# 相当于使用了两个指针def fib2(n): ptr1 = 1 ptr2 = 1 for i in range(2, n): res = ptr1 + ptr2 ptr1 = ptr2 ptr2 = res return res nlpcamp_l2-15 Closed-form 解法 123# 时间复杂度O(1)def fib_cf(n: int) -&gt; int: return 0.4472135954999579 * (1.618033988749895**n - (-0.6180339887498949)**n) P vs NP vs NP Hard vs NP Complete nlpcamp_l2-07 案例：搭建一个智能客服系统 nlpcamp_l2-08 nlpcamp_l2-09 nlpcamp_l2-10 nlpcamp_l2-11 分词(segmentation) 预处理: spell correction stemming / lemmatization stop-word words filtering 同义词 …… 文本 -&gt; 向量 boolean vector(0, 1, 1, ……) count vector(1, 2, ……) tf-idf(0.7, 0.3, 0, ……) word2vec seq2seq 添加Inverted Index(倒排表)降低复杂度 计算相似度(给定2个向量) euclidean distance cosine distance jaccard distance 排序 过滤 返回结果 nlpcamp_l2-16 推荐阅读 时间复杂度 Master's Theorem MIT Ling Ren讲解主定理 edit distance(动态规划) CS Dojo讲解斐波那契数(动态规划) Closed-Form Expression to Calculate n-th Fibonacci Number Calculating Fibonacci Numbers with Matrices and Linear Algebra(回顾mit线代)]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
      <tags>
        <tag>自动问答</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】01 笔记总结]]></title>
    <url>%2F2019%2F12%2F25%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9101-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[banner-top-logo 本文是学习贪心学院NLP自然语言处理集训营2（任课教师：李文哲）的总结学习笔记，对于一部分内容根据个人理解做了升级和优化。 视频总共时长为：119小时8分钟48秒 Logistics nlpcamp_l1-01 nlpcamp_l1-02 nlpcamp_l1-03 nlpcamp_l1-04 nlpcamp_l1-05 nlpcamp_l1-06 nlpcamp_l1-07 nlpcamp_l1-08 NLP定义以及歧义性 nlpcamp_l1-09 nlpcamp_l1-10 nlpcamp_l1-11 nlpcamp_l1-12 nlpcamp_l1-13 nlpcamp_l1-14 nlpcamp_l1-15 nlpcamp_l1-16 实现一个机器翻译系统 nlpcamp_l1-17 nlpcamp_l1-18 传统做法：给定语料库，在其中做统计，语料少的可以用排除法，根据大概的匹配结果返回给用户。 答案：jjat arrat vat mat hilat oloat at-yurp nlpcamp_l1-19 传统翻译系统缺陷： 训练速度慢(使用AI模型) 语法不正确(重点，语法要让人可以理解) 规则统计 语义 上下文 nlpcamp_l1-20 如何保证生成的语句合理通顺？ 步骤：中文分词 -&gt; 逐词翻译 -&gt; 罗列所有可能组合 -&gt; 选择最合适的句子(Language Model) 问题：两步的模型计算量过大，时间复杂度太高(指数级) 解决方案：两个模型同时考虑，维特比算法直接计算出 argmax P(e) * P(c|e) Translation Model + Language Model —&gt; Decoding Algorithm, Viterbi Algorithm(DP) nlpcamp_l1-21 nlpcamp_l1-22 nlpcamp_l1-23 语言模型分类：(计算每一个概率) Unigram Model：独立 Bigram Model：考虑前一个单词 Trigram Model：考虑前两个单词 …… N-gram Model 马尔科夫假设 一点公式推导：使精度可以接受且又容易计算 BF5F2B8FC48F801D851CAE00C695C6E0 nlpcamp_l1-24 中国的机器翻译难度较大，美国的较容易 NLP的经典应用场景 nlpcamp_l1-25 nlpcamp_l1-26 nlpcamp_l1-27 nlpcamp_l1-28 nlpcamp_l1-29 nlpcamp_l1-30 nlpcamp_l1-31 nlpcamp_l1-32 nlpcamp_l1-33 nlpcamp_l1-34 Named-entity recognition (NER) Relation Extraction NLP的关键技术 nlpcamp_l1-35 nlpcamp_l1-36 词性标注（Part-of-Speech tagging 或POS tagging) nlpcamp_l1-37 nlpcamp_l1-38 nlpcamp_l1-39 nlpcamp_l1-40 nlpcamp_l1-41 nlpcamp_l1-42 多去阅读state-of-art paper，了解nlp领域内的最新进展。 看项目中涉及到哪些技术，知道这些技术的实现难度，评估项目可行性 。 https://www.quora.com/What-are-the-major-open-problems-in-natural-language-understanding I will classify the problems in Natural Language Processing into 3 categories : 1. Easy or mostly solved Spam detection Part of Speech Tagging - Example INPUT: Profits soared at Boeing Co., easily topping forecasts on Wall Street, as their CEO Alan Mulally announced first quarter results. OUTPUT: Profits/N soared/V at/P Boeing/N Co./N ,/, easily/ADV topping/V forecasts/ N on/P Wall/N Street/N ,/, as/P their/POSS CEO/N Alan/N Mulally/ N announced/V first/ADJ quarter/N results/N ./. KEY: N = Noun, V = Verb, P = Preposition, Adv = Adverb Named Entity Recognition - Example ​ INPUT: ​ Profits soared at Boeing Co., easily topping forecasts on Wall Street, as ​ their CEO Alan Mulally announced first quarter results. ​ OUTPUT: ​ Profits/NA soared/NA at/NA Boeing/SC Co./CC ,/NA easily/NA topping/ ​ NA forecasts/NA on/NA Wall/SL Street/CL ,/NA as/NA their/NA CEO/NA ​ Alan/SP Mulally/CP announced/NA first/NA quarter/NA results/NA ./NA ​ KEY: NA = No entity, SC = Start Company, CC = Continue Company, SL = Start Location, CL = Continue Location 2. Intermediate or making good progress Sentiment analysis- Example: ​ Best roast chicken in San Francisco! -- Positive ​ The waiter ignored us for 20 minutes. -- Negative Coreference resolution - Example: &quot;Carter told Mubarak he shouldn't run again.&quot; To solve whether &quot;he&quot; is related to &quot;Carter&quot; or &quot;Mubarak&quot;. Word sense disambiguation - Example : ​ I need new batteries for my mouse. - &quot;mouse&quot; is ambiguous here. Parsing - the basic problem of parsing sentences. Machine Translation - translating sentences from one language to another, best example would be Google translate. Information Translation - to take a text as input and represent it in a structured form like a database entries. 3. Hard or still need lot of work Text Summarization - to take input as text document(s) and try to condense them into a summary. Machine dialog system - Example: ​ User - I need a flight from New York to London, arriving at 10 pm ? ​ System - What day are you leaving? ​ User - Tomorrow. ​ System detects the missing information in your sentences.]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
        <tag>NLP技术</tag>
        <tag>NLP场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[presentation]]></title>
    <url>%2F2019%2F06%2F10%2Fassets%2F</url>
    <content type="text"><![CDATA[Student Registration System 五大模块 配置虚拟环境和框架 创建一个项目 使用模板 连接数据库 使用 web forms 和 flask-security 配置Flask框架 创建学生选课系统文件夹，并在其中创建虚拟环境 123mkdir SRScd SRSpython3 -m venv venv 启动虚拟环境 1. venv/bin/activate 在虚拟环境中安装Flask 1pip install Flask 在虚拟环境中安装flask-wtf (用于快速创建表单) 1pip install flask-wtf 在项目文件夹中创建 .flaskenv 12FLASK_ENV=developmentFLASK_APP=main.py 在虚拟环境中安装python-dotenv 用途：可以把所有用到的环境变量写到.env文件里，然后以k，v的方式读取作为环境变量。这样我们的项目迁移到不同的环境时只需要更改一下.env的内容就可以了，代码执行时会自动从.env文件里读取所需要的配置信息 1pip install python-dotenv 退出虚拟环境 1deactivate image-20190524131400912 创建并运行一个简单的Flask应用程序 首先启动虚拟环境，并进入项目文件夹下 创建requirements文件，方便迁移项目 1pip freeze &gt; requirements.txt 如需重新安装库文件 1pip install -r requirements.txt 创建main.py文件 123456from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" 运行 1flask run image-20190524132647750 image-20190524133420073 创建SRS应用程序 核心步骤 在项目文件中创建application文件夹，main程序运行时调用其中的内容，进入application文件夹 创建templates static __init__.py 重构代码，将main程序中的代码转移到init程序中 在项目文件夹下创建config.py 在app文件夹下创建routes.py 创建系统主页 index.html 增加navigation links和routing patterns 核心技术 路由 现代 Web 应用的 URL 十分优雅，易于人们辨识记忆，这一点对于那些面向使用低速网络连接移动设备访问的应用特别有用。如果可以不访问索引页，而是直接访问想要的那个页面，他们多半会笑逐颜开而再度光顾。 如上所见， route() 装饰器把一个函数绑定到对应的 URL 上。 这里是一些基本的例子: 1234567@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos; 12345678910111213141516171819@app.route("/login", methods=['GET','POST'])def login(): if session.get('username'): return redirect(url_for('index')) form = LoginForm() if form.validate_on_submit(): email = form.email.data password = form.password.data user = User.objects(email=email).first() if user and user.get_password(password): flash(f"&#123;user.first_name&#125;, you are successfully logged in!", "success") session['user_id'] = user.user_id session['username'] = user.first_name return redirect("/index") else: flash("Sorry, something went wrong.","danger") return render_template("login.html", title="Login", form=form, login=True ) 构造url 如果 Flask 能匹配 URL，那么 Flask 可以生成它们吗？当然可以。你可以用 url_for()来给指定的函数构造 URL。它接受函数名作为第一个参数，也接受对应 URL 规则的变量部分的命名参数。未知变量部分会添加到 URL 末尾作为查询参数。这里有一些例子: 123456789101112131415161718192021&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route(&apos;/&apos;)... def index(): pass...&gt;&gt;&gt; @app.route(&apos;/login&apos;)... def login(): pass...&gt;&gt;&gt; @app.route(&apos;/user/&lt;username&gt;&apos;)... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():... print url_for(&apos;index&apos;)... print url_for(&apos;login&apos;)... print url_for(&apos;login&apos;, next=&apos;/&apos;)... print url_for(&apos;profile&apos;, username=&apos;John Doe&apos;)...//login/login?next=//user/John%20Doe 1234567891011&lt;header&gt; &lt;nav&gt; &lt;ul class="nav nav-pills"&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('index') &#125;&#125;" class="nav-link &#123;% if index %&#125;active&#123;% endif %&#125;"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('courses') &#125;&#125;" class="nav-link &#123;% if courses %&#125;active&#123;% endif %&#125;"&gt;Classes&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('register') &#125;&#125;" class="nav-link &#123;% if register %&#125;active&#123;% endif %&#125;"&gt;Register&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('login') &#125;&#125;" class="nav-link &#123;% if login %&#125;active&#123;% endif %&#125;"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr style="clear:both"&gt;&lt;/header&gt; jinja2模板 Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML，你确信能在Python的字符串中正确地写出来么？反正我是做不到。 Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户。 这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。 Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等； 包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。 MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。 上面的例子中，Model就是一个dict：{ 'name': 'Michael' } 有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。 image-20190609160447890 使用模板 核心步骤 在templates中创建父模板 layout.html 和一些子模板, child template 都继承自 base template image-20190609162319851 1234567891011121314151617181920&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-12 text-center"&gt; &#123;% for user in users %&#125; &lt;dl&gt; &lt;dt&gt;User ID: &#123;&#123; user.user_id&#125;&#125;&lt;/dt&gt; &lt;dd&gt;Email: &#123;&#123;user.email&#125;&#125;&lt;/dd&gt; &lt;dd&gt;Password: &#123;&#123;user.password&#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &#123;% else %&#125; &lt;h3&gt;No users yet!&lt;/h3&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 将数据传送到视图层 通过request和response对象获取数据 核心技术 get和post请求： get请求： 使用场景： 如果只是对服务器获取数据， 并没有对服务器产生任何影响，那么这时候使用get请求 传参： get请求传参是放在url中，并且是通过?的形式来指定key和value的。 post请求： 使用场景：如果要对服务器产生影响，那么使用post请求。 传参： post请求传参不是放在url中，是通过form data的形式发送给服务器的。 get和post请求获取参数： get请求是通过flask.request.args来获取。 post请求是通过flask.request.form来获取。 post请求在模板中要注意几点： input标签中， 要写那么来表示这个value的key， 方便后台获取。 在写form表单的时候， 要指定method=post, 并且要指定action='/login/' image-20190609201459316 image-20190609201541807 连接数据库 核心步骤 安装MongoDB数据库系统 安装适应Flask框架的Mongo引擎扩展 配置数据库 连接数据库 创建一些数据 创建数据模型 配置 启动 mongodb，默认数据库目录即为 /data/db： 1sudo mongod 安装flask-mongoengine 1sudo pip install flask-mongoengine 配置一个数据库 1MONGODB_SETTINGS = &#123; &apos;db&apos; : &apos;GDUT_Enrollment&apos; &#125; 导包并初始化 1234from flask_mongoengine import MongoEnginedb = MongoEngine()db.init_app(app) image-20190609204941420 12345678910111213class User(db.Document): user_id = db.IntField( unique=True ) first_name = db.StringField( max_length=50 ) last_name = db.StringField( max_length=50 ) email = db.StringField( max_length=30 ) password = db.StringField( max_length=30 )@app.route("/user")def user(): User(user_id=1, first_name="Christian", last_name="Hur", email="christian@uta.com", password="abc1234").save() User(user_id=2, first_name="Mary", last_name="Jane", email="mary.jane@uta.com", password="password123").save() users = User.objects.all() return render_template("user.html", users=users) image-20190609210018628 image-20190609210116679 添加json数据 1mongoimport --jsonArray --db GDUT_Enrollment --collection course /Users/Mac/Downloads/flask记录/courses.json image-20190609211532213 image-20190609211702437 使用 web forms 和 flask-security 1sudo pip install flask-wtf flask-security 核心步骤 安装和配置 flask-wtf flask-security 创建注册和登录页面 处理表单数据和更新数据库 创建课程和选课页面 创建 sessions 和 authentication 核心技术 使用 WTForms 进行表单验证 WTForms 当编写验证客户端提交的多个Form表单时，视图函数中的代码很快将变得冗长和难以阅读，调试和维护也变得难以忍受。通过使用WTForms库，将表单定义为继承于Form的类，使用该类可以验证所有表单，并且可以在模板中自动生成表单对应的HTML元素，定制HTML生成过程，从而实现业务逻辑代码和展示的分离，并使得代码简洁干净、易于维护。 image-20190610000509784 12345678910111213141516171819202122232425262728293031323334 &#123;% extends "layout.html" %&#125; &#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-6 offset-md-3"&gt; &lt;form name="login" action="" method="post" novalidate&gt; &lt;fieldset class="form-group"&gt; &lt;legend&gt;&#123;&#123;title&#125;&#125;&lt;/legend&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;p&gt; &#123;&#123; form.email.label &#125;&#125;&lt;br&gt; &#123;&#123; form.email(size=35) &#125;&#125; &#123;% for error in form.email.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.password.label &#125;&#125;&lt;br&gt; &#123;&#123; form.password(size=15) &#125;&#125; &#123;% for error in form.password.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.submit() &#125;&#125; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 使用 Flask-Security 扩展 支持一般的安全和认证特性 支持数据持久化 使用 Werkzeug库进行密码加密 image-20190610001245573 使用 session 当客户端进行第一次请求时，客户端的HTTP request（cookie为空）到服务端，服务端创建session，视图函数根据form表单填写session，请求结束时，session内容填写入response的cookie中并返回给客户端，客户端的cookie中便保存了用户的数据。 当同一客户端再次请求时， 客户端的HTTP request中cookie已经携带数据，视图函数根据cookie中值做相应操作（如已经携带用户名和密码就可以直接登陆）。 在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。 image-20190610005826683 image-20190610005840485 image-20190610005847712 image-20190610005859756]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Binary Search Defination Given an sorted integer array( - nums), and an integer( - target). Find the any/first/last position of target in nums Return -1 if target does not exist. Template 1234start + 1 &lt; end start + (end - start) / 2 A[mid] ==, &lt;, &gt; A[start] A[end] ? target 好处：防止死循环，防止漏解，题目适用范围广 Example: First position of target 1234567891011121314151617def binarySearch(arr, target): start = 0 end = len(arr) - 1 while (start + 1 &lt; end): mid = start + (end - start) // 2 if arr[mid] == target: end = mid elif arr[mid] &lt; target: start = mid elif arr[mid] &gt; target: end = mid if arr[start] == target: return start if arr[end] == target: return end return -1 ###Exercise classical binary search search for a range 思路：两次二分查找，第一次找第一次出现的位置，第二次找最后一次出现的位置 #### Search Insert Position 思路1: find the first position &gt;= target 思路2: find the last position &lt; target, return +1]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F04%2F09%2FCompiler%2F</url>
    <content type="text"><![CDATA[Compiler notes First Sets Defination \(\text { First }(X)=\left\{t | X \rightarrow^{*} t \alpha\right\} \cup\left\{\varepsilon | X \rightarrow^{*} \varepsilon\right\}\) Algorithm sketch: \(\text { First }(t)=(t)\) \(\varepsilon \in \mathrm{First}(X)\) \(\begin{array}{l}{\text { if } X \rightarrow \varepsilon} \\ {\text { if } X \rightarrow A_{1} \dots A_{n} \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n}\end{array}\) \(\text { First }(\alpha) \subseteq \text { First }(X)\) \(\text { if } X \rightarrow A_{1} \ldots A_{n} \alpha \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n\) Follow Sets Defination: \(\text { Follow }(X)=\left\{t | S \rightarrow^{*} \beta Xt\delta\right\}​\) Intuition \(\begin{array}{c}{\text { If } X \rightarrow A B \text { then First }(B) \subseteq \text { Follow }(A) \text { and }} \ {\text { Follow }(X) \subseteq \text { Follow }(B)}\end{array}\) \(\text { if } B \rightarrow^{*} \varepsilon \text { then Follow }(X) \subseteq \text { Follow }(A)\) \(\text { If } S \text { is the start symbol then } \$ \in \text { Follow }(S)​\) Algorithm sketch: \(\$ \in \text { Follow }(S)\) \(\begin{array}{l}{\text { First }(\beta)-\{\varepsilon\} \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta}\end{array}​\) \(\begin{array}{l}{\text { Follow }(A) \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta \text { where }\varepsilon \in \text { First }(\beta)}\end{array}\) Select Sets Defination: \(\text { Select }(A \rightarrow \alpha)=\left\{t\right\}\) Algorithm sketch: \(\text { For each production } A \rightarrow \alpha \text { in G do: }\) \(\begin{array}{l}{-\text { For each terminal } t \in \text { First }(\alpha) \text { do }} \\ {\quad \cdot \mathrm{T}[A, t]=\alpha}\end{array}\) \(\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha), \text { for each } t \in \text { Follow }(A) \mathrm{do}} \\ {\quad \cdot \mathrm{T}[A,t]=\alpha}\end{array}\) \(\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha) \text { and } \$ \in \text { Follow }(A) \text { do }} \\ {\quad \cdot \mathrm{T}[A, \$]=\alpha}\end{array}\)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lecture 4 (Error and Noise)]]></title>
    <url>%2F2019%2F04%2F03%2FLecture-4-Error-and-Noise%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lecture 3 (The Linear Model I)]]></title>
    <url>%2F2019%2F04%2F01%2FLecture-3-The-Linear-Model-I%2F</url>
    <content type="text"><![CDATA[为了可以尽快上手，将线性模型调整到前面]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈(Monotonic Stack)]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack%2F</url>
    <content type="text"><![CDATA[算法解析 第一种情况 栈底到栈顶是由大到小排列，则使栈顶数弹出的是右边离它最近的比它大的数，新的栈顶数是左边离原栈顶数最近的比它大的数。反之亦然。 第二种情况 栈底到栈顶是由小到大排列，则使栈顶数弹出的是右边离它最近的比它小的数，新的栈顶数是左边离原栈顶数最近的比它小的数。 相关习题 654. Maximum Binary Tree 算法细节：每个数都找到左和右比它大的数，选择其中小的作为父节点，左和右都为空的数则是根节点。 算法正确性（易证）： 构造的是一棵树，而非森林 每个节点最多有两个孩子 84. Largest Rectangle in Histogram 延伸阅读：Jackson Gabbard讲解 12345678910111213141516171819202122class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ stack = [] max_area = 0 index = 0 while index &lt; len(heights): if not stack or heights[stack[-1]] &lt; heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area 85. Maximal Rectangle 总结 单调栈关心的是一维数组上某个数与其周围数的关系。例如寻找距离最近的比它大（或小）的数；在histogram中，前后的bar的高低影响了最终矩形的计算；在最大子矩阵中，把每一行矩阵看做一个直方图。在这些例子中我们可以试图用单调栈来解决。在使用单调栈的时候，想清楚每个元素出栈的意义，什么时候更新index，遇到重复的元素如何处理，栈为空时是什么情况等等。因为每个元素都出栈入栈各一次，所以时间复杂度是O(n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 2 (Is Learning Feasible?)]]></title>
    <url>%2F2019%2F03%2F30%2FLecture-2-Is-Learning-Feasible%2F</url>
    <content type="text"><![CDATA[\( E_{in}\)]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
      <tags>
        <tag>feasible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2019%2F03%2F29%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class AvlTree(object): """ An avl tree. """ def __init__(self): # Root node of the tree. self.node = None self.height = -1 self.balance = 0 def insert(self, key): """ Insert new key into node """ # Create new node n = TreeNode(key) if not self.node: self.node = n self.node.left = AvlTree() self.node.right = AvlTree() elif key &lt; self.node.val: self.node.left.insert(key) elif key &gt; self.node.val: self.node.right.insert(key) self.re_balance() def re_balance(self): """ Re balance tree. After inserting or deleting a node, """ self.update_heights(recursive=False) self.update_balances(False) while self.balance &lt; -1 or self.balance &gt; 1: if self.balance &gt; 1: if self.node.left.balance &lt; 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance &lt; -1: if self.node.right.balance &gt; 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): """ Update tree height """ if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): """ Calculate tree balance factor """ if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): """ Right rotation """ new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): """ Left rotation """ new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root def in_order_traverse(self): """ In-order traversal of the tree """ result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的奇技淫巧]]></title>
    <url>%2F2019%2F03%2F27%2FHexo%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Hexo添加文章时自动打开编辑器 mac下修改文件夹权限： sudo -i进入root模式 chown -R 用户名 /文件夹名 操作步骤： 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 Mac平台的Hexo用户将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new "auto open editor test" 是不是就顺利的自动打开了自动生成的md文件啦~ Hexo添加评论区 参考: Valine leancloud Hexo内嵌pdf文档 安装插件https://github.com/superalsrk/hexo-pdf 修改主题配置文件 123456789# PDF Support# Dependencies: https://github.com/theme-next/theme-next-pdfpdf: enable: true # Default (true) will load PDFObject / PDF.js script on demand. # That is it only render those page which has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject / PDF.js srcipt EVERY PAGE. per_page: true height: 500px 其他选择 &lt;center&gt;&lt;embed src=&quot;/pdf/mou.pdf&quot; width=&quot;850&quot; height=&quot;600&quot;&gt;&lt;/center&gt; &lt;iframe src=&quot;/pdf/mou.pdf&quot; style=&quot;width:850px; height:600px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; Hexo显示数学公式 Hexo博客数学公式显示 MarkDown 插入数学公式实验大集合 Hexo Next主题解决无法显示数学公式 解决block数学公式下有scroll bar的问题 layout/_third-party/math/mathjax.swig下的 123456&lt;style&gt;.MathJax_Display &#123; overflow-x: scroll; overflow-y: hidden;&#125;&lt;/style&gt; 修改为 1234567&lt;style&gt;.MathJax_Display &#123; overflow: auto hidden; overflow-x: hidden; overflow-y: hidden;&#125;&lt;/style&gt; 参考：https://github.com/theme-next/hexo-theme-next/issues/658 Hexo插入图片 Hexo方式post_asset_folder&quot;#&quot; * 根目录下的配置文件_config.yml里的post_asset_folder选项设置为true。新建文章的时候会同时创建一个同名文件夹用于放图片。 * 执行命令npm install hexo-asset-image --save ，下载安装一个可以上传本地图片的插件： * 使用的时候，只需要图片名就可以 * 也可以使用Hexo推荐的标签方式 Hexo优化速度 禁用背景动画 NexT已经自带了多种背景动画效果，你只需要根据需求在主题配置文件修改其中一个为true即可。 Canvas-nest canvas_nest: false three_waves three_waves: false 禁用mathjax 总配置文件 删掉 123456789101112# 数学公式math: engine: 'mathjax' # or 'katex' mathjax: src: custom_mathjax_source config: # MathJax config katex: css: custom_css_source js: custom_js_source # not used config: # KaTeX config 要让Github Pages被索引到 参考文档： Blog养成记(5) 要让Github Pages被索引到 让Google搜索到搭建在Github Pages上的博客 遇到的问题：node-pre-gyp build fail error while installing with npm install or npm install -d 解决方案： the error got resolved by running 1npm install --build-from-resource 如何使文章多级目录自动展开，而不是默认折叠 如果你想实现默认展开全部目录的功能，可以在themes/next/source/css/_custom/custom.styl文件中添加以下自定义样式规则： 123.post-toc .nav .nav-child &#123; display: block; &#125; 但是通常文章内会出现多级标题，对应的目录里就会有多级导航出现，这时候一些原本你不希望出现的次要标题也会在目录中出现并且无法折叠。可以通过以下样式实现默认只展开两级目录，这样以来就完美解决了该问题。 123.post-toc .nav .nav-level-1&gt;.nav-child &#123; display: block; &#125; 参考博客 Yearito's Blog]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Morris遍历]]></title>
    <url>%2F2019%2F03%2F27%2FMorris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Morris遍历 问题描述：利用Morris遍历实现二叉树的先序，中序，后续遍历，时间复杂度O(N)，额外空间复杂度O(1)。 算法描述 来到的当前节点记为cur（cur是一个引用），如果cur无左孩子，cur向右移动。 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright。 如果mostright的右指针指向空，则让其指向cur，cur向左移动。 如果mostright的右指针指向cur，则让其指向空，cur向右移动。 图解 算法解析 如果一个节点有左子树，则回到这个节点两次，若没有，则回到这个节点一次。递归版遍历无论如何可以三次来到一个节点，根据处理时机的不同分为三种顺序的遍历。而Morris遍历是根据一个节点左子树最右指针的指向来判断是第一次来到这个节点还是第二次。第一次来到这个节点处理时记为先序，第二次来到这个节点处理时记为中序。 在第二次来到这个节点时逆序打印它左子树的右边界，最后单独打印整棵树的右边界，记为后序遍历。 算法复杂度 整棵树可以分解成由右边界组成，算法有限次的遍历了右边界，所以时间复杂度是O(N)。 Code 123456789101112131415# 递归版遍历，方便理解def process_recursive(root, res=None): if root is None: return [] if res is None: res = [] # 1 # res.append(root.val) process_recursive(root.left, res) # 2 # res.append(root.val) process_recursive(root.right, res) # 3 # res.append(root.val) return res 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Morris版遍历def preorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: res.append(cur.val) node.right = cur cur = cur.left else: node.right = None cur = cur.right return resdef inorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res.append(cur.val) node.right = None cur = cur.right return res def postorder_morris(root: Node) -&gt; list: dummy = Node(0) dummy.left = root res = [] cur = dummy while cur: if cur.left is None: cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res += traceBack(cur.left, node) node.right = None cur = cur.right return resdef traceBack(frm, to): res = [] cur = frm while cur is not to: res.append(cur.val) cur = cur.right res.append(to.val) res.reverse() return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a]]></title>
    <url>%2F2018%2F01%2F26%2Fa%2F</url>
    <content type="text"><![CDATA[some content]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
