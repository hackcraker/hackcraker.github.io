<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Python】统计视频总时长]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90Python%E3%80%91%E7%BB%9F%E8%AE%A1%E8%A7%86%E9%A2%91%E6%80%BB%E6%97%B6%E9%95%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import osfrom moviepy.editor import VideoFileClipimport traceback class MovieDirUtil(): def __init__(self,file_dir): self.file_dir = file_dir def get_filesize(self, filename): u""" 获取文件大小（M: 兆） """ file_byte = os.path.getsize(filename) return self.sizeConvert(file_byte) def get_file_times(self, filename): u""" 获取视频时长（s:秒） """ file_time = 0 clip = None try: clip = VideoFileClip(filename) file_time = clip.duration except Exception as e: traceback.print_exc() finally: if clip: clip.close() return file_time def sizeConvert(self, size): # 文件大小单位换算 K, M, G = 1024, 1024 ** 2, 1024 ** 3 if size &gt;= G: return str(size / G) + 'G Bytes' elif size &gt;= M: return str(size / M) + 'M Bytes' elif size &gt;= K: return str(size / K) + 'K Bytes' else: return str(size) + 'Bytes' def timeConvert(self, size): # 时间单位换算 M, H = 60, 60 ** 2 if size &lt; M: return str(size) + u'秒' if size &lt; H: return u'%s分钟%s秒' % (int(size / M), int(size % M)) else: hour = int(size / H) mine = int(size % H / M) second = int(size % H % M) tim_srt = u'%s小时%s分钟%s秒' % (hour, mine, second) return tim_srt def get_all_file(self): u""" 获取目录下下所有的文件 """ file_list = [] for root, dirs, files in os.walk(file_dir): for file in files: # begin #print(os.path.join(root, file)) file_list.append(os.path.join(root, file)) # end return file_list def get_all_file_duration(self): u""" 获取目录下下所有的文件的播放总时长，单位s """ fileList = self.get_all_file() file_duration = 0 for f in fileList: # print(f) print(f, mdu.timeConvert(self.get_file_times(f))) file_duration += self.get_file_times(f) return file_duration if __name__=="__main__": file_dir = u"/Volumes/sed" # 定义目录地址 mdu = MovieDirUtil(file_dir) print("目录里面包含的视频总共时长为：&#123;duration&#125;".format(duration=mdu.timeConvert(mdu.get_all_file_duration())))]]></content>
  </entry>
  <entry>
    <title><![CDATA[【九章算法】02 Java语言]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E3%80%9102-Java%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[第五讲 栈和队列 Stack &amp; Queue 栈 Stack 什么是栈(stack) 栈是一种后进先出(last in first out，LIFO)的线性数据结构 学习目标 implement a stack ○ http://www.lintcode.com/en/problem/implement-stack/ valid parentheses ○ http://www.lintcode.com/en/problem/valid-parentheses/ 栈的操作 push pop peek (getTop) isEmpty image-20191230205927164 栈的实现 ArrayList push —&gt; add pop —&gt; remove LinkedList(推荐) ArrayList不适合用来实现栈，动态数组的copy数据操作复杂度较大，remove元素时不会马上削减size，而是要等到s一定程度时，而栈是伸缩的一种数据结构，会增长也会减小，在一些特殊情况会频繁的resize，所以不适合用来实现栈。 12345678910111213141516171819202122232425262728293031// ArrayList实现的栈class StackImpArrayList &#123; public List&lt;Integer&gt; array; public StackImpArrayList() &#123; array = new ArrayList&lt;Integer&gt;(); &#125; // Push a new item into the stack public void push(int val) &#123; array.add(val); &#125; // Pop the top of the stack public int pop() &#123; int size = array.size(); return array.remove(size - 1); &#125; // Return the top of the stack public int peek() &#123; int size = array.size(); return array.get(size - 1); &#125; // Check the stack is empty or not. public boolean isEmpty() &#123; return array.isEmpty(); &#125;&#125; pop操作如何实现？ 一般情况下是 dummy -&gt; 20 -&gt;10 -&gt; null dummy.next为栈底，这样pop时复杂度为O(N)， 在这里实现为 dummy -&gt; 10 -&gt;20 -&gt; null dummy.next设为栈顶，这样pop时复杂度为O(1)。 123456789101112131415161718192021222324252627282930313233343536373839// LinkedList实现的栈class Node &#123; public int val; public Node next; public Node(int value) &#123; this.val = value; &#125;&#125;class StackImpListNode &#123; public Node dummy; public StackImpListNode() &#123; dummy = new Node(-1); &#125; public void push(int val) &#123; Node node = new Node(val); node.next = dummy.next; dummy.next = node; &#125; public int pop() &#123; int ele = dummy.next.val; dummy.next = dummy.next.next; return ele; &#125; public int peek() &#123; int ele = dummy.next.val; return ele; &#125; public boolean isEmpty() &#123; return dummy.next == null; &#125;&#125;]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】04 笔记总结]]></title>
    <url>%2F2019%2F12%2F30%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9104-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文本的表示 文本的相似度 Tf-idf 文本表示 词向量介绍 生成词向量 问答系统回顾 倒排表]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【九章算法】01 Java语言]]></title>
    <url>%2F2019%2F12%2F29%2F%E3%80%90%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E3%80%9101-Java%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[本文是学习Java入门与基础算法（任课教师：林平之）的总结学习笔记。如果有不会的算法题，请参考题解:smiley: 第二讲 变量，数组和循环(Java基础 I)变量ASCII &amp; Unicode编码 字符 对应整数 0 48 A 65 a 97 123456// 小写转大写，避免hard codechar a = 'a';System.out.println((char)(a - 'a' + 'A'));// 或者直接调用写好的函数Character.toUpperCase(a); 数组 Array数组用一个变量来表示一组连续的相同类型的变量。 1234567891011// 定义方式1int[] array = new int[] &#123;90, 95, 92, 89, 100, 98&#125;;// 定义方式2int[] array2 = new int[6];array2[0] = 90;array2[1] = 95;array2[2] = 92;array2[3] = 89;array2[4] = 100;array2[5] = 98; 二维数组和多维数组 123456789// 定义方式1int[][] matrix = new int[][] &#123; &#123;1, 4, 7, 10&#125;, &#123;2, 6, 12, 15&#125;, &#123;6, 8, 13, 20&#125;&#125;;// 定义方式2int[][] matrix2 = new int[3][4]; 程序的三大结构 顺序结构 控制结构 循环结构 控制结构12345678910111213// max number of 3 numbersint a = 10, b = 20, c = 15;int max = a;if (b &gt; max) &#123; max = b;&#125;if (c &gt; max) &#123; max = c;&#125;System.out.println(max); 循环结构12345678910111213141516// 找第二大的数int[] arr = new int[] &#123;90, 95, 92, 89, 100, 98&#125;;int len = array.length;int max = 0;int sMax = 0;// 1[ ], 2[ ]for (int i = 0; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; sMax = max; max = arr[i]; &#125; else if (sMax &lt; arr[i]) &#123; sMax = arr[i] &#125;&#125;System.out.println(max);System.out.println(sMax); 1234567891011// 遍历二维数组int[][] matrix = new int[][] &#123; &#123;1, 4, 7&#125;, &#123;2, 6&#125;, &#123;6, 8, 13, 20&#125;&#125;;for (int i = 0; i&lt; matrix.length; ++i) &#123; for (int j = 0; j&lt; matrix[i].length; ++j) &#123; System.out.println(matrix[i][j]); &#125;&#125; 12345// loopint[] array = new int[] &#123;1, 2, 4&#125;;for (int num: array) &#123; System.out.println(num);&#125; 第三讲 字符串，函数，类和对象(Java基础 II)String及其常用操作1234567891011121314151617181920212223242526272829303132333435// 字符串的长度String a = "hello";String b = new String("hello");System.out.println(a.length());// 字符串的遍历// 1for (int i = 0; i &lt; a.length(); ++i) &#123; System.out.println(a.charAt(i));&#125;// 2char[] chars = new char[] &#123;'h', 'e', 'l', 'l', 'o'&#125;;for (char c: a.toCharArray()) &#123; System.out.println(c);&#125;// 字符串的运算:连接String str = "My name is";str += " Guojing"; // str: "My name is Guojing"int age = 18;str = "I am " + age + " years old"; // str: "I am 18 years old"// 字符串 子串的查找indexOf (返回子串作为位置的下标。)String source = "jiuzhang";int index = source.indexOf("zhang"); System.out.println(index);// 字符串的比较(大部分情况都是用方法比较内容的)String a = "hello";String b = new String("hello");String c = "hello";String d = new String("hello");System.out.println(a == b); // false,不是指向同一个对象System.out.println(a.equals(b); // true,同一个内容System.out.println(a == c); // true,指向同一个对象,常量表 System.out.println(b == d); // false,new创建了两个对象 LintCode: Valid Palindrome12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; /** * @param s: A string * @return: Whether the string is a valid palindrome */ public boolean isPalindrome(String s) &#123; // write your code here if (s == null || s.length() == 0) &#123; return true; &#125; int left = 0; int right = s.length() - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; !isValid(s.charAt(left))) &#123; left++; &#125; while (left &lt; right &amp;&amp; !isValid(s.charAt(right))) &#123; right--; &#125; if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123; return false; &#125; else &#123; left++; right--; &#125; &#125; return true; &#125; public boolean isValid(char c) &#123; return Character.isLetter(c) || Character.isDigit(c); &#125;&#125; 函数 类和对象 LintCode: Student ID(Design a Student class)Description Implement a class Class with the following attributes and methods: A public attribute students which is an array of Student instances. A constructor with a parameter n, which is the total number of students in this class. The constructor should create n Student instances and initialized with student id from 0 ~ n-1 Example 1234567891011Java: Class cls = new Class(3) cls.students[0]; // should be a student instance with id = 0 cls.students[1]; // should be a student instance with id = 1 cls.students[2]; // should be a student instance with id = 2Python: cls = new Class(3) cls.students[0] # should be a student instance with id = 0 cls.students[1] # should be a student instance with id = 1 cls.students[2] # should be a student instance with id = 2 Solution Java: 123456789101112131415161718class Student &#123; public int id; public Student(int id) &#123; this.id = id; &#125;&#125;public class Class &#123; public Student[] students; // 声明Student类型数组，即创建一个引用 public Class(int n) &#123; this.students = new Student[n]; // 创建Student类型数组，将引用（students）指向此数组 for (int i = 0; i &lt; n; ++i) &#123; students[i] = new Student(i); &#125; &#125;&#125; Python: 12345678910111213141516class Student: def __init__(self, id): self.id = id;class Class: ''' * Declare a constructor with a parameter n which is the total number of * students in the *class*. The constructor should create n Student * instances and initialized with student id from 0 ~ n-1 ''' # write your code here def __init__(self, n): self.students = [] for i in range(n): self.students.append(Student(i)) LintCode: Student LevelDescriptionImplement a class Student, including the following attributes and methods: Two public attributes name(string) and score(int). A constructor expect a name as a parameter. A method getLevel to get the level(char) of the student. score – level table: A: score &gt;= 90 B: score &gt;= 80 and &lt; 90 C: score &gt;= 60 and &lt; 80 D: score &lt; 60 Example 12345678910111213Java: Student student = new Student(&quot;Zuck&quot;); student.score = 10; student.getLevel(); // should be &apos;D&apos; student.score = 60; student.getLevel(); // should be &apos;C&apos;Python: student = Student(&quot;Zuck&quot;) student.score = 10 student.getLevel() # should be &apos;D&apos; student.score = 60 student.getLevel() # should be &apos;C&apos; Solution: 123456789101112131415161718192021## Basic Ideas:## Complexity: Time O(1), Space O(1)class Student: ''' * Declare a constructor expect a name as a parameter. ''' # write your code here def __init__(self, name): self.name = name self.score = 0 ''' * Declare a public method `getLevel` to get the level(char) of this student. ''' # write your code here def getLevel(self): if self.score &gt;= 90: return 'A' if self.score&gt;=80 and self.score&lt;90: return 'B' if self.score&gt;=60 and self.score&lt;80: return 'C' return 'D' 推荐阅读 Object-Oriented Design Problems LEETCODE COMMON TEMPLATES 第四讲 Reference LinkedList 引用 &amp; 链表引用 Reference对象去哪儿了?1ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); intList不是对象本身，是对象的引用new出来的对象，存储在堆空间(heap space)上 堆空间 heap space 栈空间 stack space 注意区别于数据结构的heap &amp; stack 引用的赋值12Student student1 = new Student(&quot;Jack&quot;);Student student2 = new Student(&quot;Rose&quot;); new出来两个对象 student1和student2是这两个对象的引用 演示对比 int 和 IntegerWrapperPs: int, double等都是基础类型 IntegerWrapper对象作为函数参数 对比Increment(int) 和 Increment(IntegerWrapper) 12345678910111213141516171819202122232425262728class IntegerWrapper &#123; public int value; public IntegerWrapper(int val) &#123; value = val; &#125; &#125;public class Main &#123; public static void increment(int a) &#123; a++; &#125; public static void increment(IntergerWrapper intW) &#123; intW.value++; // 指向同一个对象，可以修改 &#125; public static void main(String[] args) &#123; int a = 10; IntegerWrapper intW = new IntegerWrapper(10); increment(a); increment(intW); System.out.println("a: " + a); System.out.println("intW.value: " + inW.value); &#125;&#125; 12345678910111213141516171819202122232425262728class IntegerWrapper &#123; public int value; public IntegerWrapper(int val) &#123; value = val; &#125;&#125;public class Main &#123; public static void increment(int a) &#123; a++; &#125; public static void increment(IntegerWrapper intW) &#123; intW = new IntegerWrapper(20); // 指向新创建的对象 &#125; public static void main(String[] args) &#123; int a = 10; IntegerWrapper intW = new IntegerWrapper(10); increment(a); increment(intW); System.out.println("a: " + a); System.out.println("intW.value: " + intW.value); &#125;&#125; 原因分析： 总结 传递引用 修改引用所指向对象的数据，修改引用没有任何效果(举例) 引用的好处与用处 引用也存的是数据，存的是指向这个对象的地址 使得数据更加的整齐 需要传递引用去修改数据 什么是null空的引用，没有引用任何对象。 1234ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list = null; // list变成了空引用list.add(1); // NullPointerException 引用中的NULL值问题Student ID问题: http://www.lintcode.com/en/problem/student-id/ Note:构造一个Student的数组，对象数组(非基础类型的数组)new出来后， 每个对象都是NULL 链表 Linked List什么是数据结构(data structure)● 数据 ○ 存储数据的功能 ● 结构 ○ 如何组织排列存储的数据 ● 操作 ○ 如何查询，添加，删除维护存在的数据 什么是链表(linked list) 由节点构成的列表 线性的数据结构 1234class ListNode &#123; public int val; public ListNode next;&#125; 哨兵节点不得不提的dummy Node:伟大的哨兵节点: dummyNode -&gt; null 作用(前驱节点的重要性): 使得每一个元素都有前驱节点 (好处：操作一致，程序逻辑更简单，容易找到头结点) Coding:基于ListNode实现一个Linked ListLinkedList Class的接口: 读取操作 get(location) // 获取location位置上的node的value 查找操作 contains(val) // 判断链表中是否含有val值的node 插入操作 add(location, val) // 在location的位置上插入一个值为val的node 删除操作 remove(location) // 删除location位置上的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ListNode &#123; public int val; public ListNode next; public ListNode(int value) &#123; this.val = value; &#125;&#125;// Location 0 是dummy的下一个节点public class LinkedList &#123; ListNode dummy; public LinkedList() &#123; dummy = new ListNode(-1); // dummy.next = null; &#125; public int get(int location) &#123; ListNode cur = dummy.next; for (int i = 0; i &lt; location; ++i) &#123; cur = cur.next; &#125; return cur.val; &#125; public boolean contains(int val) &#123; ListNode head = dummy.next; while (head != null) &#123; if (head.val == val) &#123; return true; &#125; head = head.next; &#125; return false; &#125; public void add(int location, int val) &#123; ListNode pre = dummy; for (int i = 0; i &lt; location; ++i) &#123; pre = pre.next; &#125; ListNode node = new ListNode(val); node.next = pre.next; pre.next = node; &#125; public void remove(int location) &#123; ListNode pre = dummy; for (int i = 0; i &lt; location; ++i) &#123; pre = pre.next; &#125; pre.next = pre.next.next; &#125; public void print() &#123; ListNode head = dummy.next; while (head != null) &#123; System.out.println(head.val + "-&gt;"); head = head.next; &#125; System.out.println("null"); &#125;&#125; 时间复杂度对比 操作 ArrayList LinkedList Add/Remove at end O(1) O(1) Add/Remove at begin O(n) O(1) Add/Remove at any where O(n) O(n) Add/Remove at specified place O(n) O(1) Read/Find By position O(1) O(n) Read/Find By target (value) O(n) O(n) 小练习 在排序的链表中插入一个Node 翻转一个链表 删除链表中倒数第N个元素]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】03 笔记总结]]></title>
    <url>%2F2019%2F12%2F27%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9103-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview nlpcamp_l3-02 nlpcamp_l3-03 分词 nlpcamp_l3-04 nlpcamp_l3-05 最大匹配算法 正向最大匹配法 分词目标： 在词典中进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 算法流程： 假设词典中最长的单词为 5 个（MAX_LENGTH），那么最大匹配的起始子串字数也为 5 个 扫描字典，测试读入的子串是否在字典中 如果存在，则从输入中删除掉该子串，重新按照规则取子串，重复 1 如果不存在于字典中，则从右向左减少子串长度，重复1 nlpcamp_l3-06 贪心算法：选择当前最优解 DP：选择全局最优解 max-len通常为5~10 可以根据单词长度的不同做一个分析已选择最合适的max-len。 逆向最大匹配法 分词目标： 在词典中进行扫描，尽可能地选择与词典中最长单词匹配的词作为目标分词，然后进行下一次匹配。 在实践中，逆向最大匹配算法性能优于正向最大匹配算法。 算法流程： 假设词典中最长的单词为 5 个（MAX_LENGTH），那么最大匹配的起始子串字数也为 5 个 扫描字典，测试读入的子串是否在字典中 如果存在，则从输入中删除掉该子串，重新按照规则取子串，重复 1 如果不存在于字典中，则从左向右减少子串长度，重复 1 nlpcamp_l3-07 90%情况前向和后向分词结果相同，10%不同。如南京市长江大桥 最大匹配缺点 细分可能更优 局部最优 没有考虑语义(单词-&gt;syntactic-&gt;semantic) nlpcamp_l3-08 考虑语义模型(LM) nlpcamp_l3-09 nlpcamp_l3-10 Unigram Language Model语言模型选择所有分割情况中最好的 通过统计的方式写出每个单词出现的概率 给定一个句子分词后可以用联合概率算出的概率用作评判是否符合语义的标准 nlpcamp_l3-22 计算时取对数防溢出 nlpcamp_l3-21 生成组合太多，算法复杂度过高，解决方法使用维特比算法 维特比算法 nlpcamp_l3-11 nlpcamp_l3-12 伪代码 nlpcamp_l3-20 数学公式 nlpcamp_l3-19 9E038A12ECCE3D003FAA2C06F6B311F9 分词算法总结 nlpcamp_l3-13 拼写错误纠正 nlpcamp_l3-14 两种错误情况： 错别字 不是错别字，不适合 nlpcamp_l3-15 计算编辑距离（DP算法）三种操作： insert delete replace 然后再在编辑距离最小的之中根据上下文，词频选择一个 nlpcamp_l3-16 nlpcamp_l3-17 QQ20191230-164446 QQ20191230-164600 QQ20191230-164649 一个独立的问题 QQ20191230-164912 停用词过滤 QQ20191230-164950 QQ20191230-165228 Stemming操作 QQ20191230-165347 QQ20191230-165503 推荐阅读 分词中的最大匹配算法 DP经典练习题]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[待看]]></title>
    <url>%2F2019%2F12%2F27%2F%E9%87%8D%E7%82%B9%E5%BE%85%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[重点待看 Stanford ai cs224 cs230 6.006 6.046 弱待看 来offer 极客时间 Python核心技术与实战 加 数学 statistics 110 18.01 18.02 18.03 18.065 数学分析 陈纪修 OS 经典书籍 名人刷题记录 小土刀 Byvoid CS-Notes 自学nlp Sanny Kim nlpprogress 贪心nlp课程大纲 nine chapter https://lintcode-solutions.gitbook.io/project/jiuzhang-courses/binary-search https://stomachache007.wordpress.com/2017/03/07/414/ https://www.cnblogs.com/Raising-Sun/ https://marian5211.github.io/categories/%E7%AE%97%E6%B3%95/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/ &#x68;&#116;&#x74;&#x70;&#115;&#x3a;&#47;&#47;&#x6d;&#x65;&#x64;&#105;&#x75;&#x6d;&#46;&#99;&#x6f;&#109;&#x2f;&#x40;&#x64;&#x65;&#114;&#x65;&#107;&#102;&#x61;&#x6e;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】02 笔记总结]]></title>
    <url>%2F2019%2F12%2F26%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9102-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Overview 算法复杂度这是任何AI工程师必须要深入理解的概念。对于每一个设计出来的算法都需要从这两个方面来分析。 例子1123456789int a = 0, b = 0; for (i = 0; i &lt; N; i++) &#123; # O(N)+O(N)=2*O(N)=O(N) a = a + rand(); # N*1个操作 = O(N) b = b + rand(); # N*1个操作 = O(N)&#125; for (j = 0; j &lt; N/2; j++) &#123; b = b + rand(); # N/2*1个操作 = 1/2*O(N)=O(N)&#125; 时间复杂度：O(N)空间复杂度：2个单位的内存空间 = O(1) # constant space complexity 例子21234567891011121314int a = 0, i, j;for (i = 0; i &lt; N; i++) &#123; for (j = N; j &gt; i; j--) &#123; a = a + i + j; &#125; &#125; i=0: j=N...1 Ni=1: j=N...2 N-1i=2: j=N...3 N-2i=N-1: j=N 1total = 1+2+3,...+N = N*(N+1)/2 = N*N/2 + N/2 = 1/2*O(N^2) + 1/2*O(N) = O(N^2) + O(N) = O(N^2) 时间复杂度：O(N^2);空间复杂度:O(1) 例子312345678910111213141516int a = 0, i = N; while (i &gt; 0) &#123; a += i; # 1个操作 i /= 2; # 1个操作&#125; N = 40; i=40i=20 2i=10 2i=5 2i=2 2i=1 2i=0 2terminate2*log(N) = 2* O(log N) = O(log N) 例子412345678int i, j, k = 0; for (i = n / 2; i &lt;= n; i++) &#123; for (j = 2; j &lt;= n; j = j * 2) &#123; k = k + n / 2; &#125; &#125; O(n*log n) 复杂度总结我们每当说算法X的效率要高于Y时指的是？ 时间复杂度X: o(log n) &gt; Y: o(n) o(n log n) &gt; Y: o(n^2)定理： 如果x的时间复杂度要优于y的时间复杂度，那么，假设存在一个足够大的数M，当n&gt;M时，我们可以保证X的实际效率要优于Y的实际效率 归并排序 主定理 斐波那契数问题序列为 1, 1, 2, 3, 5, 8, 13, 21, …… 请求出序列的第n个数。 原始解法12345678# 递推式: T(n) = T(n-2) + T(n-1)def fib(n): if n == 1 or n == 2: result = 1 else: result = fib(n-2) + fib(n-1) return result fibonacci sequence 的递推式不符合主定理的要求可以通过画出一棵递归树分析出时间复杂度为O(2^n) 空间复杂度为O(n) 动态规划解法时间复杂度为O(n)空间复杂度为O(n) 123456789# Use Dynamic Programmingimport numpy as npdef fib4(n): tmp = np.zeros(n) tmp[0] = 1 tmp[1] = 1 for i in range(2, n): tmp[i] = tmp[i - 1] + tmp[i - 2] return tmp[n - 1] 一点优化，提升空间复杂度至O(1) 123456789# 相当于使用了两个指针def fib2(n): ptr1 = 1 ptr2 = 1 for i in range(2, n): res = ptr1 + ptr2 ptr1 = ptr2 ptr2 = res return res Closed-form 解法123# 时间复杂度O(1)def fib_cf(n: int) -&gt; int: return 0.4472135954999579 * (1.618033988749895**n - (-0.6180339887498949)**n) P vs NP vs NP Hard vs NP Complete 案例：搭建一个智能客服系统 分词(segmentation) 预处理: spell correction stemming / lemmatization stop-word words filtering 同义词 …… 文本 -&gt; 向量 boolean vector(0, 1, 1, ……) count vector(1, 2, ……) tf-idf(0.7, 0.3, 0, ……) word2vec seq2seq 添加Inverted Index(倒排表)降低复杂度 计算相似度(给定2个向量) euclidean distance cosine distance jaccard distance 排序 过滤 返回结果 推荐阅读 时间复杂度 Master’s Theorem MIT Ling Ren讲解主定理 edit distance(动态规划) CS Dojo讲解斐波那契数(动态规划) Closed-Form Expression to Calculate n-th Fibonacci Number Calculating Fibonacci Numbers with Matrices and Linear Algebra(回顾mit线代)]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
      <tags>
        <tag>自动问答</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心学院nlp】01 笔记总结]]></title>
    <url>%2F2019%2F12%2F25%2F%E3%80%90%E8%B4%AA%E5%BF%83%E5%AD%A6%E9%99%A2nlp%E3%80%9101-%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[banner-top-logo 本文是学习贪心学院NLP自然语言处理集训营2（任课教师：李文哲）的总结学习笔记，对于一部分内容根据个人理解做了升级和优化。 视频总共时长为：119小时8分钟48秒 ** Logistics nlpcamp_l1-01 nlpcamp_l1-02 nlpcamp_l1-03 nlpcamp_l1-04 nlpcamp_l1-05 nlpcamp_l1-06 nlpcamp_l1-07 nlpcamp_l1-08 NLP定义以及歧义性 nlpcamp_l1-09 nlpcamp_l1-10 nlpcamp_l1-11 nlpcamp_l1-12 nlpcamp_l1-13 nlpcamp_l1-14 nlpcamp_l1-15 nlpcamp_l1-16 实现一个机器翻译系统 nlpcamp_l1-17 nlpcamp_l1-18 传统做法：给定语料库，在其中做统计，语料少的可以用排除法，根据大概的匹配结果返回给用户。 答案：jjat arrat vat mat hilat oloat at-yurp nlpcamp_l1-19 传统翻译系统缺陷： 训练速度慢(使用AI模型) 语法不正确(重点，语法要让人可以理解) 规则统计 语义 上下文 nlpcamp_l1-20 如何保证生成的语句合理通顺？ 步骤：中文分词 -&gt; 逐词翻译 -&gt; 罗列所有可能组合 -&gt; 选择最合适的句子(Language Model) 问题：两步的模型计算量过大，时间复杂度太高(指数级) 解决方案：两个模型同时考虑，维特比算法直接计算出 argmax P(e) * P(c|e) Translation Model + Language Model —&gt; Decoding Algorithm, Viterbi Algorithm(DP) nlpcamp_l1-21 nlpcamp_l1-22 nlpcamp_l1-23 语言模型分类：(计算每一个概率) Unigram Model：独立 Bigram Model：考虑前一个单词 Trigram Model：考虑前两个单词 …… N-gram Model 马尔科夫假设 一点公式推导：使精度可以接受且又容易计算 BF5F2B8FC48F801D851CAE00C695C6E0 nlpcamp_l1-24 中国的机器翻译难度较大，美国的较容易 NLP的经典应用场景 nlpcamp_l1-25 nlpcamp_l1-26 nlpcamp_l1-27 nlpcamp_l1-28 nlpcamp_l1-29 nlpcamp_l1-30 nlpcamp_l1-31 nlpcamp_l1-32 nlpcamp_l1-33 nlpcamp_l1-34 Named-entity recognition (NER) Relation Extraction NLP的关键技术 nlpcamp_l1-35 nlpcamp_l1-36 词性标注（Part-of-Speech tagging 或POS tagging) nlpcamp_l1-37 nlpcamp_l1-38 nlpcamp_l1-39 nlpcamp_l1-40 nlpcamp_l1-41 nlpcamp_l1-42 多去阅读state-of-art paper，了解nlp领域内的最新进展。 看项目中涉及到哪些技术，知道这些技术的实现难度，评估项目可行性 。 https://www.quora.com/What-are-the-major-open-problems-in-natural-language-understanding I will classify the problems in Natural Language Processing into 3 categories : 1. Easy or mostly solved Spam detection Part of Speech Tagging - Example INPUT: Profits soared at Boeing Co., easily topping forecasts on Wall Street, as their CEO Alan Mulally announced first quarter results. OUTPUT: Profits/N soared/V at/P Boeing/N Co./N ,/, easily/ADV topping/V forecasts/ N on/P Wall/N Street/N ,/, as/P their/POSS CEO/N Alan/N Mulally/ N announced/V first/ADJ quarter/N results/N ./. KEY: N = Noun, V = Verb, P = Preposition, Adv = Adverb Named Entity Recognition - Example ​ INPUT: ​ Profits soared at Boeing Co., easily topping forecasts on Wall Street, as ​ their CEO Alan Mulally announced first quarter results. ​ OUTPUT: ​ Profits/NA soared/NA at/NA Boeing/SC Co./CC ,/NA easily/NA topping/ ​ NA forecasts/NA on/NA Wall/SL Street/CL ,/NA as/NA their/NA CEO/NA ​ Alan/SP Mulally/CP announced/NA first/NA quarter/NA results/NA ./NA ​ KEY: NA = No entity, SC = Start Company, CC = Continue Company, SL = Start Location, CL = Continue Location 2. Intermediate or making good progress Sentiment analysis- Example: ​ Best roast chicken in San Francisco! -- Positive ​ The waiter ignored us for 20 minutes. -- Negative Coreference resolution - Example: &quot;Carter told Mubarak he shouldn't run again.&quot; To solve whether &quot;he&quot; is related to &quot;Carter&quot; or &quot;Mubarak&quot;. Word sense disambiguation - Example : ​ I need new batteries for my mouse. - &quot;mouse&quot; is ambiguous here. Parsing - the basic problem of parsing sentences. Machine Translation - translating sentences from one language to another, best example would be Google translate. Information Translation - to take a text as input and represent it in a structured form like a database entries. 3. Hard or still need lot of work Text Summarization - to take input as text document(s) and try to condense them into a summary. Machine dialog system - Example: ​ User - I need a flight from New York to London, arriving at 10 pm ? ​ System - What day are you leaving? ​ User - Tomorrow. ​ System detects the missing information in your sentences.]]></content>
      <categories>
        <category>贪心学院nlp</category>
      </categories>
      <tags>
        <tag>机器翻译</tag>
        <tag>NLP技术</tag>
        <tag>NLP场景</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[presentation]]></title>
    <url>%2F2019%2F06%2F10%2Fassets%2F</url>
    <content type="text"><![CDATA[Student Registration System五大模块 配置虚拟环境和框架 创建一个项目 使用模板 连接数据库 使用 web forms 和 flask-security 配置Flask框架创建学生选课系统文件夹，并在其中创建虚拟环境123mkdir SRScd SRSpython3 -m venv venv 启动虚拟环境1. venv/bin/activate 在虚拟环境中安装Flask 1pip install Flask 在虚拟环境中安装flask-wtf (用于快速创建表单) 1pip install flask-wtf 在项目文件夹中创建 .flaskenv 12FLASK_ENV=developmentFLASK_APP=main.py 在虚拟环境中安装python-dotenv用途：可以把所有用到的环境变量写到.env文件里，然后以k，v的方式读取作为环境变量。这样我们的项目迁移到不同的环境时只需要更改一下.env的内容就可以了，代码执行时会自动从.env文件里读取所需要的配置信息 1pip install python-dotenv 退出虚拟环境 1deactivate 创建并运行一个简单的Flask应用程序 首先启动虚拟环境，并进入项目文件夹下 创建requirements文件，方便迁移项目 1pip freeze &gt; requirements.txt 如需重新安装库文件 1pip install -r requirements.txt 创建main.py文件 123456from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" 运行 1flask run 创建SRS应用程序核心步骤 在项目文件中创建application文件夹，main程序运行时调用其中的内容，进入application文件夹 创建templates static __init__.py 重构代码，将main程序中的代码转移到init程序中 在项目文件夹下创建config.py 在app文件夹下创建routes.py 创建系统主页 index.html 增加navigation links和routing patterns 核心技术 路由 现代 Web 应用的 URL 十分优雅，易于人们辨识记忆，这一点对于那些面向使用低速网络连接移动设备访问的应用特别有用。如果可以不访问索引页，而是直接访问想要的那个页面，他们多半会笑逐颜开而再度光顾。 如上所见， route() 装饰器把一个函数绑定到对应的 URL 上。 这里是一些基本的例子: 1234567@app.route(&apos;/&apos;)def index(): return &apos;Index Page&apos;@app.route(&apos;/hello&apos;)def hello(): return &apos;Hello World&apos; 12345678910111213141516171819@app.route("/login", methods=['GET','POST'])def login(): if session.get('username'): return redirect(url_for('index')) form = LoginForm() if form.validate_on_submit(): email = form.email.data password = form.password.data user = User.objects(email=email).first() if user and user.get_password(password): flash(f"&#123;user.first_name&#125;, you are successfully logged in!", "success") session['user_id'] = user.user_id session['username'] = user.first_name return redirect("/index") else: flash("Sorry, something went wrong.","danger") return render_template("login.html", title="Login", form=form, login=True ) 构造url 如果 Flask 能匹配 URL，那么 Flask 可以生成它们吗？当然可以。你可以用 url_for()来给指定的函数构造 URL。它接受函数名作为第一个参数，也接受对应 URL 规则的变量部分的命名参数。未知变量部分会添加到 URL 末尾作为查询参数。这里有一些例子: 123456789101112131415161718192021&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route(&apos;/&apos;)... def index(): pass...&gt;&gt;&gt; @app.route(&apos;/login&apos;)... def login(): pass...&gt;&gt;&gt; @app.route(&apos;/user/&lt;username&gt;&apos;)... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():... print url_for(&apos;index&apos;)... print url_for(&apos;login&apos;)... print url_for(&apos;login&apos;, next=&apos;/&apos;)... print url_for(&apos;profile&apos;, username=&apos;John Doe&apos;)...//login/login?next=//user/John%20Doe 1234567891011&lt;header&gt; &lt;nav&gt; &lt;ul class="nav nav-pills"&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('index') &#125;&#125;" class="nav-link &#123;% if index %&#125;active&#123;% endif %&#125;"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('courses') &#125;&#125;" class="nav-link &#123;% if courses %&#125;active&#123;% endif %&#125;"&gt;Classes&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('register') &#125;&#125;" class="nav-link &#123;% if register %&#125;active&#123;% endif %&#125;"&gt;Register&lt;/a&gt;&lt;/li&gt; &lt;li class="nav-item"&gt;&lt;a href="&#123;&#123; url_for('login') &#125;&#125;" class="nav-link &#123;% if login %&#125;active&#123;% endif %&#125;"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr style="clear:both"&gt;&lt;/header&gt; jinja2模板 Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在函数中返回一个包含HTML的字符串，简单的页面还可以，但是，想想新浪首页的6000多行的HTML，你确信能在Python的字符串中正确地写出来么？反正我是做不到。 Web App最复杂的部分就在HTML页面。HTML不仅要正确，还要通过CSS美化，再加上复杂的JavaScript脚本来实现各种交互和动画效果。总之，生成HTML页面的难度很大。由于在Python代码里拼字符串是不现实的，所以，模板技术出现了。使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户。 这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。 Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等； 包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。 MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。 上面的例子中，Model就是一个dict：{ ‘name’: ‘Michael’ } 有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。 使用模板核心步骤 在templates中创建父模板 layout.html 和一些子模板, child template 都继承自 base template 1234567891011121314151617181920&#123;% extends "layout.html" %&#125;&#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-12 text-center"&gt; &#123;% for user in users %&#125; &lt;dl&gt; &lt;dt&gt;User ID: &#123;&#123; user.user_id&#125;&#125;&lt;/dt&gt; &lt;dd&gt;Email: &#123;&#123;user.email&#125;&#125;&lt;/dd&gt; &lt;dd&gt;Password: &#123;&#123;user.password&#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &#123;% else %&#125; &lt;h3&gt;No users yet!&lt;/h3&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 将数据传送到视图层 通过request和response对象获取数据 核心技术get和post请求： get请求： 使用场景： 如果只是对服务器获取数据， 并没有对服务器产生任何影响，那么这时候使用get请求 传参： get请求传参是放在url中，并且是通过?的形式来指定key和value的。 post请求： 使用场景：如果要对服务器产生影响，那么使用post请求。 传参： post请求传参不是放在url中，是通过form data的形式发送给服务器的。 get和post请求获取参数： get请求是通过flask.request.args来获取。 post请求是通过flask.request.form来获取。 post请求在模板中要注意几点： input标签中， 要写那么来表示这个value的key， 方便后台获取。 在写form表单的时候， 要指定method=post, 并且要指定action=&#39;/login/&#39; 连接数据库核心步骤 安装MongoDB数据库系统 安装适应Flask框架的Mongo引擎扩展 配置数据库 连接数据库 创建一些数据 创建数据模型 配置启动 mongodb，默认数据库目录即为 /data/db： 1sudo mongod 安装flask-mongoengine 1sudo pip install flask-mongoengine 配置一个数据库 1MONGODB_SETTINGS = &#123; &apos;db&apos; : &apos;GDUT_Enrollment&apos; &#125; 导包并初始化 1234from flask_mongoengine import MongoEnginedb = MongoEngine()db.init_app(app) 12345678910111213class User(db.Document): user_id = db.IntField( unique=True ) first_name = db.StringField( max_length=50 ) last_name = db.StringField( max_length=50 ) email = db.StringField( max_length=30 ) password = db.StringField( max_length=30 )@app.route("/user")def user(): User(user_id=1, first_name="Christian", last_name="Hur", email="christian@uta.com", password="abc1234").save() User(user_id=2, first_name="Mary", last_name="Jane", email="mary.jane@uta.com", password="password123").save() users = User.objects.all() return render_template("user.html", users=users) 添加json数据 1mongoimport --jsonArray --db GDUT_Enrollment --collection course /Users/Mac/Downloads/flask记录/courses.json 使用 web forms 和 flask-security1sudo pip install flask-wtf flask-security 核心步骤 安装和配置 flask-wtf flask-security 创建注册和登录页面 处理表单数据和更新数据库 创建课程和选课页面 创建 sessions 和 authentication 核心技术 使用 WTForms 进行表单验证 WTForms 当编写验证客户端提交的多个Form表单时，视图函数中的代码很快将变得冗长和难以阅读，调试和维护也变得难以忍受。通过使用WTForms库，将表单定义为继承于Form的类，使用该类可以验证所有表单，并且可以在模板中自动生成表单对应的HTML元素，定制HTML生成过程，从而实现业务逻辑代码和展示的分离，并使得代码简洁干净、易于维护。 12345678910111213141516171819202122232425262728293031323334 &#123;% extends "layout.html" %&#125; &#123;% block content %&#125; &lt;div class="row"&gt; &lt;div class="col-md-6 offset-md-3"&gt; &lt;form name="login" action="" method="post" novalidate&gt; &lt;fieldset class="form-group"&gt; &lt;legend&gt;&#123;&#123;title&#125;&#125;&lt;/legend&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &lt;p&gt; &#123;&#123; form.email.label &#125;&#125;&lt;br&gt; &#123;&#123; form.email(size=35) &#125;&#125; &#123;% for error in form.email.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.password.label &#125;&#125;&lt;br&gt; &#123;&#123; form.password(size=15) &#125;&#125; &#123;% for error in form.password.errors %&#125; &lt;span class="error-message"&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &#123;% endfor %&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; form.submit() &#125;&#125; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 使用 Flask-Security 扩展 支持一般的安全和认证特性 支持数据持久化 使用 Werkzeug库进行密码加密 使用 session 当客户端进行第一次请求时，客户端的HTTP request（cookie为空）到服务端，服务端创建session，视图函数根据form表单填写session，请求结束时，session内容填写入response的cookie中并返回给客户端，客户端的cookie中便保存了用户的数据。 当同一客户端再次请求时， 客户端的HTTP request中cookie已经携带数据，视图函数根据cookie中值做相应操作（如已经携带用户名和密码就可以直接登陆）。 在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Binary SearchDefination Given an sorted integer array( - nums), and an integer( - target). Find the any/first/last position of target in nums Return -1 if target does not exist. Template1234start + 1 &lt; end start + (end - start) / 2 A[mid] ==, &lt;, &gt; A[start] A[end] ? target 好处：防止死循环，防止漏解，题目适用范围广 Example: First position of target1234567891011121314151617def binarySearch(arr, target): start = 0 end = len(arr) - 1 while (start + 1 &lt; end): mid = start + (end - start) // 2 if arr[mid] == target: end = mid elif arr[mid] &lt; target: start = mid elif arr[mid] &gt; target: end = mid if arr[start] == target: return start if arr[end] == target: return end return -1 Exerciseclassical binary searchsearch for a range思路：两次二分查找，第一次找第一次出现的位置，第二次找最后一次出现的位置 Search Insert Position思路1: find the first position &gt;= target思路2: find the last position &lt; target, return +1]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F04%2F09%2FCompiler%2F</url>
    <content type="text"><![CDATA[Compiler notesFirst SetsDefination$\text { First }(X)=\left{t | X \rightarrow^{} t \alpha\right} \cup\left{\varepsilon | X \rightarrow^{} \varepsilon\right}$ Algorithm sketch: $\text { First }(t)=(t)$ $\varepsilon \in \mathrm{First}(X)$$\begin{array}{l}{\text { if } X \rightarrow \varepsilon} \ {\text { if } X \rightarrow A{1} \dots A{n} \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n}\end{array}$ $\text { First }(\alpha) \subseteq \text { First }(X)$$\text { if } X \rightarrow A{1} \ldots A{n} \alpha \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n$ Follow SetsDefination: $\text { Follow }(X)=\left{t | S \rightarrow^{*} \beta Xt\delta\right}​$ Intuition $\begin{array}{c}{\text { If } X \rightarrow A B \text { then First }(B) \subseteq \text { Follow }(A) \text { and }} \ {\text { Follow }(X) \subseteq \text { Follow }(B)}\end{array}$$\text { if } B \rightarrow^{*} \varepsilon \text { then Follow }(X) \subseteq \text { Follow }(A)$ $\text { If } S \text { is the start symbol then } $ \in \text { Follow }(S)​$ Algorithm sketch: $$ \in \text { Follow }(S)$ $\begin{array}{l}{\text { First }(\beta)-{\varepsilon} \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta}\end{array}​$ $\begin{array}{l}{\text { Follow }(A) \subseteq \text { Follow }(X)} {\text { - For each production } A \rightarrow \alpha X \beta \text { where }\varepsilon \in \text { First }(\beta)}\end{array}$ Select SetsDefination: $\text { Select }(A \rightarrow \alpha)=\left{t\right}$ Algorithm sketch:$\text { For each production } A \rightarrow \alpha \text { in G do: }$ $\begin{array}{l}{-\text { For each terminal } t \in \text { First }(\alpha) \text { do }} \ {\quad \cdot \mathrm{T}[A, t]=\alpha}\end{array}$ $\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha), \text { for each } t \in \text { Follow }(A) \mathrm{do}} \ {\quad \cdot \mathrm{T}[A,t]=\alpha}\end{array}$ $\begin{array}{l}{-\text { If } \varepsilon \in \text { First }(\alpha) \text { and } $ \in \text { Follow }(A) \text { do }} \ {\quad \cdot \mathrm{T}[A, $]=\alpha}\end{array}$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lecture 4 (Error and Noise)]]></title>
    <url>%2F2019%2F04%2F03%2FLecture-4-Error-and-Noise%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lecture 3 (The Linear Model I)]]></title>
    <url>%2F2019%2F04%2F01%2FLecture-3-The-Linear-Model-I%2F</url>
    <content type="text"><![CDATA[为了可以尽快上手，将线性模型调整到前面]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈(Monotonic Stack)]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack%2F</url>
    <content type="text"><![CDATA[算法解析第一种情况栈底到栈顶是由大到小排列，则使栈顶数弹出的是右边离它最近的比它大的数，新的栈顶数是左边离原栈顶数最近的比它大的数。反之亦然。 第二种情况栈底到栈顶是由小到大排列，则使栈顶数弹出的是右边离它最近的比它小的数，新的栈顶数是左边离原栈顶数最近的比它小的数。 相关习题654. Maximum Binary Tree算法细节：每个数都找到左和右比它大的数，选择其中小的作为父节点，左和右都为空的数则是根节点。 算法正确性（易证）： 构造的是一棵树，而非森林 每个节点最多有两个孩子 84. Largest Rectangle in Histogram延伸阅读：Jackson Gabbard讲解 12345678910111213141516171819202122class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ stack = [] max_area = 0 index = 0 while index &lt; len(heights): if not stack or heights[stack[-1]] &lt; heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area 85. Maximal Rectangle总结 单调栈关心的是一维数组上某个数与其周围数的关系。例如寻找距离最近的比它大（或小）的数；在histogram中，前后的bar的高低影响了最终矩形的计算；在最大子矩阵中，把每一行矩阵看做一个直方图。在这些例子中我们可以试图用单调栈来解决。在使用单调栈的时候，想清楚每个元素出栈的意义，什么时候更新index，遇到重复的元素如何处理，栈为空时是什么情况等等。因为每个元素都出栈入栈各一次，所以时间复杂度是O(n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 2 (Is Learning Feasible?)]]></title>
    <url>%2F2019%2F03%2F30%2FLecture-2-Is-Learning-Feasible%2F</url>
    <content type="text"><![CDATA[\( E_{in}\)]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
      <tags>
        <tag>feasible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2019%2F03%2F29%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class AvlTree(object): """ An avl tree. """ def __init__(self): # Root node of the tree. self.node = None self.height = -1 self.balance = 0 def insert(self, key): """ Insert new key into node """ # Create new node n = TreeNode(key) if not self.node: self.node = n self.node.left = AvlTree() self.node.right = AvlTree() elif key &lt; self.node.val: self.node.left.insert(key) elif key &gt; self.node.val: self.node.right.insert(key) self.re_balance() def re_balance(self): """ Re balance tree. After inserting or deleting a node, """ self.update_heights(recursive=False) self.update_balances(False) while self.balance &lt; -1 or self.balance &gt; 1: if self.balance &gt; 1: if self.node.left.balance &lt; 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance &lt; -1: if self.node.right.balance &gt; 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): """ Update tree height """ if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): """ Calculate tree balance factor """ if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): """ Right rotation """ new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): """ Left rotation """ new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root def in_order_traverse(self): """ In-order traversal of the tree """ result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的奇技淫巧]]></title>
    <url>%2F2019%2F03%2F27%2FHexo%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Hexo添加文章时自动打开编辑器 mac下修改文件夹权限： sudo -i进入root模式 chown -R 用户名 /文件夹名 操作步骤： 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 Mac平台的Hexo用户将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new "auto open editor test" 是不是就顺利的自动打开了自动生成的md文件啦~ Hexo添加评论区 参考: Valine leancloud Hexo内嵌pdf文档 安装插件https://github.com/superalsrk/hexo-pdf 修改主题配置文件 123456789# PDF Support# Dependencies: https://github.com/theme-next/theme-next-pdfpdf: enable: true # Default (true) will load PDFObject / PDF.js script on demand. # That is it only render those page which has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject / PDF.js srcipt EVERY PAGE. per_page: true height: 500px 其他选择 &lt;center&gt;&lt;embed src=&quot;/pdf/mou.pdf&quot; width=&quot;850&quot; height=&quot;600&quot;&gt;&lt;/center&gt; &lt;iframe src=&quot;/pdf/mou.pdf&quot; style=&quot;width:850px; height:600px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; Hexo显示数学公式 Hexo博客数学公式显示 MarkDown 插入数学公式实验大集合 Hexo Next主题解决无法显示数学公式 解决block数学公式下有scroll bar的问题 layout/_third-party/math/mathjax.swig下的 123456&lt;style&gt;.MathJax_Display &#123; overflow-x: scroll; overflow-y: hidden;&#125;&lt;/style&gt; 修改为 1234567&lt;style&gt;.MathJax_Display &#123; overflow: auto hidden; overflow-x: hidden; overflow-y: hidden;&#125;&lt;/style&gt; 参考：https://github.com/theme-next/hexo-theme-next/issues/658 Hexo插入图片 Hexo方式post_asset_folder&quot;#&quot; * 根目录下的配置文件_config.yml里的post_asset_folder选项设置为true。新建文章的时候会同时创建一个同名文件夹用于放图片。 * 执行命令npm install hexo-asset-image --save ，下载安装一个可以上传本地图片的插件： * 使用的时候，只需要图片名就可以 * 也可以使用Hexo推荐的标签方式 Hexo优化速度 禁用背景动画 NexT已经自带了多种背景动画效果，你只需要根据需求在主题配置文件修改其中一个为true即可。 Canvas-nest canvas_nest: false three_waves three_waves: false 禁用mathjax 总配置文件 删掉 123456789101112# 数学公式math: engine: 'mathjax' # or 'katex' mathjax: src: custom_mathjax_source config: # MathJax config katex: css: custom_css_source js: custom_js_source # not used config: # KaTeX config 要让Github Pages被索引到 参考文档： Blog养成记(5) 要让Github Pages被索引到 让Google搜索到搭建在Github Pages上的博客 遇到的问题：node-pre-gyp build fail error while installing with npm install or npm install -d 解决方案： the error got resolved by running 1npm install --build-from-resource 如何使文章多级目录自动展开，而不是默认折叠 如果你想实现默认展开全部目录的功能，可以在themes/next/source/css/_custom/custom.styl文件中添加以下自定义样式规则： 123.post-toc .nav .nav-child &#123; display: block; &#125; 但是通常文章内会出现多级标题，对应的目录里就会有多级导航出现，这时候一些原本你不希望出现的次要标题也会在目录中出现并且无法折叠。可以通过以下样式实现默认只展开两级目录，这样以来就完美解决了该问题。 123.post-toc .nav .nav-level-1&gt;.nav-child &#123; display: block; &#125; 参考博客 Yearito's Blog]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Morris遍历]]></title>
    <url>%2F2019%2F03%2F27%2FMorris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Morris遍历 问题描述：利用Morris遍历实现二叉树的先序，中序，后续遍历，时间复杂度O(N)，额外空间复杂度O(1)。 算法描述 来到的当前节点记为cur（cur是一个引用），如果cur无左孩子，cur向右移动。 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright。 如果mostright的右指针指向空，则让其指向cur，cur向左移动。 如果mostright的右指针指向cur，则让其指向空，cur向右移动。 图解 算法解析如果一个节点有左子树，则回到这个节点两次，若没有，则回到这个节点一次。递归版遍历无论如何可以三次来到一个节点，根据处理时机的不同分为三种顺序的遍历。而Morris遍历是根据一个节点左子树最右指针的指向来判断是第一次来到这个节点还是第二次。第一次来到这个节点处理时记为先序，第二次来到这个节点处理时记为中序。 在第二次来到这个节点时逆序打印它左子树的右边界，最后单独打印整棵树的右边界，记为后序遍历。 算法复杂度整棵树可以分解成由右边界组成，算法有限次的遍历了右边界，所以时间复杂度是O(N)。 Code123456789101112131415# 递归版遍历，方便理解def process_recursive(root, res=None): if root is None: return [] if res is None: res = [] # 1 # res.append(root.val) process_recursive(root.left, res) # 2 # res.append(root.val) process_recursive(root.right, res) # 3 # res.append(root.val) return res 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Morris版遍历def preorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: res.append(cur.val) node.right = cur cur = cur.left else: node.right = None cur = cur.right return resdef inorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res.append(cur.val) node.right = None cur = cur.right return res def postorder_morris(root: Node) -&gt; list: dummy = Node(0) dummy.left = root res = [] cur = dummy while cur: if cur.left is None: cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res += traceBack(cur.left, node) node.right = None cur = cur.right return resdef traceBack(frm, to): res = [] cur = frm while cur is not to: res.append(cur.val) cur = cur.right res.append(to.val) res.reverse() return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a]]></title>
    <url>%2F2018%2F01%2F26%2Fa%2F</url>
    <content type="text"><![CDATA[some content]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
