<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Compiler]]></title>
    <url>%2F2019%2F04%2F09%2FCompiler%2F</url>
    <content type="text"><![CDATA[First SetsDefination: $\text { First }(\mathrm{X})=\left\{\mathrm{t} | \mathrm{X} \rightarrow^{} \mathrm{t} \alpha\right\} \cup\left\{\varepsilon | \mathrm{X} \rightarrow^{} \varepsilon\right\}$ Algorithm sketch: $ \text { First }(\mathrm{t})=\{\mathrm{t}\}​$ $\varepsilon \in \mathrm{First}(\mathrm{X})​$ $ \begin{array}{l}{\text { if } X \rightarrow \varepsilon} \\ {\text { if } X \rightarrow A_{1} \dots A_{n} \text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n}\end{array} ​$ $\text { First }(\alpha) \subseteq \text { First }(\mathrm{X}) \text { if } \mathrm{X} \rightarrow \mathrm{A}_{1} \ldots \mathrm{A}_{\mathrm{n}} \alpha\text { and } \varepsilon \in \text { First }\left(A_{i}\right) \text { for } 1 \leq i \leq n​$ Follow SetsDefination: $\text { Follow }(x)=\left\{t | s \rightarrow^{*} \beta x+\delta\right\}$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lecture 4 (Error and Noise)]]></title>
    <url>%2F2019%2F04%2F03%2FLecture-4-Error-and-Noise%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lecture 3 (The Linear Model I)]]></title>
    <url>%2F2019%2F04%2F01%2FLecture-3-The-Linear-Model-I%2F</url>
    <content type="text"><![CDATA[为了可以尽快上手，将线性模型调整到前面]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单调栈(Monotonic Stack)]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack%2F</url>
    <content type="text"><![CDATA[算法解析 第一种情况 栈底到栈顶是由大到小排列，则使栈顶数弹出的是右边离它最近的比它大的数，新的栈顶数是左边离原栈顶数最近的比它大的数。反之亦然。 第二种情况 栈底到栈顶是由小到大排列，则使栈顶数弹出的是右边离它最近的比它小的数，新的栈顶数是左边离原栈顶数最近的比它小的数。 相关习题 654. Maximum Binary Tree 算法细节：每个数都找到左和右比它大的数，选择其中小的作为父节点，左和右都为空的数则是根节点。 算法正确性（易证）： 构造的是一棵树，而非森林 每个节点最多有两个孩子 84. Largest Rectangle in Histogram 延伸阅读：Jackson Gabbard讲解 12345678910111213141516171819202122class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ stack = [] max_area = 0 index = 0 while index &lt; len(heights): if not stack or heights[stack[-1]] &lt; heights[index]: stack.append(index) index += 1 else: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = heights[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area 85. Maximal Rectangle 总结 单调栈关心的是一维数组上某个数与其周围数的关系。例如寻找距离最近的比它大（或小）的数；在histogram中，前后的bar的高低影响了最终矩形的计算；在最大子矩阵中，把每一行矩阵看做一个直方图。在这些例子中我们可以试图用单调栈来解决。在使用单调栈的时候，想清楚每个元素出栈的意义，什么时候更新index，遇到重复的元素如何处理，栈为空时是什么情况等等。因为每个元素都出栈入栈各一次，所以时间复杂度是O(n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture 2 (Is Learning Feasible?)]]></title>
    <url>%2F2019%2F03%2F30%2FLecture-2-Is-Learning-Feasible%2F</url>
    <content type="text"><![CDATA[\( E_{in}\)]]></content>
      <categories>
        <category>机器学习</category>
        <category>Learning from Data</category>
      </categories>
      <tags>
        <tag>feasible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL树]]></title>
    <url>%2F2019%2F03%2F29%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class AvlTree(object): """ An avl tree. """ def __init__(self): # Root node of the tree. self.node = None self.height = -1 self.balance = 0 def insert(self, key): """ Insert new key into node """ # Create new node n = TreeNode(key) if not self.node: self.node = n self.node.left = AvlTree() self.node.right = AvlTree() elif key &lt; self.node.val: self.node.left.insert(key) elif key &gt; self.node.val: self.node.right.insert(key) self.re_balance() def re_balance(self): """ Re balance tree. After inserting or deleting a node, """ self.update_heights(recursive=False) self.update_balances(False) while self.balance &lt; -1 or self.balance &gt; 1: if self.balance &gt; 1: if self.node.left.balance &lt; 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance &lt; -1: if self.node.right.balance &gt; 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): """ Update tree height """ if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): """ Calculate tree balance factor """ if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): """ Right rotation """ new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): """ Left rotation """ new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root def in_order_traverse(self): """ In-order traversal of the tree """ result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的奇技淫巧]]></title>
    <url>%2F2019%2F03%2F27%2FHexo%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Hexo添加文章时自动打开编辑器 mac下修改文件夹权限： sudo -i进入root模式 chown -R 用户名 /文件夹名 操作步骤： 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。 如果没有这个scripts目录，则新建一个。 scripts目录新建的JavaScript脚本文件可以任意取名。 通过这个脚本，我们用其来监听hexo new这个动作，并在检测到hexo new之后，执行编辑器打开的命令。 Mac平台的Hexo用户将下列内容写入你的脚本： 12345678910var exec = require('child_process').exec;// Hexo 2.x 用户复制这段hexo.on('new', function(path)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + path);&#125;);// Hexo 3 用户复制这段hexo.on('new', function(data)&#123; exec('open -a "markdown编辑器绝对路径.app" ' + data.path);&#125;); 保存并退出脚本之后，在命令行中键入： 1hexo new "auto open editor test" 是不是就顺利的自动打开了自动生成的md文件啦~ Hexo添加评论区 参考: Valine leancloud Hexo内嵌pdf文档 安装插件https://github.com/superalsrk/hexo-pdf 修改主题配置文件 # PDF Support # Dependencies: https://github.com/theme-next/theme-next-pdf pdf: enable: true # Default (true) will load PDFObject / PDF.js script on demand. # That is it only render those page which has `pdf: true` in Front Matter. # If you set it to false, it will load PDFObject / PDF.js srcipt EVERY PAGE. per_page: true height: 500px 其他选择 &lt;center&gt;&lt;embed src=&quot;/pdf/mou.pdf&quot; width=&quot;850&quot; height=&quot;600&quot;&gt;&lt;/center&gt; &lt;iframe src=&quot;/pdf/mou.pdf&quot; style=&quot;width:850px; height:600px;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; Hexo显示数学公式 Hexo博客数学公式显示 MarkDown 插入数学公式实验大集合]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Morris遍历]]></title>
    <url>%2F2019%2F03%2F27%2FMorris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[Morris遍历 问题描述：利用Morris遍历实现二叉树的先序，中序，后续遍历，时间复杂度O(N)，额外空间复杂度O(1)。 算法描述 来到的当前节点记为cur（cur是一个引用），如果cur无左孩子，cur向右移动。 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright。 如果mostright的右指针指向空，则让其指向cur，cur向左移动。 如果mostright的右指针指向cur，则让其指向空，cur向右移动。 图解 算法解析 如果一个节点有左子树，则回到这个节点两次，若没有，则回到这个节点一次。递归版遍历无论如何可以三次来到一个节点，根据处理时机的不同分为三种顺序的遍历。而Morris遍历是根据一个节点左子树最右指针的指向来判断是第一次来到这个节点还是第二次。第一次来到这个节点处理时记为先序，第二次来到这个节点处理时记为中序。 在第二次来到这个节点时逆序打印它左子树的右边界，最后单独打印整棵树的右边界，记为后序遍历。 算法复杂度 整棵树可以分解成由右边界组成，算法有限次的遍历了右边界，所以时间复杂度是O(N)。 Code 123456789101112131415# 递归版遍历，方便理解def process_recursive(root, res=None): if root is None: return [] if res is None: res = [] # 1 # res.append(root.val) process_recursive(root.left, res) # 2 # res.append(root.val) process_recursive(root.right, res) # 3 # res.append(root.val) return res 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Morris版遍历def preorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: res.append(cur.val) node.right = cur cur = cur.left else: node.right = None cur = cur.right return resdef inorder_morris(root): res = [] cur = root while cur: if cur.left is None: res.append(cur.val) cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res.append(cur.val) node.right = None cur = cur.right return res def postorder_morris(root: Node) -&gt; list: dummy = Node(0) dummy.left = root res = [] cur = dummy while cur: if cur.left is None: cur = cur.right else: node = cur.left while node.right and node.right != cur: node = node.right if node.right is None: node.right = cur cur = cur.left else: res += traceBack(cur.left, node) node.right = None cur = cur.right return resdef traceBack(frm, to): res = [] cur = frm while cur is not to: res.append(cur.val) cur = cur.right res.append(to.val) res.reverse() return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a]]></title>
    <url>%2F2018%2F01%2F26%2Fa%2F</url>
    <content type="text"><![CDATA[some content]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
